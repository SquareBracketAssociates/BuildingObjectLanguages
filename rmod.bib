%% Saved with string encoding Unicode (UTF-8)

@inproceedings{Spri16a,
  TITLE = {Hierarchical Layer-Based Class Extensions in Squeak/Smalltalk},
  AUTHOR = {M. Springer and H. Masuhara and R. Hirschfeld},
  BOOKTITLE = {Modularity'2016},
  YEAR = {2016}
}

@inproceedings{Mira15a,
  TITLE = {A Partial Read Barrier for Efficient Support of Live Object-oriented Programming},
  Annote = {topconference},
  AUTHOR = {Miranda, Eliot and B{\'e}ra, Cl{\'e}ment},
  URL = {https://hal.inria.fr/hal-01152610},
  BOOKTITLE = {International Symposium on Memory Management (ISMM '15)},
  ADDRESS = {Portland, United States},
  PAGES = {93-104},
  YEAR = {2015},
  MONTH = jun,
  DOI = {10.1145/2754169.2754186},
  PDF = {https://hal.inria.fr/hal-01152610/file/partialReadBarrier.pdf},
  HAL-ID = {hal-01152610}
}

@inproceedings{Abde07a,
	Annote = {internationalworkshop},
	Author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
	Booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
	Keywords = {moose stefPub kzVisualization},
	Title = {Package References Distribution Fingerprint},
	Year = {2007}}

@inproceedings{Abde08b,
	Abstract = {Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages, allowing classes to be organized into named abstractions. Maintainers of large applications need to understand how packages are structured and how they relate to each other, but this task is very complex because packages often have multiple clients and different roles (class container, code ownership...). Cohesion and coupling are still among the most used metrics, because they help identify candidate packages for restructuring; however, they do not help maintainers understand the structure and interrelationships between packages. In this paper, we present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable visualization centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system. We applied these views on three large case studies: JBoss, Azureus, and ArgoUML.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Hani Abdeen and Ilham Alloui and St\'ephane Ducasse and Damien Pollet and Mathieu Suen},
	Booktitle = {Proceeding of the 12th European Conference on Software Maintenance and Reengineering (CSMR'08)},
	Hal = {http://hal.inria.fr/inria-00200869},
	Hal-Id = {inria-00200869},
	Inria = {ADAM},
	Keywords = {moose cook-pub lse-pub kzVisualization},
	Location = {Athens, Greece},
	Misc = {Acceptance rate: 24/87 = 27\%},
	Pages = {213--222},
	Publisher = {IEEE Computer Society Press},
	Rate = {27\%},
	Selectif = {oui},
	Title = {Package Reference Fingerprint: a Rich and Compact Visualization to Understand Package Relationships},
	Url = {http://rmod.inria.fr/archives/papers/Abde08b-CSMR2008-Fingerprint.pdf},
  Year = {2008}}

@inproceedings{Abde09b,
	Abstract = {Object-oriented (OO) software is usually organized into subsystems using the concepts of package or module. Such modular structure helps applications to evolve when facing new requirements. However, studies show that as soft- ware evolves to meet requirements and environment changes, modularization quality degrades. To help maintainers improve the quality of software modularization we have designed and implemented a heuristic search-based approach for automatically optimizing inter-package connectivity (i.e., dependencies). In this paper, we present our approach and its underlying techniques and algorithm. We show through a case study how it enables maintainers to optimize OO package structure of source code. Our optimization approach is based on Simulated Annealing technique.},
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui and Ilham Alloui},
	Booktitle = {Proceedings of the 16th International Working Conference on Reverse Engineering (WCRE'09)},
	Hal = {http://hal.inria.fr/inria-00425417},
	Hal-Id = {inria-00425417 to recover as lse},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose remoose2 lse-pub cook kzRemodularisation},
	Misc = {acceptance rate: 20/79 = 25\%},
	Pages = {103--112},
	Publisher = {IEEE Computer Society Press},
	Rate = {25\%},
	Selectif = {oui},
	Title = {Automatic Package Coupling and Cycle Minimization},
	Url = {http://rmod.inria.fr/archives/papers/Abde09b-WCRE2009-AutomaticPackageCoupling.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CA},
	X-Proceedings = {yes},
  Year = {2009}}

@phdthesis{Abde09c,
	Abstract = {To cope with the complexity of large object-oriented software systems, developers organize classes into subsystems using the concepts of module or package. Such modular structure helps software systems to evolve when facing new requirements. The organization of classes into packages and/or subsystems represents the software modularization. the software modularization usually follows interrelationships between classes. Ideally, packages should to be loosely coupled and cohesive to a certain extent. However, Studies show that as
    software evolves to meet requirements and environment changes, the software modularization gradually drifts
    and looses quality. As a consequence, the software modularization must be maintained. It is thus important to
    understand, to assess and to optimize the organization of packages and their relationships.
    Our claim is that the maintenance of large and complex software modularizations needs approaches that help in:
    (1) understanding package shapes and relationships; (2) assessing the quality of a modularization, as well as
    the quality of a single package within a given modularization; (3) optimizing the quality of an existing
    modularization.
    In this thesis, we concentrate on three research fields: software visualizations, metrics and algorithms. At
    first, we define two visualizations that help maintainers: (1) to understand packages structure, usage and
    relationships; (2) to spot patterns; and (3) to identify misplaced classes and structural anomalies. In
    addition to visualizations, we define a suite of metrics that help in assessing the package design quality
    (i.e., package cohesion and coupling). We also define metrics that assess the quality of a collection of
    inter-dependent packages from different view points, such as the degree of package coupling and cycles.
    Finally, we define a search-based algorithm that automatically reduces package coupling and cycles only by
    moving classes over existing packages. Our optimization approach takes explicitly into account the original
    class organization and package structure. It also allows maintainers to control the optimization process by
    specifying: (1) the maximal number of classes that may change their packages; (2) the classes that are
    candidate for moving and the classes that should not; (3) the packages that are candidate for restructuring
    and the packages that should not; and (4) the maximal number of classes that a given package can entail.
    The approaches presented in this thesis have been applied to real large object-oriented software systems. The
    results we obtained demonstrate the usefulness of our visualizations and metrics; and the effectiveness of our
    optimization algorithm.},
	Aeres = {AP},
	Annote = {PhD},
	Author = {Hani Abdeen},
	Hal-Id = {tel-00498389 / zi#3ow#h},
	Inria = {RMOD},
	Institution = {INRIA},
	Keywords = {moose remoose2 lse-pub cook kzVisualization kzVisualization},
	School = {Universit\'e de Lille},
	Title = {Visualizing, Assessing and Re-Modularizing Object-Oriented Architectural Elements},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2009-Abdeen.pdf},
	X-Language = {EN},
  Year = {2009}}

@article{Abde10a,
	Abstract = {Context: Object-oriented languages such as Java, Smalltalk, and C\+\+ structure their programs using packages. Maintainers of large systems need to understand how packages relate to each other, but this task is complex because packages often have multiple clients and play different roles (class container, code ownership. . . ). Several approaches have been proposed, among which the use of cohesion and coupling metrics. Such metrics help identify candidate packages for restructuring; however, they do not help maintainers actually understand the structure and interrelation- ships between packages.
Objectives: In this paper, we use pre-attentive processing as the basis for package visualization and see to what extent it could be used in package understanding.
Method: We present the package fingerprint, a 2D visualization of the references made to and from a package. The proposed visualization offers a semantically rich, but compact and zoomable views centered on packages. We focus on two views (incoming and outgoing references) that help users understand how the package under analysis is used by the system and how it uses the system.
Results: We applied these views on four large systems: Squeak, JBoss, Azureus, and ArgoUML. We obtained several interesting results, among which, the identification of a set of recurring visual patterns that help maintainers: (a) more easily identify the role of and the way a package is used within the system (e.g., the package under analysis provides a set of layered services), and, (b) detect either problematic situations (e.g., a single package that groups together a large number of basic services) or opportunities for better package restructuring (e.g., removing cyclic dependencies among packages). The visualization generally scaled well and the detection of different patterns was always possible.
Conclusion: The proposed visualizations and patterns proved to be useful in understanding and maintaining the different systems we addressed. To generalize to other contexts and systems, a real user study is required.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui},
	Doi = {10.1016/j.infsof.2010.07.005},
	Hal-Id = {inria-00531496},
	Impactfactor = {ISI impact factor (2010) 1.821},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Information and Software Technology Journal},
	Keywords = {moose remoose2 lse-pub cook kzVisualisation},
	Pages = {1312-1330},
	Secondurl = {http://rmod.inria.fr/archives/papers/Abde10a-IST-packageFingerprints.pdf},
	Title = {Package Fingerprint: a visual summary of package interfaces and relationships},
	Url = {http://rmod.inria.fr/archives/papers/Abde10a-IST-Official-packageFingerprints.pdf},
	Volume = {52},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Abde11a,
	Abstract = {There exist many large object-oriented software systems consisting of several thousands of classes that are organized into several hundreds of packages. In such software systems, classes cannot be considered as units for software modularization. In such context, packages are not simply classes containers, but they also play the role of modules: a package should focus to provide well identified services to the rest of the software system. Therefore, understanding and assessing package organization is primordial for software maintenance tasks. Although there exist a lot of works proposing metrics for the quality of a single class and/or the quality of inter-class relationships, there exist few works dealing with some aspects for the quality of package organization and relationship. We believe that additional investigations are required for assessing package modularity aspects. The goal of this paper is to provide a complementary set of metrics that assess some modularity principles for packages in large legacy object-oriented software: Information-Hiding, Changeability and Reusability principles. Our metrics are defined with respect to object-oriented dependencies that are caused by inheritance and method call. We validate our metrics theoretically through a careful study of the mathematical properties of each metric.},
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Hani Abdeen and St\'ephane Ducasse and Houari A. Sahraoui},
	Booktitle = {Proceedings of the 18th IEEE International Working Conference on Reverse Engineering (WCRE'11)},
	Hal = {http://hal.inria.fr/inria-00614778/en/},
	Hal-Id = {inria-00614778},
	Inria = {RMOD},
	Keywords = {moose cutter lse-pub raweb2011 kzMetric kzRemodularisation},
	Labo = {dans},
	Misc = {Short paper, acceptance rate: 50/104 = 48\%},
	Publisher = {IEEE Computer Society Press},
	Rate = {acceptance rate (full + short papers): 50/104 = 48\%},
	Selectif = {non},
	Title = {Modularization Metrics: Assessing Package Organization in Legacy Large Object-Oriented Software},
	Url = {http://hal.inria.fr/docs/00/61/45/83/PDF/ModularizationMetrics-INRIA.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@techreport{Abde11i,
	Abstract = {There exist many large object-oriented software systems consisting of several thousands of classes that are organized into several hundreds of packages. In such software systems, classes cannot be considered as units for software modularization. In such context, packages are not simply classes containers, but they also play the role of modules: a package should focus to provide well identified services to the rest of the software system. Therefore, understanding and assessing package organization is primordial for software maintenance tasks. Although there exist a lot of works proposing metrics for the quality of a single class and/or the quality of inter-class relationships, there exist few works dealing with some aspects for the quality of package organization and relationship. We believe that additional investigations are required for assessing package modularity aspects. The goal of this paper is to provide a complementary set of metrics that assess some modularity principles for packages in large legacy object-oriented software: Information-Hiding, Changeability and Reusability principles. Our metrics are defined with respect to object-oriented inter-package and intra-package dependencies. The dependencies that are caused by different types of inter-class dependencies, such as inheritance and method call. We validate our metrics theoretically through a careful study of the mathematical properties of each metric.},
	Aeres = {COM},
	Aeresstatus = {aeres12},
	Annote = {technicalreport},
	Author = {Abdeen, Hani and Ducasse, St{\'e}phane and Sahraoui, Houari A.},
	Hal-Id = {inria-00614583},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {Software Metrics Software Modularization Coupling Cohesion Packages Modularity kzMetric kzRemodularisation},
	Labo = {dans},
	Pdf = {http://hal.inria.fr/inria-00614583/PDF/ModularizationMetrics-INRIA.pdf},
	Selectif = {non},
	Title = {Modularization Metrics: Assessing Package Organization in Legacy Large Object-Oriented Software},
	Url = {http://rmod.inria.fr/archives/reports/Abde11a-TechReport-ModularizationMetrics-INRIA.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@inproceedings{Abde13a,
	Abstract = {Recent studies have largely investigated the detection of class design anomalies. They proposed a large set of metrics that help in detecting those anomalies and in predicting the quality of class design. While those studies and the proposed metrics are valuable, they do not address the particularities of Java interfaces. Interfaces define the contracts that spell out how software modules and logic units interact with each other. This paper proposes a list of design anomalies related to Java interfaces. We identify and describe those anomalies via real examples, taken from well-known Java applications. Then we define three metrics help in automatically estimate the interface design quality, regarding the proposed design anomalies. We evaluate our metrics on three large Java applications. The results show that our metrics are realistic and help in qualifying the interface design, and in identifying candidate refactoringRecently, there has been an important progress in applying search-based optimization techniques to the problem of software re-modularization. Yet, a major part of the existing body of work addresses the problem of modularizing software systems from scratch, regardless of the existing packages structure. This paper presents a novel multi-objective optimization approach for improving existing packages structure. The optimization ap- proach aims at increasing the cohesion and reducing the coupling and cyclic connectivity of packages, by modifying as less as pos- sible the existing packages organization. Moreover, maintainers can specify several constraints to guide the optimization process with regard to extra design factors. To this contribution, we use the Non-Dominated Sorting Genetic Algorithm (NSGA-II). We evaluate the optimization approach through an experiment covering four real-world software systems. The results promise the effectiveness of our optimization approach for improving existing packages structure by doing very small modifications.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Hani Abdeen and Houari Sahraoui and Osama Shata and Nicolas Anquetil and St\'ephane Ducasse},
	Booktitle = {International Working Conference on Reverse Engineering (WCRE'13)},
	Hal-Id = {hal-00862063},
	Keywords = {moose cutter lse-pub kzMetric kzInterface},
	Misc = {Acceptance rate: 38/97 = 39\%},
	Publisher = {IEEE Computer Society Press},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Towards Automatically Improving Package Structure While Respecting Original Design Decisions},
	Url = {http://rmod.inria.fr/archives/papers/Abde13a-ImprovingPackageStructure-WCRE13.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2013}}

@article{Abde14a,
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Hani Abdeen and St\'ephane Ducasse and Damien Pollet and Ilham Alloui and Jean-R\'emy Falleri},
	Hal-Id = {hal-00957695},
	Impactfactor = {5-Year ISI impact factor (2010) 4.865},
	Journal = {Science of Computer Programming},
	Keywords = {lse-pub kzVisualization},
	Labo = {dans},
	Month = feb,
	Selectif = {yes},
	Title = {The Package Blueprint: Visually analyzing and quantifying packages dependencies},
	Url = {http://rmod.inria.fr/archives/papers/Abde14a-Official-PackageBlueprint-SCP.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
  Year = {2014}}

@article{Alle13a,
	Abstract = {Being able to combine static and dynamic typing within the same language has clear benefits in order to support the evolution of prototypes or scripts into mature robust programs. While being an emblematic dynamic object-oriented language, Smalltalk is lagging behind in this regard. We report on the design, implementation and application of Gradualtalk, a gradually-typed Smalltalk meant to enable incremental typing of existing programs. The main design goal of the type system is to support the features of the Smalltalk language, like metaclasses and blocks, live programming, and to accomodate the programming idioms used in practice. We studied a number of existing projects in order to determine the features to include in the type system. As a result, Gradualtalk is a practical approach to gradual types in Smalltalk, with a novel blend of type system features that accomodate most programming idioms.},
	Annote = {internationaljournal},
	Author = {Esteban Allende and Oscar Callau and Johan Fabry and Eric Tanter and Marcus Denker},
	Doi = {10.1016/j.scico.2013.06.006},
	Hal-Id = {hal-00862815},
	Inria = {RMOD},
	Journal = {Science of Computer Programming},
	Keywords = {type systems, gradual typing, smalltalk, lse-pub},
	Title = {Gradual Typing for Smalltalk},
	Url = {http://rmod.inria.fr/archives/papers/Alle13aGradualTyping.pdf},
  Year = {2013}}

@inproceedings{Alli12a,
	Annote = {internationalconference},
	Author = {Simon Allier and Nicolas Anquetil and Andre Hora St\'ephane Ducasse},
	Booktitle = {Proceedings of the 19th International Working Conference on Reverse Engineering (WCRE'12)},
	Hal-Id = {hal-00747817v1},
	Inria = {RMOD},
	Keywords = {lse-pub stefPub kzChecking},
	Misc = {Acceptance rate: 43/138 = 31\%},
	Tagnicolasa = {analysis},
	Title = {A Framework to Compare Alert Ranking Algorithms},
	Url = {http://rmod.inria.fr/archives/papers/Alli12a-wcre2012-ComparisonOfAlertsRankingAlgorithms.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2012}}

@inproceedings{Anqu00a,
	Address = {Los Alamitos, CA, USA},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Anquetil, Nicolas},
	Booktitle = {WCRE'00: Proceedings of the Seventh Working Conference on Reverse Engineering (WCRE'00)},
	Labo = {non},
	Note = {Due to an error of the editor, the paper does not appear in the proceedings},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {Concepts + Relations = 'Abstract Constructs'},
	Url = {http://rmod.inria.fr/archives/papers/Anqu00a-WCRE-Concepts+Relations.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2000}}

@inproceedings{Anqu00b,
	Abstract = {To group related things together (for example to form subsystems); researchers in Reverse Engineering are looking for algorithms that create meaningful groups. One such algorithm, Concept Analysis, received a lot of interest recently. It creates a lattice of concepts, which have some advantages over the more traditional tree of clusters from clustering algorithms.We will argue that the main interest of Concept Analysis lies in the concepts themselves and can be disconnected from the particular structure (the lattice of concepts) in which the concepts are usually arranged. We will compare Concept Analysis to various other algorithms trying to select the most important concepts contained in a set of entities.Our main conclusion is that although it have advantages, the lattice of concepts suffer from a major drawback that other constructs do not have: it returns much more information (concepts) than what it was given in input (a set of entities describing some software system).},
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Anquetil, Nicolas},
	Booktitle = {Proceedings of the 8th International Workshop on Program Comprehension},
	Isbn = {0-7695-0656-9},
	Keywords = {Reverse Engineering, Concept Analysis, Clustering},
	Labo = {non},
	Pages = {231--},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Series = {IWPC '00},
	Tagnicolasa = {architecture},
	Title = {A Comparison of Graphs of Concept for Reverse Engineering},
	Url = {http://rmod.inria.fr/archives/papers/Anqu00b-ICSM-GraphsConcepts.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2000}}

@inproceedings{Anqu01a,
	Abstract = {Program comprehension of legacy systems is a highly knowledge-intensive task. One of the goals of reverse engineering is to propose automated help to relate application domain concepts to all their implementation instances. It is generally accepted that to do so would require analyzing such documentation as identifiers or comments. However, before attempting to perform this difficult analysis, it would be useful to know precisely what information the documentation contains and if it is worth trying. In this paper, we present the results of a study of the knowledge contained in two sources of documentation for the Mosaic system. This knowledge is categorized into various domains, and the relative proportions of these domains are discussed. Among other things, the results highlight the high frequency with which application domain concepts are used, which could provide the means to identify them.},
	Acceptnum = {27},
	Accepttotal = {104},
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Anquetil, Nicolas},
	Booktitle = {WCRE '01: Proceedings of the Eighth Working Conference on Reverse Engineering (WCRE'01)},
	Doi = {10.1109/WCRE.2001.957821},
	Isbn = {0-7695-1303-4},
	Labo = {non},
	Misc = {acceptance rate: 27/104 = 26\%},
	Pages = {166--175},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Characterizing the Informal Knowledge Contained in Systems},
	Url = {http://rmod.inria.fr/archives/papers/Anqu01a-WCRE-InformalKnowledge.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2001}}

@incollection{Anqu02a,
	Address = {New York, NY, USA},
	Aeres = {OS},
	Annote = {articlebook},
	Author = {Lethbridge, Timothy C. and Anquetil, Nicolas},
	Booktitle = {Advances in software engineering: Comprehension, Evaluation, and Evolution},
	Editor = {Hakan Erdogmus, Oryal Tanir},
	Inria = {hors},
	Isbn = {0-387-95109-1},
	Labo = {hors},
	Pages = {137--157},
	Publisher = {Springer-Verlag New York, Inc.},
	Selectif = {non},
	Tagnicolasa = {architecture},
	Title = {Approaches to clustering for program comprehension and remodularization},
	Url = {http://portal.acm.org/citation.cfm?id=505630.505637},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {no},
  Year = {2002}}

@article{Anqu03a,
	Abstract = {As valuable software systems become older, reverse engineering becomes increasingly important to companies that have to maintain the code. Clustering is a key activity in reverse engineering that is used to discover improved designs of systems or to extract significant concepts from code. Clustering is an old, highly sophisticated, activity which offers many methods to meet different needs. The various methods have been well documented in the past; however, conclusions from general clustering literature may not apply entirely to the reverse engineering domain. In the paper, the authors study three decisions that need to be made when clustering: the choice of (i) abstract descriptions of the entities to be clustered, (ii) metrics to compute coupling between the entities, and (iii) clustering algorithms. For each decision, our objective is to understand which choices are best when performing software remodularisation. The experiments were conducted on three public domain systems (gcc, Linux and Mosaic) and a real world legacy system (2 million LOC). Among other things, the authors confirm the importance of a proper description scheme for the entities being clustered, list a few effective coupling metrics and characterise the quality of different clustering algorithms. They also propose description schemes not directly based on the source code, and advocate better formal evaluation methods for the clustering results.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Nicolas Anquetil and Timothy Lethbridge},
	Doi = {10.1049/ip-sen:20030581},
	Journal = {IEE Proceedings - Software},
	Labo = {non},
	Number = {3},
	Pages = {185-201},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Comparative study of clustering algorithms and abstract representations for software remodularization},
	Url = {http://rmod.inria.fr/archives/papers/Anqu03a-IEESoft-ComparativeStudy.pdf},
	Volume = {150},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {2003}}

@inproceedings{Anqu03b,
	Abstract = {Knowledge management is emerging as a promising area to support software engineering activities. The general idea is to use knowledge gained in previous projects to help future ones. We believe this approach is even more relevant when considering software maintenance where maintainers often have to modify a system that they did not develop, that has no documentation, and that nobody knows intimately. Contrasting with this lack of information on the system, maintainers need a lot of knowledge: about the application domain, the organization software maintenance procedures, the system itself, the language used, past development methods, etc. Although one can readily agree with the information needs listed above, there is no clear, exhaustive definition of which knowledge would be useful to perform software maintenance. In this paper we describe our research to identify these needs. This research is part of a long term project that aims at building a knowledge management system for software maintenance.},
	Acceptnum = {71},
	Accepttotal = {159},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira and M{\'a}rcio Greyck Batista Dias and Marcelo Ramal and Ricardo de Moura Meneses},
	Booktitle = {Proceedings of the Fifteenth International Conference on Software Engineering \& Knowledge Engineering (SEKE'2003)},
	Labo = {non},
	Misc = {acceptance rate: 71/159 = 45\%},
	Pages = {61--68},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Knowledge for Software Maintenance},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
	Year = {2003}}

@incollection{Anqu06a,
	Aeres = {OS},
	Annote = {articlebook},
  Author = {Nicolas Anquetil and K\'athia M. de Oliveira and M\'arcio G. B. Dias},
	Booktitle = {Ontologies for Software Engineering and Software Technology},
	Chapter = {5},
	Doi = {10.1007/3-540-34518-3\_5},
	Editor = {Coral Calero, Francisco Ruiz, Mario Piattini},
	Inria = {hors},
	Isbn = {978-3-540-34517-6},
	Labo = {hors},
	Pages = {153--173},
	Publisher = {Springer-Verlag New York, Inc.},
	Selectif = {non},
	Tagnicolasa = {knowledge},
	Title = {Software Maintenance Ontology},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {no},
	Year = {2006}}

@inproceedings{Anqu06c,
	Abstract = {Because they routinely work with intangible goods, software organizations need to be aware of the importance of knowledge. Different knowledge management approaches exist in the literature to help them manage this fundamental asset. However, the current approaches suffer from different problems, like dealing only with explicit knowledge (e.g. in the form of best practices), or focusing on "on demand" knowledge access. In this paper we present a richer, pro-active, knowledge management approach suitable for small or medium organizations. We report on an experiment we conducted with our model.},
	Aeres = {ACT},
	Author = {Alexandre H. Torres and Nicolas Anquetil and K\'athia M. de Oliveira},
	Booktitle = {Proceedings of the Eighth International Workshop on Learning Software Organizations},
	Inria = {hors},
	Labo = {hors},
	Pages = {19--27},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Pro-active dissemination of knowledge with learning histories},
	Url = {http://rmod.inria.fr/archives/papers/Anqu06c-LSO-ProactiveKnowldge.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {BR},
	X-Proceedings = {yes},
  Year = {2006}}

@article{Anqu07a,
	Abstract = {Creating and maintaining software systems is a knowledge intensive task. One needs to have a good understanding of the application domain, the problem to solve and all its requirements, the software process used, technical details of the programming language(s), the system's architecture and how the different parts fit together, how the system interacts with its environment, etc. All this knowledge is difficult and costly to gather. It is also difficult to store and usually lives only in the mind of the software engineers who worked on a particular project. If this is a problem for development of new software, it is even more for maintenance, when one must rediscover lost information of an abstract nature from legacy source code among a swarm of unrelated details. In this paper, we submit that this lack of knowledge is one of the prominent problems in software maintenance. To try to solve this problem, we adapted a knowledge extraction technique to the knowledge needs specific to software maintenance. We explain how we explicit the knowledge discovered on a legacy software during maintenance so that it may be recorded for future use. Some applications on industry maintenance projects are reported.},
	Address = {Newton, MA, USA},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Anquetil, Nicolas and de Oliveira, K\'{a}thia M. and de Sousa, Kleiber D. and Batista Dias, M\'{a}rcio G.},
	Doi = {10.1016/j.infsof.2006.07.007},
	Impactfactor = {Impact Factor (2008) 1.200},
	Issn = {0950-5849},
	Journal = {Information Software Technology},
	Labo = {non},
	Number = {5},
	Pages = {515--529},
	Publisher = {Butterworth-Heinemann},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Software maintenance seen as a knowledge management issue},
	Url = {http://rmod.inria.fr/archives/papers/Anqu07a-IST-MaintenanceKnowledge.pdf},
	Volume = {49},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2007}}

@inproceedings{Anqu08a,
	Abstract = {Traceability is an important challenge for software organizations. This is true for traditional software development and even more so in new approaches that introduce more variety of artefacts such as Model Driven development or Software Product Lines. In this paper we look at some aspect of the interaction of Traceability, Model Driven development and Software Product Line.},
	Address = {Norway},
	Aeres = {ACL},
	Annote = {internationalworkshop},
	Author = {N. {Anquetil} and B. {Grammel} and I. {Galvao Lourenco da Silva} and J.A.R. {Noppen} and S. {Shakil Khan} and H. {Arboleda} and A. {Rashid} and A. {Garcia}},
	Booktitle = {ECMDA Traceability Workshop Proceedings},
	Labo = {non},
	Month = {jun},
	Pages = {77--86},
	Publisher = {SINTEF ICT},
	Selectif = {non},
	Tagnicolasa = {traceability SPL},
	Title = {Traceability for Model Driven, Software Product Line Engineering},
	Url = {http://doc.utwente.nl/64994/},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2008}}

@article{Anqu08b,
	Annote = {nationaljournal},
	Author = {Anquetil, Nicolas and Noppen, Joost and Galv{\~a}o, Ism{\^e}nia},
	Journal = {L'Objet},
	Number = {3},
	Pages = {47--57},
	Publisher = {Lavoisier},
	Tagnicolasa = {traceability SPL},
	Title = {La tra{\c{c}}abilit{\'e} dans les lignes de produits logiciels},
	Volume = {14},
	Year = {2008}}

@article{Anqu08c,
	Annote = {nationaljournal},
	Author = {Anquetil, Nicolas and Arboleda, Hugo and DE ALEXANDRIA FERNANDES, Fabricio and Nunez, Angel and Royer, Jean-Claude},
	Journal = {L'Objet},
	Number = {3},
	Pages = {15--31},
	Publisher = {Lavoisier},
	Tagnicolasa = {traceability SPL},
	Title = {Lignes de produits logiciels et usines logicielles},
	Volume = {14},
	Year = {2008}}

@inproceedings{Anqu09a,
	Annote = {invited},
	Author = {Anquetil, Nicolas and Lethbridge, Timothy C},
	Booktitle = {Reverse Engineering, 2009. WCRE'09. 16th Working Conference on},
	Organization = {IEEE},
	Pages = {7--7},
	Tagnicolasa = {architecture},
	Title = {Ten years later, experiments with clustering as a software remodularization method},
	Year = {2009}}

@inproceedings{Anqu09b,
	Annote = {internationalconference},
	Author = {Anquetil, Nicolas and Royer, J-C and Andre, Pascal and Ardourel, Gilles and Hnetynka, Petr and Poch, Tomas and Petrascu, Dragos and Petrascu, Vladiela},
	Booktitle = {Reverse Engineering, 2009. WCRE'09. 16th Working Conference on},
	Hal-Id = {hal-00457219},
	Organization = {IEEE},
	Pages = {317--318},
	Tagnicolasa = {architecture},
	Title = {Javacompext: Extracting architectural elements from java source code},
	Year = {2009}}

@article{Anqu10a,
	Abstract = {Software product line (SPL) engineering is a recent approach to software development where a set of software products are derived for a well defined target application domain, from a common set of core assets using analogous means of production (for instance, through Model Driven Engineering). Therefore, such family of products are built from reuse, instead of developed individually from scratch. SPL promise to lower the costs of development, increase the quality of software, give clients more flexibility and reduce time to market. These benefits come with a set of new problems and turn some older problems possibly more complex. One of these problems is traceability management. In the European AMPLE project we are creating a common traceability framework across the various activities of the SPL development. We identified four orthogonal traceability dimensions in SPL development, one of which is an extension of what is often considered as "traceability of variability". This constitutes one of the two contributions of this paper. The second contribution is the specification of a metamodel for a repository of traceability links in the context of SPL and the implementation of a respective traceability framework. This framework enables fundamental traceability management operations, such as trace import and export, modification, query and visualization. The power of our framework is highlighted with an example scenario.},
	Address = {Secaucus, NJ, USA},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Anquetil, Nicolas and Kulesza, Uir\'{a} and Mitschke, Ralf and Moreira, Ana and Royer, Jean-Claude and Rummler, Andreas and Sousa, Andr\'{e}},
	Doi = {10.1007/s10270-009-0120-9},
	Hal-Id = {hal-00668175},
	Impactfactor = {Impact Factor (2011) 1.061},
	Issn = {1619-1366},
	Journal = {Journal of Software and Systems Modeling (SOSYM)},
	Labo = {non},
	Number = {4},
	Pages = {427--451},
	Publisher = {Springer-Verlag New York, Inc.},
	Selectif = {oui},
	Tagnicolasa = {traceability SPL},
	Title = {A model-driven traceability framework for software product lines},
	Url = {http://rmod.inria.fr/archives/papers/Anqu10a-SOSYM-TraceabilitySPL.pdf},
	Volume = {9},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {DE,PT,BR},
  Year = {2010}}

@inproceedings{Anqu11a,
	Abstract = {Software re-modularization is an old preoccupation of reverse engineering research. The advantages of a well structured or modularized system are well known. Yet after so much time and efforts, the field seems unable to come up with solutions that make a clear difference in practice. Recently, some researchers started to question whether some basic assumptions of the field were not overrated. The main one consists in evaluating the high-cohesion/low-coupling dogma with metrics of unknown relevance. In this paper, we study a real structuring case (on the Eclipse platform) to try to better understand if (some) existing metrics would have helped the software engineers in the task. Results show that the cohesion and coupling metrics used in the experiment did not behave as expected and would probably not have helped the maintainers reach there goal.
We also measured another possible restructuring which is to decrease the number of cyclic dependencies between modules.
Again, the results did not meet expectations.},
	Acceptnum = {29},
	Accepttotal = {101},
	Address = {Oldenburg, Germany},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Nicolas Anquetil and Jannik Laval},
	Booktitle = {Proceedings of the 15th European Conference on Software Maintenance and Reengineering (CSMR'11)},
	Hal-Id = {hal-00745773},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {moose lse-pub cutter raweb2011 pharo},
	Labo = {dans},
	Misc = {acceptance rate: 29/101 = 29\%},
	Pages = {279--286},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Legacy Software Restructuring: Analyzing a Concrete Case},
	Url = {http://rmod.inria.fr/archives/papers/Anqu11a-CSMR2011-Coupling.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2011}}

@incollection{Anqu11b,
	Annote = {articlebook},
	Author = {Nicolas Anquetil and Uir\'a Kulesza and Ricardo Mateus and Ralf Mitschke and Ana Moreira and Jean-Claude Royer and Andreas Rummler},
	Booktitle = {Aspect-Oriented, Model-Driven Software Product Lines -- The AMPLE way},
	Chapter = {8},
	Doi = {10.1017/CBO9781139003629.008},
	Editor = {Awais Rashid and Jean-Claude Royer and Andreas Rummler},
	Inria = {RMOD},
	Inriareport = {2011},
	Isbn = {978-0-521-76722-4},
	Keywords = {ample lse-pub raweb2011},
	Labo = {dans},
	Pages = {222--262},
	Publisher = {Cambridge University Press},
	Selectif = {non},
	Tagnicolasa = {SPL traceability},
	Title = {Managing information flow in the {SPL} development processes},
	X-Country = {DE PT BR},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {non},
  Year = {2011}}

@incollection{Anqu11c,
	Annote = {articlebook},
	Author = {Phil Greenwood and Vander Alves and John Hutchinson and Christa Schwanninger and Nicolas Anquetil},
	Booktitle = {Aspect-Oriented, Model-Driven Software Product Lines -- The AMPLE way},
	Chapter = {14},
	Doi = {10.1017/CBO9781139003629.014},
	Editor = {Awais Rashid and Jean-Claude Royer and Andreas Rummler},
	Inria = {RMOD},
	Inriareport = {2011},
	Isbn = {978-0-521-76722-4},
	Keywords = {ample lse-pub raweb2011},
	Labo = {dans},
	Pages = {411--443},
	Publisher = {Cambridge University Press},
	Selectif = {non},
	Tagnicolasa = {SPL},
	Title = {Empirical research in software product line engineering},
	X-Country = {UK DE},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {GB},
	X-Proceedings = {non},
  Year = {2011}}

@techreport{Anqu12x,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {Nicolas Anquetil and Damien Cassou and Marcus Denker and St\'ephane Ducasse and Damien Pollet},
	Hal-Id = {hal-00777904},
	Inria = {RMOD},
	Inriareport = {2012},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2012 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Anqu12x-RAWEB-RMOD-2012-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2012}}

@article{Anqu14a,
	Aeres = {AP},
	Annote = {vulgarisation},
	Author = {Nicolas Anquetil and St\'ephane Ducasse and Muhammad U. Bhatti},
	Inria = {RMOD},
	Journal = {ERCIM News},
	Keywords = {moose lse-pub raweb2014 kzIDE kzMoose},
	Labo = {dans},
	Month = oct,
	Pages = {22--23},
	Selectif = {non},
	Tagnicolasa = {analysis},
	Title = {Dedicated Software Analysis Tools},
	Url = {http://ercim-news.ercim.eu/images/stories/EN99/EN99-web.pdf},
	Volume = {99},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {no},
  Year = {2014}}

@techreport{Anqu14b,
  author = 	 {Nicolas Anquetil},
  title = 	 {HDR - Supporting Software Evolution in the Organizations},
  institution = {{Universit{\'e} des Sciences et Technologie de Lille - Lille I}},
  Hal-Id = {tel-01086785},
  year = 	 {2014},
  month = 	 {may},
  annote = 	 {habilitation}
}

@inproceedings{Anqu97a,
	Abstract = {Decomposing complex software systems into conceptually independent subsystems represents a significant software engineering activity that receives considerable research attention. Most of the research in this domain deals with the source code; trying to cluster together files which are conceptually related. In this paper we propose using a more informal source of information: file names. We present an experiment which shows that file naming convention is the best file clustering criteria for the software system we are studying.Based on the experiment results, we also sketch a method to build a conceptual browser on a software system.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Anquetil, Nicolas and Lethbridge, Timothy C.},
	Booktitle = {Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
	Keywords = {clustering},
	Labo = {non},
	Location = {Toronto, Ontario, Canada},
	Month = nov,
	Pages = {184--195},
	Publisher = {IBM Press},
	Selectif = {oui},
	Series = {CASCON'97},
	Tagnicolasa = {architecture},
	Title = {File clustering using naming conventions for legacy systems},
	Url = {http://portal.acm.org/citation.cfm?id=782010.782012},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1997}}

@inproceedings{Anqu98a,
	Abstract = {Reverse engineering is a difficult task even for humans. When trying to provide tools to assist in this task, one should try to take advantage of all possible sources of information.Informal sources, like naming conventions, are more abstract than the code, thus helping to bridge the gap between code and design. On the other hand, there is no certainty that they actually represent the current state of the system.Some researchers have used these informal sources of information, relying on an assumption that if types (or variables, or functions) have the same name then they represent the same thing.However none of these researchers have actually tried to establish to what extent this assumption is valid. This paper provides a framework to study this issue. We will define what it means to have a "reliable naming convention", how this can be tested and under what conditions. We present examples from the particular legacy software system we are studying as well as from the literature.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Nicolas Anquetil and Timothy C. Lethbridge},
	Booktitle = {Proceedings of the 1998 conference of the Centre for Advanced Studies on Collaborative research},
	Labo = {non},
	Location = {Toronto, Ontario, Canada},
	Pages = {213--222},
	Publisher = {IBM Press},
	Selectif = {oui},
	Series = {CASCON'98},
	Tagnicolasa = {knowledge},
	Title = {Assessing the relevance of identifier names in a legacy software system},
	Url = {http://portal.acm.org/citation.cfm?id=783160.783164},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1998}}

@inproceedings{Anqu98b,
	Abstract = {Decomposing complex software systems into conceptually independent subsystems is a significant software engineering activity which received considerable research attention. Most of the research in this domain considers the body of the source code; trying to cluster together files which are conceptually related. This paper discusses techniques for extracting concepts (we call them ``abbreviations'') from a more informal source of information: file names. The task is difficult because nothing indicates where to split the file names into substrings. In general, finding abbreviations would require domain knowledge to identify the concepts that are referred to in a name and intuition to recognize such concepts in abbreviated forms. We show by experiment that the techniques we propose allow about 90\% of the abbreviations to be found automatically. },
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Nicolas Anquetil and Timothy C. Lethbridge},
	Booktitle = {Proceedings of the 20th international conference on Software engineering},
	Isbn = {0-8186-8368-6},
	Labo = {non},
	Location = {Kyoto, Japan},
	Pages = {84--93},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Series = {ICSE'98},
	Tagnicolasa = {architecture},
	Title = {Extracting Concepts from File Names: a New File Clustering Criterion},
	Url = {http://portal.acm.org/citation.cfm?id=302163.302172},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1998}}

@article{Anqu98c,
	Abstract = {Although seemingly simple and intuitive, the object model still contains ambiguous notions. For example, inheritance has been proved to convey two different meanings depending on whether it is behavior or implementation that is inherited. Another conceptually simple notion, multiple inheritance, has not yet been clearly formalized. In this paper, we start by looking at relationships between sibling classes (two immediate subclasses of a common parent). Siblings can be combined through multiple inheritance, or on the contrary, they can be mutually exclusive. We call the relation between incompatible siblings "opposition", and show how it could help in formalizing object models. We then consider widening the explicit use of negation in object models. We argue that negative assertions could be used to validate the creation of new classes to ensure they are compatible with the intended uses of existing classes. Negation leads us to consider the implicit assumption behind object models, we propose to shift from the closed world assumption to the open world assumption.},
	Address = {New York, NY, USA},
	Aeres = {ASCL},
	Annote = {internationaljournal},
	Author = {Anquetil, Nicolas and Vaucher, Jean},
	Doi = {10.1145/609742.609749},
	Issn = {0362-1340},
	Issue = {1},
	Journal = {SIGPLAN Notices},
	Keywords = {multiple inheritance, negation, object model, reflection, theoretical foundations},
	Labo = {non},
	Month = {jan},
	Pages = {48--55},
	Publisher = {ACM},
	Selectif = {non},
	Title = {Expressing opposition in the object model, first step towards negation},
	Volume = {33},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1998}}

@inproceedings{Anqu99a,
	Abstract = {As valuable software systems get old, reverse engineering becomes more and more important to the companies that have to maintain the code. Clustering is a key activity in reverse engineering to discover a better design of the systems or to extract significant concepts from the code. Clustering is an old activity, highly sophisticated, offering many methods to answer different needs. Although these methods have been well documented in the past, these discussions may not apply entirely to the reverse engineering domain. We study some clustering algorithms and other parameters to establish whether and why they could be used for software remodularization. We study three aspects of the clustering activity: abstract descriptions chosen for the entities to cluster; metrics computing coupling between the entities; and clustering algorithms. The experiments were conducted on three public domain systems (gcc, Linux and Mosaic) and a real world legacy system (2 million LOC). Among other things, we confirm the importance of a proper description scheme of the entities being clustered, we list a few good coupling metrics to use and characterize the quality of different clustering algorithms. We also propose novel description schemes not directly based on the source code and we advocate better formal evaluation methods for the clustering results},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Nicolas Anquetil and Timothy Lethbridge},
	Booktitle = {Proceedings of Working Conference on Reverse Engineering (WCRE'99)},
	Doi = {10.1109/WCRE.1999.806964},
	Isbn = {0-7695-0303-9},
	Keywords = {clustering},
	Labo = {non},
	Pages = {235--255},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Experiments with {Clustering} as a {Software} {Remodularization} {Method}},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1999}}

@article{Anqu99b,
	Abstract = {We discuss how to extract a useful set of subsystems from a set of existing source-code file names. This problem is challenging because many legacy systems use thousands of files names, including some that are very short and cryptic. At the same time the problem is important because software maintainers often find it difficult to understand such systems. We propose a general algorithm to cluster files based on their names, and a set of alternative methods for implementing the algorithm. One of the key tasks is picking candidate words to try to identify in file names. We do this by (a) iteratively decomposing file names, (b) finding common substrings, and (c) choosing words in routine names, in an English dictionary or in source-code comments. In addition, we investigate generating abbreviations from the candidate words in order to find matches in file names, as well as how to split file names into components given no word markers. To compare and evaluate our five approaches, we present two experiments. The first compares the "concepts" found in each file name by each method with the results of manually decomposing file names. The second experiment compares automatically generated subsystems with subsystem examples proposed by experts. We conclude that two methods are most effective: extracting concepts using common substrings and extracting those concepts that relate to the names of routines in the files.},
	Aeres = {ACT},
	Annote = {internationaljournal},
  Author = {Nicolas Anquetil and Timothy C. Lethbridge},
	Doi = {10.1002/(SICI)1096-908X(199905/06)11:3<201::AID-SMR192>3.0.CO;2-1},
	Journal = {Journal of Software Maintenance: Research and Practice},
	Labo = {non},
	Misc = {5 Year ISI impact factor (2010) 1.523},
	Pages = {201--21},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Recovering Software Architecture from the Names of Source Files},
	Volume = {11},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1999}}

@article{Aran14a,
	Author = {Aranega, Vincent and Mottu, Jean-Marie and Etien, Anne and Degueule, Thomas and Baudry, Benoit and Dekeyser, Jean-Luc},
	Doi = {10.1002/stvr.1532},
	Issn = {1099-1689},
	Hal-Id = {hal-00988164},
	annote = {internationaljournal},
	Journal = {Software Testing, Verification and Reliability},
	Keywords = {MDE, model transformation, mutation analysis, traceability, mutation operator},
	Title = {Towards an automation of the mutation analysis dedicated to model transformation},
	Url = {http://dx.doi.org/10.1002/stvr.1532},
  Year = {2014}}

@booklet{Ardi95b,
	Annote = {lectures},
	Author = {Laurent Arditi and St\'ephane Ducasse},
	Keywords = {stefPub kzTeaching},
	Note = {support de cours de Deug SM-PE et Mass, 120 pages},
	Title = {Une premi\`ere approche fonctionnelle et r\'ecursive de la programmation},
	Year = {1995}}

@book{Ardi96a,
	Address = {Paris},
	Annote = {book},
	Author = {Laurent Arditi and St\'ephane Ducasse},
	Isbn = {2-212-08915-5},
	Keywords = {stefPub scglib kzBook kzTeaching},
	Month = apr,
	Note = {238 pages, Pr\'eface de G\'erard Huet},
	Publisher = {Eyrolles},
	Title = {La programmation: une approche fonctionelle et r\'ecursive avec Scheme},
	Year = {1996}}

@inproceedings{Ardi97a,
	Abstract = {Dans cet article, nous pr\'esentons une exp\'erience d'enseignement de l'informatique en milieu aride: volume horaire faible, faible coefficient, \'etudiants peu motiv\'es. Dans ce contexte d\'efavorable, nous avons choisi de privil\`egier un concept, la r\'ecursivit\'e dans le cadre de la programmation fonctionnelle, plut\^ot qu'un langage.  Ce choix nous a conduit \`a consid\`erer le langage Scheme pour sa simplicit\'e. Nous d\'ecrivons ici notre cours, les probl\`emes que nous avons rencontr\'es et les solutions que nous avons choisies.},
	Annote = {nationalconference},
	Author = {Laurent Arditi and St\'ephane Ducasse},
	Booktitle = {Actes des Journ\'ees Fran\c{c}aises des Langages Applicatifs (JFLA '97)},
	Hal-Id = {inria-00533051},
	Keywords = {stefPub kzTeaching},
	Pages = {209--228},
	Title = {Scheme: un langage applicatif pour l'enseignement de l'informatique en milieu aride},
	Url = {http://scg.unibe.ch/archive/papers/Ardi97aSchemeTeaching.pdf},
  Year = {1997}}

@inproceedings{Arev03c,
	Abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views -- a technique based on Concept Analysis --  which reveal the internal relationships between groups of methods and attributes of a class. XRay views are com- posed out of elementary collaborations between attributes and methods, and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it on the Smalltalk class UIBuilder.},
	Annote = {internationalconference},
	Author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 18th Conference on Automated Software Engineering (ASE'03)},
	Cvs = {ConAnASE03XRayViews},
	Doi = {10.1109/ASE.2003.1240318},
	Hal-Id = {inria-00533054},
	Keywords = {recast03 scg-pub stefPub moose arevalo jb04 kzRemodularisation},
	Month = oct,
	Note = {Short paper},
	Pages = {267--270},
	Publisher = {IEEE Computer Society},
	Secondurl = {http://scg.unibe.ch/archive/papers/Arev03cASE03XRayViews.pdf},
	Title = {{X-Ray} Views: Understanding the Internals of Classes},
	Url = {http://rmod.inria.fr/archives/papers/Arev03c-ASE03-XRayViews.pdf},
  Year = {2003}}

@inproceedings{Arev03d,
	Abstract = {Understanding the internal workings of classes is a key prerequisite to maintaining an object-oriented software system. Unfortunately, classical editing and browsing tools offer mainly linear and textual views of classes and their implementation. These views fail to expose the semantic relationships between the internal parts of a class. We propose XRay views --a technique based on Concept Analysis-- which reveal the internal relationships between groups of methods and attributes of a class. XRay views are composed out of elementary collaborations between attributes and methods and help the engineer to build a mental model of how a class works internally. In this paper we present XRay views, and illustrate the approach by applying it to three Smalltalk classes: OrderedCollection, Scanner, and UIBuilder.},
	Annote = {internationalworkshop},
	Author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 2nd International Workshop on MASPEGHI 2003 (ASE'03)},
	Cvs = {ConAnMASPEGHI03XRayViews},
	Keywords = {snf04 scg-pub skip-doi stefPub arevalo jb04 moose kzRemodularisation},
	Month = oct,
	Pages = {9--18},
	Publisher = {CRIM --- University of Montreal (Canada)},
	Title = {Understanding Classes using {X-Ray} Views},
	Url = {http://scg.unibe.ch/archive/papers/Arev03dMASPEGHI03XRayViews.pdf},
  Year = {2003}}

@inproceedings{Arev05b,
	Abstract = {Object-oriented applications are difficult to extend and maintain, due to the presence of implicit dependencies in the inheritance hierarchy. Although these dependencies of- ten correspond to well-known schemas, such as hook and template methods, new unanticipated dependency schemas occur in practice, and can consequently be hard to recognize and detect. To tackle this problem, we have applied Concept Analysis to automatically detect recurring dependency schemas in class hierarchies used in object-oriented applications. In this paper we describe our mapping of OO dependencies to the formal framework of Concept Analysis, we apply our approach to a non-trivial case study, and we report on the kinds of dependencies that are uncovered with this technique. As a result, we show how the discovered dependency schemas correspond not only to good design practices, but also to "bad smells" in design.},
	Acceptnum = {33},
	Accepttotal = {81},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
	Cvs = {ConAnCSMR05ClassHierarchies},
	Doi = {10.1109/CSMR.2005.24},
	Hal-Id = {inria-00533057},
	Impactfactor = {hors},
	Keywords = {scg-pub arevalo jb05 recast05 stefPub moose kzRemodularisation},
	Location = {Manchester, United Kingdom},
	Misc = {acceptance rate: 33/81 = 41\%},
	Month = mar,
	Pages = {62--71},
	Publisher = {IEEE Computer Society},
	Rate = {41\%},
	Secondurl = {http://scg.unibe.ch/archive/papers/Arev05bCSMR05ClassHierarchies.pdf},
	Selectif = {non},
	Title = {Discovering Unanticipated Dependency Schemas in Class Hierarchies},
	Url = {http://rmod.inria.fr/archives/papers/Arev05b-CSMR05-ClassHierarchies.pdf},
  Year = {2005}}

@inproceedings{Arev05c,
	Abstract = {A key difficulty in the maintenance and evolution of complex software systems is to recognize and understand the implicit dependencies that define contracts that must be respected by changes to the software. Formal Concept Analysis is a well-established technique for identifying groups of elements with common sets of properties. We have successfully applied FCA to complex software systems in order to automatically discover a variety of different kinds of implicit, recurring sets of dependencies amongst design artifacts. In this paper we describe our approach, outline three case studies, and draw various lessons from our experiences. In particular, we discuss how our approach is applied iteratively in order to draw the maximum benefit offered by FCA.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Gabriela Ar{\'e}valo and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 3rd International Conference on Formal Concept Analysis (ICFCA'05)},
	Cvs = {ConAnICFCA05LessonsLearned},
	Doi = {10.1007/b105806},
	Hal-Id = {inria-00533445},
	Impactfactor = {hors},
	Keywords = {scg-pub jb05 recast05 arevalo stefPub kzRemodularisation},
	Location = {Lens, France},
	Month = feb,
	Pages = {95--112},
	Publisher = {Springer Verlag},
	Secondurl = {http://scg.unibe.ch/archive/papers/Arev05cICFCA05LessonsLearned.pdf},
	Selectif = {non},
	Series = {LNAI (Lecture Notes in Artificial Intelligence)},
	Title = {Lessons Learned in Applying Formal Concept Analysis},
	Url = {http://rmod.inria.fr/archives/papers/Arev05c-ICFCA05-LessonsLearned.pdf},
	Volume = {3403},
  Year = {2005}}

@inproceedings{Arev06a,
	Abstract = {Designing class models is usually an iterative process to detect how to express, for a specific domain, the adequate concepts and their relationships. During those iterations, the abstraction of concepts and relationships is an important step. In this paper, we propose to automate this abstraction process using techniques based on Formal Concept Analysis in a model-driven context. Using UML 2.0 class diagrams as modeling language for class models, in this proposal we show how our model-driven approach enables parameterization, tracing and generalization to any metamodel to express class models.},
	Author = {Gabriela Ar\'evalo and Jean-R\'emy Falleri and Marianne Huchard and Cl\'ementine Nebut},
	Booktitle = {MODELS'06},
	Editor = {Oscar Nierstrasz; Jhon Whittle; David Harel; Gianna Reggio},
	Isbn = {978-3-540-45772-5},
	Keywords = {UML, model transformation, refactoring, formal concept analysis, relational concept analysis},
	Month = oct,
	Pages = {513-527},
	Publisher = {Springer Verlag},
	Series = {{LNCS} ({L}ecture {N}otes in {C}omputer {S}cience)},
	Title = {Building Abstractions in Class Models: Formal Concept Analysis in a Model-Driven Approach},
	Volume = {4199},
	Year = {2006}}

@article{Arev10a,
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Gabriela Ar\'evalo and St\'ephane Ducasse and Silvia Gordillo and Oscar Nierstrasz},
	Doi = {10.1016/j.infsof.2010.05.010},
	Hal-Id = {inria-00531498},
	Impactfactor = {ISI impact factor (2010) 1.821},
	Inria = {RMOD},
	Inriareport = {2010},
	Issn = {0950-5849},
	Journal = {Journal of Information and Software Technology},
	Keywords = {moose lse-pub cook report2010 kzRemodularisation},
	Month = dec,
	Pages = {1167-1187},
	Secondurl = {http://rmod.inria.fr/archives/papers/Arev10a-IST-Official-generatingCatalog.pdf},
	Title = {Generating a catalog of unanticipated schemas in class hierarchies using Formal Concept Analysis},
	Url = {http://rmod.inria.fr/archives/papers/Arev10a-IST-generatingCatalog.pdf},
	Volume = {52},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {AR,CH},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Arlo16a,
	TITLE = {{Pillar: A Versatile and Extensible Lightweight Markup Language}},
	AUTHOR = {Thibault Arloing and Yann Dubois and Damien Cassou and Ducasse, St{\'e}phane},
	URL = {http://rmod.inria.fr/archives/papers/Arlo16a-IWST16-Pillar.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01353882},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@inproceedings{Arna10a,
	Abstract = {Supporting read-only and side effect free execution has been the focus of a large body of work in the area of statically typed programming languages. Read-onlyness in dynamically typed languages is difficult to achieve because of the absence of a type checking phase and the support of an open-world assumption in which code can be constantly added and modified. To address this issue, we propose Dynamic Read-Only references (DRO) that provide a view on an object where this object and its object graph are protected from modification. The read- only view dynamically propagates to aggregated objects, without changing the object graph itself; it acts as a read-only view of complex data structures, without making them read-only globally. We implement dynamic read-only references by using smart object proxies that lazily propagate the read-only view, following the object graph and driven by control flow and applied them to realize side-effect free assertions.},
	Address = {Malaga, Spain},
	Annote = {internationalconference},
	Author = {Jean-Baptiste Arnaud and Marcus Denker and St\'ephane Ducasse and Damien Pollet and Alexandre Bergel and Mathieu Suen},
	Booktitle = {Proceedings of the 48th International Conference Objects, Models, Components, Patterns (TOOLS'10)},
	Doi = {10.1007/978-3-642-13953-6\_7},
	Hal = {http://hal.archives-ouvertes.fr/inria-00498377/fr/},
	Hal-Id = {inria-00498377 / 7a#ndah},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {tools10 lse-pub marcusdenker pharo kzReferences},
	Misc = {25\%},
	Month = jun,
	Rate = {25\%},
	Title = {Read-Only Execution for Dynamic Languages},
	Url = {http://rmod.inria.fr/archives/papers/Arna10a-Tools2010-ReadOnlyExecutionForDynamicLanguages.pdf},
	X-Country = {CL},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2010}}

@phdthesis{Arna13a,
	Abstract = {Dynamically-typed object-oriented programming languages do not provide type information until runtime. Two of their main advantages are that they allow fast prototyping and integrating changes at runtime. The ability of dynamically-typed languages to support program changes at runtime and the lack of type information doom the classic security approaches to failure. Controlling references to single objects and to graphs of objects is essential to build secure systems. Existing approaches are commonly based on static type system and cannot be applied to dynamically-typed languages.This thesis argue that: In the context of dynamically-typed languages, reifying references, controlling behavior, and isolating state via such references, is a practical way to control references. This thesis makes five contributions: - We propose dynamic read-only objects (DRO) as one kind of adaptation of behavioral change at reference-level. - We generalize the DRO model to enable more generic behavioral changes. We extend the Pharo programming environment and language with Handles, that are first-class references with the ability to change the behavior of referenced objects. - We define Metahandle to offer flexibility and adaptability to controlled references. - We propose SHandle, an extension of the Handle model to isolate side effects at the level of references. - And finally, we formalize the Handles and SHandle models to represent and explain their semantics. As validation of our thesis we have implemented three approaches  relevant to securing system using our model. In addition, as proof of concept we extended the Pharo virtual machine to support Handles, Metahandles and SHandles.},
	Author = {Jean-Baptiste Arnaud},
	Hal-Id = {tel-00808419},
	Inriareport = {2013},
	Institution = {INRIA},
	Keywords = {security, dynamically-typed languages, reflection, language design, first class reference, object-oriented programming},
	School = {Universit\'e de Lille},
	Title = {Towards First Class References as a Security Infrastructure in Dynamically-Typed Languages},
	Type_Rapport = {PhD},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2013-Arnaud.pdf},
  Year = {2013}}

@article{Arna14a,
	Abstract = {Controlling object graphs and giving specific semantics to references (such as read-only, owner- ship, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is an underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first-class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementa- tion of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Jean-Baptiste Arnaud and St\'ephane Ducasse and Marcus Denker and Camille Teruel},
	Hal = {http://hal.inria.fr/hal-01060537},
	Hal-Id = {hal-01060537},
	Impactfactor = {(Core A), 5-year impact factor (2012) 0.903},
	Inria = {RMOD},
	Inriareport = {2015},
	Pages = {318-338},
	Volume = {98},
	Issue = {3},
	Journal = {Journal of Science of Computer Programming},
	Keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzLanguageDesign},
	Title = {Handles: Behavior-Propagating First Class References For Dynamically-Typed Languages},
	Url = {http://rmod.inria.fr/archives/papers/Arna14a-SCICO-Handles.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2015}}

@inproceedings{Auth12a,
	Abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and with no entropy creation. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {nationalconference},
	Author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
	Booktitle = {INFORSID},
	Hal-Id = {hal-00707536},
	Inria = {RMOD},
	Keywords = {moose lse-pub kzReengineerig},
	Selectif = {non},
	Title = {Interop\'erabilit\'e des syst\`emes d'information : approches dirig\'ees par les mod\`eles},
	Url = {http://rmod.inria.fr/archives/papers/Auth12a-interop-si-2012.pdf},
  Year = {2012}}

@article{Auth13a,
	Abstract = {Information systems are more and more often based on aggregation of other systems that must be maintained and evolved in an agile way and without uncontrolled entropy. This is not without interoperability problems! Among others, the aim of Model-Driven Engineering (MDE) is to provide solutions for interoperability issues between systems. This paper summarizes thoughts that have come up from the specific action Interoperability of information systems and model-driven engineering: What challenges? What solutions? supported by inforsid. We propose a summary of approaches that are based on MDE and knowledge engineering and that tackle interoperability issues in the industry. Open questions and limitations that raised during the meetings are also reported.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {nationaljournal},
	Author = {Authosserre-Cavarero, Annie and Bertrand, Frederic and Blay-Fornarino, Mireille and Collet, Philippe and Dubois, Hubert and Ducasse, St\'ephane and Dupuy-Chessa, Sophie and Faron-Zucker, Catherine and Faucher, Cyril and Lafaye, Jean-Yves and Lahire, Philippe and Le Goaer, Olivier and Montagnat, Johan and Pinna-Dery, Anne-Marie},
	Hal-Id = {hal-00813675},
	Inria = {RMOD},
	Journal = {Revue Ing\'enierie des Syst\`emes d'Information},
	Keywords = {moose lse-pub kzReengineerig},
	Pages = {9-40},
	Selectif = {non},
	Title = {Ing\'enierie dirig\'ee par les mod\`eles : quels supports \`a l'interop\'erabilit\'e des syst\`emes},
	Url = {http://rmod.inria.fr/archives/papers/Auth13a-interop-si-JournalVersion.pdf},
	Volume = {18},
  Year = {2013}}

@misc{Auve11a,
	Aeres = {OV},
	Aeresstatus = {aeres12},
	Annote = {vulgarisation},
	Author = {Olivier Auverlot and St\'ephane Ducasse},
	Hal-Id = {hal-00746254},
	Inria = {RMOD},
	Inriareport = {2011},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzWeb},
	Month = sep,
	Number = 141,
	Selectif = {non},
	Title = {Construire un service Rest avec Pharo et Seaside-Rest},
	Volume = 1,
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {no},
	X-Language = {FR},
	X-Proceedings = {yes},
	X-Scientific-Popularization = {yes},
	Year = {2011}}

@misc{Auve16a,
	Annote = {vulgarisation},
	Author = {Olivier Auverlot and St\'ephane Ducasse},
	Journal = {GNU Linux Magazine},
	Keywords = {pharo-pub lse-pub  pharo kzWeb},
	Month = jan,
	Hal-id = {hal-01353594},
	Number = 189,
	Selectif = {non},
	Title = {Un Chat en Pharo},
	Year = {2016}
}

@misc{Auve16b,
	Annote = {vulgarisation},
	Author = {Olivier Auverlot},
	Journal = {GNU Linux Magazine},
	Keywords = {pharo-pub lse-pub pharo },
	Month = feb,
	Hal-ID = {hal-01353596},
	Number = 190,
	Selectif = {non},
	Title = {{Pharo : g\'en\'erer des documents PDF avec Artefact}},
	Year = {2016}
}

@techreport{Balm09a,
	Abstract = {The objective of this workpackage is to define a catalog of software metrics. In particular we analyze the metrics used in the Squale Model and tool. In addition it offers a coherent set of software metrics for object-oriented languages on top of which Squale practices will be based. There is a plethora of software metrics [LK94, FP96, HS96, HK00, LM06] and a large amount of research articles. Still there is a lack for a serious and practically-oriented evaluation of metrics. Often metrics lacks the property that the software reengineer or quality expert can easily understand the situation summarized by the metrics. In particular since the exact notion of coupling and cohesion is complex, a particular focus on such point is important.},
	Annote = {technicalReport},
	Author = {Fran\c{c}oise Balmas and Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet and Hani Abdeen and Fabrice Bellingard},
	Hal-Id = {inria-00533617},
	Inria = {RMOD},
	Inriareport = {2009},
	Institution = {INRIA Lille Nord Europe},
	Keywords = {squale-pub lse-pub deliverable11 kzMetric},
	Title = {Software metric for Java and C\+\+ practices (Squale Deliverable 1.1)},
	Url = {http://rmod.inria.fr/archives/reports/Balm09a-Squale-deliverable11-Metrics.pdf},
  Year = {2009}}

@techreport{Balm09c,
	Abstract = {This document presents the Squale Software Quality Model as defined by Qualixo. It first reviews existing quality models and presents the Squale model with its particularity, namely a practice layer. Then it reviews in details an instance of this Squale Model with its Factors, Criteria and Practices, giving precise definitions and description1. Finally, it discusses possible future enhancements of this model like new practices or its agreement with the program life-cycle and the change of needs during this life cycle.},
	Aeres = {AP},
	Author = {Fran\c{c}oise Balmas and Fabrice Bellingard and Simon Denier and St\'ephane Ducasse and Jannik Laval and Karine Mordal-Manet},
	Hal-Id = {inria-00533654},
	Inria = {RMOD},
	Inriareport = {2009},
	Institution = {INRIA},
	Keywords = {squale-pub lse-pub deliverable13 kzMetric kzQualityModel},
	Title = {Practices in the Squale Quality Model (Squale Deliverable 1.3)},
	Url = {http://rmod.inria.fr/archives/reports/Balm09c-Squale-deliverable13-Practices.pdf},
	X-Language = {EN},
  Year = {2009}}

@inproceedings{Bera13a,
	Abstract = {The Pharo Smalltalk-inspired language and environment started its development with a codebase that can be traced back to the original
	Smalltalk-80 release from 1983. Over the last years, Pharo has been used as the basis of many research projects. Often these experiments needed
	changes related to the compiler infrastructure. However, they did not use the existing compiler and instead implemented their own experimental solutions.
	This shows that despite being an impressive achievement considering its age of over 35 years, the compiler infrastructure needs to be improved.
	We identify three problems: (i) The architecture is not reusable, (ii) compiler  can not be parametrized and (iii) the mapping between source code
	and bytecode is overly complex.
	Solving these problems will not only help researchers to develop new language features, but also the enhanced power of the infrastructure
	allows many tools and frameworks to be built that are important even for day-to-day development, such as debuggers and code transformation tools.
    In this paper we discuss the three problems, show how these are solved with a new Compiler model. We present an implementation, Opal, and show how
	Opal is used as the bases for many important tools for the everyday development of Pharo 3.},
	Annote = {internationalworkshop},
	Author = {Cl\'ement B\'era and Marcus Denker},
	Booktitle = {International Workshop on Smalltalk Technologies 2013},
	Hal-Id = {hal-00862411},
	Keywords = {pharo marcusdenker lse-pub},
	Title = {Towards a flexible Pharo Compiler},
	Url = {http://rmod.inria.fr/archives/papers/Bera13a-OpalIWST.pdf},
  Year = {2013}}

@inproceedings{Bera14a,
  TITLE = {A bytecode set for adaptive optimizations},
  AUTHOR = {B{\'e}ra, Cl{\'e}ment and Miranda, Eliot},
  Url = {http://rmod.inria.fr/archives/papers/Bera14a-IWST-BytecodeSet.pdf},
  booktitle = {International Workshop on Smalltalk Technologies (IWST 14)},
  annote = {internationalworkshop},
  YEAR = {2014},
  MONTH = aug,
  HAL-ID = {hal-01088801}}

@article{Bera16a,
	Author = {Cl\'ement B\'era and  Eliot Miranda and Marcus Denker and  St\'ephane Ducasse},
	journal = {Journal of Object Technology},
	Hal-Id = {hal-01299371},
	Annote = {internationaljournal},
	Abstract ={Speculative inlining in just-in-time compilers enables many performance optimizations. However, it also introduces significant complexity. The compiler optimizations themselves, as well as the deoptimization mechanism are complex and error prone. To stabilize our bytecode to bytecode just-in-time compiler, we designed a new approach to validate the correctness of dynamic deoptimization. The approach consists of the symbolic execution of an optimized and an unop-timized bytecode compiled method side by side, deoptimizing the abstract stack at each deoptimization point (where dynamic deoptimization is possible) and comparing the deoptimized and unoptimized abstract stack to detect bugs. The implementation of our approach generated tests for several hundred thousands of methods, which are now available to be run automatically after each commit.},
	Keywords = {stefpub lse-pub marcusdenker},
	Doi = {10.5381/jot.2016.15.2.a1.},
	Pages = {1:1-26},
	Volume = {15},
	Number = {2},
	Title = {Practical Validation of Bytecode to Bytecode JIT Compiler Dynamic Deoptimization},
	Url = {https://hal.inria.fr/hal-01299371},
	Url = {http://rmod.inria.fr/archives/papers/Bera16aPracticalValidation-JOT.pdf},
	Year = {2016}}

@inproceedings{Berg03a,
	Abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of Joint Modular Languages Conference (JMLC'03)},
	Doi = {10.1007/b12023},
	Hal-Id = {inria-00533446},
	Inria = {hors},
	Isbn = {978-3-540-40796-6},
	Keywords = {module classbox kzClassBox},
	Note = {Best Paper Award},
	Pages = {122--131},
	Publisher = {Springer-Verlag},
	Secondurl = {http://scg.unibe.ch/archive/papers/Berg03aClassboxes.pdf},
	Selectif = {non},
	Series = {LNCS},
	Title = {Classboxes: A Minimal Module Model Supporting Local Rebinding},
	Url = {http://rmod.inria.fr/archives/papers/Berg03a-JLMC03-Classboxes.pdf},
	Volume = {2789},
  Year = {2003}}

@inproceedings{Berg03b,
	Abstract = {Classical module systems support well the modular development of applications but do not offer the ability to add or replace a method in a class that is not defined in that module. On the other hand, languages that support method addition and replacement do not provide a modular view of applications, and their changes have a global impact. The result is a gap between module systems for object-oriented languages on one hand, and the very desirable feature of method addition and replacement on the other hand. To solve these problems we present classboxes, a module system for object-oriented languages that provides method addition and replacement. Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model, we have implemented it in the Squeak Smalltalk environment, and performed experiments modularising code.},
	Aeres = {ACT},
	Aeresstatus = {aeres05},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Inria = {hors},
	Keywords = {stefPub alexPub module classbox kzClassBox},
	Month = jul,
	Selectif = {non},
	Title = {The {Classbox} Module System},
	Url = {http://scg.unibe.ch/archive/papers/Berg03bClassboxes.pdf},
  Year = {2003}}

@techreport{Berg04a,
	Abstract = {A class extension is a method that is defined in a module, but whose class is defined elsewhere. Class extensions offer a convenient way to incrementally modify existing classes when subclassing is inappropriate. Unfortunately existing approaches suffer from various limitations. Either class extensions have a global impact, with possibly negative effects for unexpected clients, or they have a purely local impact, with negative results for collaborating clients. Furthermore, conflicting class extensions are either disallowed, or resolved by linearization, with consequent negative effects.  To solve these problems we present classboxes, a module system for object-oriented languages that provides for method addition and replacement.  Moreover, the changes made by a classbox are only visible to that classbox (or classboxes that import it), a feature we call local rebinding. To validate the model we have implemented it in the Squeak Smalltalk environment, and performed benchmarks.},
	Address = {Universit\"at Bern, Switzerland},
	Aeres = {AP},
	Aeresstatus = {aeres05},
	Annote = {report notrefereed technicalReport},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Inria = {hors},
	Institution = {Institut f\"ur Informatik},
	Keywords = {stefPub alexPub kzClassBox},
	Misc = {ClassboxTR04},
	Month = jun,
	Number = {IAM-04-003},
	Selectif = {non},
	Title = {Classboxes: Controlling Visibility of Class Extensions},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Berg04aIAM-04-003.pdf},
  Year = {2004}}

@inproceedings{Berg04c,
	Abstract = {With prototype-based languages, concretization and abstraction are unified into a single concept a prototype. Prototype-based languages are based on a simple set of principles: object-centered representation, dynamic reshape of objects, cloning and possibly message delegation. However, they all differ in the interpretation and combination of these principles. Therefore there is a need to compare and understand. In this paper we present Prototalk, a research and teaching vehicle to understand, implement and compare prototype-based languages. Prototalk is a framework that offers a predefined set of language data structures and mechanisms that can be composed and extended to generate various prototype-based language interpreters. It presents a classification of languages based on different mechanisms in an operational manner.},
	Aeres = {ACT},
	Aeresstatus = {aeres05},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and Christophe Dony and St\'ephane Ducasse},
	Booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
	Cvs = {PrototalkESUG04},
	Hal-Id = {inria-00533452},
	Inria = {hors},
	Keywords = {stefPub alexPub kzPrototype},
	Month = sep,
	Pages = {107--130},
	Secondurl = {http://scg.unibe.ch/archive/papers/Berg04cprototalk.pdf},
	Selectif = {non},
	Title = {Prototalk: an Environment for Teaching, Understanding, Designing and Prototyping Object-Oriented Languages},
	Url = {http://rmod.inria.fr/archives/papers/Berg04c-ISC04-prototalk.pdf},
  Year = {2004}}

@article{Berg05a,
	Abstract = {A class extension is a method that is defined in a module, but whose class is
defined elsewhere. Class extensions offer a convenient way to incrementally modify existing
classes when subclassing is inappropriate. Unfortunately existing approaches suffer from
various limitations. Either class extensions have a global impact, with possibly negative
effects for unexpected clients, or they have a purely local impact, with negative results
for collaborating clients. Furthermore, conflicting class extensions are either disallowed,
or resolved by linearization, with consequent negative effects. To solve these problems we
present classboxes, a module system for object-oriented languages that provides for method
addition and replacement. Moreover, the changes made by a classbox are only visible to that
classbox (or classboxes that import it), a feature we call local rebinding. To validate the
model we have implemented it in the Squeak Smalltalk environment, and performed
benchmarks.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Cvs = {ClassboxESUG04},
	Doi = {10.1016/j.cl.2004.11.002},
	Hal-Id = {inria-00533458},
	Impactfactor = {Impact factor (2010) 0.541},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {classbox stefPub kzClassbox},
	Month = dec,
	Number = {3-4},
	Pages = {107--126},
	Publisher = {Elsevier},
	Secondurl = {http://scg.unibe.ch/archive/papers/Berg05aclassboxesJournal.pdf},
	Selectif = {non},
	Title = {Classboxes: Controlling Visibility of Class Extensions},
	Url = {http://rmod.inria.fr/archives/papers/Berg05a-CompLangESUG04-classboxesJournal.pdf},
	Volume = {31},
  Year = {2005}}

@inproceedings{Berg05b,
	Abstract = {Unanticipated changes to complex software systems can introduce anomalies such as duplicated code, suboptimal inheritance relationships and a proliferation of run-time downcasts. Refactoring to eliminate these anomalies may not be an option, at least in certain stages of software evolution.  Classboxes are modules that restrict the visibility of changes to selected clients only, thereby offering more freedom in the way unanticipated changes may be implemented, and thus reducing the need for convoluted design anomalies. In this paper we demonstrate how classboxes can be implemented in statically-typed languages like {Java}. We also present an extended case study of Swing, a {Java} GUI package built on top of AWT, and we document the ensuing anomalies that Swing introduces. We show how Classbox/J, a prototype implementation of classboxes for {Java}, is used to provide a cleaner implementation of Swing using local refinement rather than subclassing.},
	Acceptnum = {25},
	Accepttotal = {142},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 20th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'05)},
	Doi = {10.1145/1094811.1094826},
	Hal-Id = {inria-00533461},
	Inria = {hors},
	Keywords = {stefPub alexPub kzClassbox},
	Misc = {acceptance rate: 25/142 = 17\%},
	Pages = {177--189},
	Publisher = {ACM Press},
	Rate = {17\%},
	Secondurl = {http://scg.unibe.ch/archive/papers/Berg05bclassboxjOOPSLA.pdf},
	Selectif = {oui},
	Title = {Classbox/{J}: Controlling the Scope of Change in {Java}},
	Url = {http://rmod.inria.fr/archives/papers/Berg05b-OOSPLA05-classboxJ.pdf},
  Year = {2005}}

@article{Berg05c,
	Abstract = {Each object-oriented programming language proposes various grouping
mechanisms to bundle interacting classes (i.e., packages, modules, selector namespaces,
etc). To understand such diversity and to compare the different approaches, a common
foundation is needed. As far as we are aware of, no major attempt that would go in that
direction has been realized. In this paper we present a simple module calculus together
with a set of operators for modeling the composition semantics of different grouping
mechanisms. Using this module calculus we are able to express the semantics of {Java}
packages, C# namespaces, Ruby modules, selector namespaces, gbeta classes, classboxes,
MZScheme units, and MixJuice modules. This calculus supports the identification of system
families sharing similar characteristics. In addition it provides a uniform way to
represent and analyze fine-grained module semantics.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz},
	Cvs = {ModuleAnalysisJUCS05},
	Impactfactor = {SCI impact factor 0.337},
	Inria = {hors},
	Journal = {Journal of Universal Computer Science},
	Keywords = {classbox stefPub alexPub kzClassbox kzModule},
	Month = nov,
	Number = {10},
	Pages = {1613--1644},
	Selectif = {non},
	Title = {Analyzing Module Diversity},
	Url = {http://rmod.inria.fr/archives/papers/Berg05cModuleDiversity.pdf},
	Volume = {11},
  Year = {2005}}

@inproceedings{Berg05d,
	Abstract = {On the one hand, traits are a powerful way of structuring classes. Traits
support the reuse of method collections over several classes. However, traits cannot be
used when specifying unanticipated changes to an application. On the other hand, classboxes
are a new module system that supports the local redefinition of classes: a collection of
classes can be locally extended with variables and/or methods and the existing clients do
not get impacted by changes. However, an extension applied to a class by a classbox cannot
be reused for other classes. This paper describes how combining Traits and Classboxes
supports the safe introduction of crosscutting collaborations: safe because the existing
clients of the classes do not get impacted, crosscutting because collaborations between
several classes can be put in place in a unanticipated manner. In the resulting system, a
collaboration is represented by a classbox and a role by a trait.},
	Address = {Erfurt, Germany},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {nationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse},
	Booktitle = {{Net}.{ObjectDays} (NODE'05)},
	Inria = {hors},
	Keywords = {alexPub stefPub kzClassBox kzTrait},
	Month = sep,
	Pages = {61--75},
	Selectif = {non},
	Title = {Supporting Unanticipated Changes with {Traits} and {Classboxes}},
	Url = {http://rmod.inria.fr/archives/papers/Berg05dTraitsClassbox.pdf},
  Year = {2005}}

@article{Berg05e,
	Abstract = {Atomically introducing changes to a group of classes is a challenging task.
In addition, certain applications require that changes be applied dynamically without
shutting down and restarting the application. In this paper we present an extension of
classboxes to make them dynamic. A classbox is a kind of module that supports class
extension and instance variable addition. Class extensions and definitions defined in a
classbox represent an aspect. In addition, with classboxes, aspects are dynamically applied
to, removed from hot- in a system. Such aspects may crosscut a large number of classes
which are extended by adding or redefining existing methods and adding new instance
variables. Finally the aspects are scoped i.e., they are local to the classboxes that
define them.},
	Aeres = {ACT},
	Annote = {nationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse},
	Cvs = {ClassboxJFDLPA04},
	Inria = {hors},
	Journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet (Num\'ero sp\'ecial : Programmation par aspects)},
	Keywords = {classboxes stefPub alexPub kzClassbox kzAspect},
	Month = nov,
	Number = {3},
	Pages = {53--68},
	Publisher = {Hermes, Paris},
	Selectif = {non},
	Title = {Scoped and Dynamic Aspects with {Classboxes}},
	Url = {http://rmod.inria.fr/archives/papers/Berg05eDynamicClassboxes.pdf},
	Volume = {11},
  Year = {2005}}

@inproceedings{Berg06b,
	Abstract = {Prototyping new programming languages is often assimilated as a task
requiring heavy expertise in parsing and compilation. This paper argues that choosing as a
host platform a language having advanced reflective capabilities helps in reducing the
effort and time spent on developing new language related constructs and tools. The Squeak
Smalltalk implementation provides very expressive reflective facilities. In this paper we
focus on having methods as first class entities, enabling methods manipulation as plain
standard objects and reification of method execution. Powerful language related tools and
efficient new programming constructs can be quickly implemented. ByteSurgeon, a bytecode
manipulation library, and FacetS, an aspect mechanism, serve as illustrations.},
	Aeres = {ACT},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and Marcus Denker},
	Booktitle = {Proceedings of the ECOOP'06 Workshop on Revival of Dynamic Languages},
	Cvs = {SqueakRSP06},
	Inria = {hors},
	Keywords = {alexpub fromscgbib marcusdenker},
	Medium = {4},
	Month = jul,
	Peerreview = {yes},
	Selectif = {non},
	Title = {Prototyping Languages, Related Constructs and Tools with {Squeak}},
	Url = {http://rmod.inria.fr/archives/workshops/Bergel06b-RDL06-Prototyping.pdf},
  Year = {2006}}

@inproceedings{Berg07a,
	Abstract = {Traits offer a fine-grained mechanism to compose classes from reusable
components while avoiding problems of fragility brought by multiple inheritance and mixins.
Traits as originally proposed are \emph{stateless}, that is, they contain only methods, but
no instance variables. State can only be accessed within traits by accessors, which become
\emph{required methods} of the trait. Although this approach works reasonably well in
practice, it means that many traits, viewed as software components, are artificially
\emph{incomplete}, and classes that use such traits may contain significant amounts of
boilerplate glue code. Although these limitations are largely mitigated by proper tool
support, we seek a cleaner solution that supports \emph{stateful traits}. The key
difficulty is how to handle conflicts that arise when composed traits contribute instance
variables whose names clash. We present a solution that is faithful to the guiding
principle of stateless traits: \emph{the client retains control of the composition}.
Stateful traits consist of a minimal extension to stateless traits in which instance
variables are purely local to the scope of a trait, unless they are explicitly made
accessible by the composing client of a trait. Naming conflicts are avoided, and variables
of disjoint traits can be explicitly merged by clients. We discuss and compare two
implementation strategies, and briefly present a case study in which stateful traits have
been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
	Doi = {10.1007/978-3-540-71836-9\_3},
	Inria = {hors},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {stefPub traits kzTrait},
	Medium = {2},
	Month = aug,
	Pages = {66--90},
	Peerreview = {yes},
	Publisher = {Springer},
	Selectif = {non},
	Series = {LNCS},
	Title = {Stateful Traits},
	Url = {http://rmod.inria.fr/archives/papers/Berg07a-InternationalSmalltalkConference07-StatefulTraits.pdf},
	Volume = {4406},
  Year = {2007}}

@inproceedings{Berg07c,
	Abstract = {Smalltalk is not only an object-oriented programming language; it is also known for its extensive integrated development environment supporting interactive and dynamic programming. While the default tools are adequate for browsing the code and developing applications, it is often cumbersome to extend the environment to support new language constructs or to build additional tools supporting new ways of navigating and presenting source code. In this paper, we present the OmniBrowser, a browser framework that supports the definition of browsers based on an explicit metamodel. With OmniBrowser a domain model is described in a graph and the navigation in this graph is specified in its associated metagraph. We present how new browsers are built from predefined parts and how new tools are easily described. The browser framework is implemented in the Squeak Smalltalk environment. This paper shows several concrete instantiations of the framework: a remake of the ubiquitous Smalltalk System Browser, and a coverage browser.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC'06)},
	Doi = {10.1007/978-3-540-71836-9\_3},
	Inria = {hors},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {stefPub kzIDE},
	Medium = {2},
	Month = aug,
	Pages = {134--156},
	Peerreview = {yes},
	Publisher = {Springer},
	Selectif = {non},
	Series = {LNCS},
	Title = {Meta-Driven Browsers},
	Url = {http://rmod.inria.fr/archives/papers/Berg07cOmnibrowser.pdf},
	Volume = {4406},
  Year = {2007}}

@article{Berg08a,
	Abstract = {Page-centric Web application frameworks fail to offer adequate solutions to
model composition and control flow. Seaside allows Web applications to be developed in the
same way as desktop applications. Control flow is modelled as a continuous piece of code,
and components may be composed, configured and nested as one would expect from traditional
user interface frameworks.},
	Aeres = {AP},
	Aeresstatus = {aeres08},
	Annote = {notrefereed},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Lukas Renggli},
	Inria = {hors},
	Journal = {ERCIM News},
	Keywords = {alexPub stefPub kzWeb},
	Month = jan,
	Selectif = {non},
	Title = {Seaside -- Advanced Composition and Control Flow for Dynamic Web Applications},
	Url = {http://ercim-news.ercim.org/content/view/325/536/},
	Volume = 72,
  Year = {2008}}

@inproceedings{Berg08b,
	Abstract = {Following last two years' workshop on dynamic languages at the ECOOP
conference, the Dyla 2007 workshop was a successful and popular event. As its name implies,
the workshop's focus was on dynamic languages and their applications. Topics and
discussions at the workshop included macro expansion mechanisms, extension of the method
lookup algorithm, language interpretation, reflexivity and languages for mobile ad hoc
networks. The main goal of this workshop was to bring together different dynamic language
communities and favouring cross communities interaction. Dyla 2007 was organised as a full
day meeting, partly devoted to presentation of submitted position papers and partly devoted
to tool demonstration. All accepted papers can be downloaded from the workshop's web site.
In this report, we provide an overview of the presentations and a summary of discussions.},
	Aeres = {DO},
	Aeresstatus = {aeres08},
	Annote = {workshopproceedings},
	Author = {Alexandre Bergel and Wolfgang De Meuter and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Object-Oriented Technology. ECOOP'07 Workshop Reader},
	Doi = {10.1007/978-3-540-78195-0},
	Inria = {hors},
	Isbn = {978-3-540-78194-3},
	Keywords = {stefPub scg-pub kzEditor},
	Medium = {2},
	Pages = {7--12},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Selectif = {non},
	Series = {LNCS},
	Title = {Dynamic Languages and Applications, Report on the Workshop {Dyla}'07 at {ECOOP} 2007},
	Url = {http://rmod.inria.fr/archive/reports/Berg08b-Dyla07Report.pdf},
	Volume = {4906},
  Year = {2008}}

@inproceedings{Berg08c,
	Aeres = {COM},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Jannik Laval and Romain Peirs},
	Booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
	Hal-Id = {inria-00498484},
	Inria = {RMOD},
	Keywords = {moose kzCycle},
	Labo = {dans},
	Selectif = {non},
	Title = {Enhanced Dependency Structure Matrix for Moose},
	Url = {http://rmod.inria.fr/archives/workshops/Berg08c-Famoosr2008-DSM.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {no},
  Year = {2008}}

@article{Berg08d,
	Abstract = {Smalltalk is not only an object-oriented programming language; it is also
known for its extensive integrated development environment supporting interactive and
dynamic programming. While the default tools are adequate for browsing the code and
developing applications, it is often cumbersome to extend the environment to support new
language constructs or to build additional tools supporting new ways of navigating and
presenting source code. In this paper, we present the OmniBrowser, a browser framework that
supports the definition of browsers based on an explicit metamodel. With OmniBrowser a
domain model is described in a graph and the navigation in this graph is specified in its
associated metagraph. We present how new browsers are built from predefined parts and how
new tools are easily described. The browser framework is implemented in the Squeak
Smalltalk environment. This paper shows several concrete instantiations of the framework: a
remake of the ubiquitous Smalltalk System Browser, a coverage browser, the Duo Browser and
the Dynamic Protocols browser.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Colin Putney and Roel Wuyts},
	Doi = {10.1016/j.cl.2007.05.005},
	Impactfactor = {Impact factor (2008) 0.421},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {stefPub kzIDE},
	Number = {2-3},
	Pages = {109--129},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Creating Sophisticated Development Tools with {OmniBrowser}},
	Volume = {34},
  Year = {2005}}

@article{Berg08e,
	Abstract = {Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially \emph{incomplete}, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Doi = {10.1016/j.cl.2007.05.003},
	Impactfactor = {Impact factor (2008) 0.421},
	Inria = {hors},
	Issn = {1477-8424},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {stefPub kzTrait},
	Medium = {2},
	Number = {2-3},
	Pages = {83--108},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Stateful Traits and their Formalization},
	Url = {http://rmod.inria.fr/archives/papers/Berg08e-JournalComputerLanguages-StatefulTraitsFormalization.pdf},
	Volume = {34},
  Year = {2008}}

@inproceedings{Berg09a,
	Abstract = {No abstract},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and Simon Denier and St\'ephane Ducasse and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues and Fran\c{c}oise Balmas and Karine Mordal-Manet},
	Booktitle = {Proceedings of the 13th European Conference on Software Maintenance and Reengineering (CSMR'09), European Projects Track},
	Hal-Id = {hal-00746252},
	Inria = {RMOD},
	Institution = {INRIA},
	Keywords = {squale-pub lse-pub kzMetric},
	Labo = {dans},
	Month = {mar},
	Note = {Presentation},
	Selectif = {non},
	Title = {SQUALE -- Software QUALity Enhancement},
	Url = {http://rmod.inria.fr/archives/workshops/Berg09c-CSMR2009-Squale.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Berg09b,
	Abstract = {La composition et l'int\'eraction des aspects est un domaine de recherche tr\`es actif. Bien que plusieurs solutions existent, telles que l'agencement
des aspects et des advices, les approches propos\'ees par des langages \`a aspects
supposent qu'une connaissance g\'en\'erale des aspects soit n\'ecessaire pour pouvoir
les composer, et m\^eme ceci ne permet pas d'\'eviter les interactions implicites r\'esultant d'une composition.
Cet article pr\'esente les aspectboxes, un m\'ecanisme de visibilit\'e pour aspects.
L'unit\'e \'el\'ementaire de visibilit\'e est un aspectbox. Un aspectbox encapsule des
d\'efinitions d'aspects. Un aspectbox peut \^etre utilis\'e par d'autres aspectboxes
pour aider la construction incr\'ementale de logiciel \`a base d'aspects. Une classe
peut utiliser un aspectbox dans le but de b\'en\'eficier des aspects d\'efinis.},
	Aeres = {ACT},
	Aeresstatus = {aeres09},
	Annote = {nationalconference},
	Author = {Alexandre Bergel},
	Booktitle = {Proceedings of LMO 2009},
	Hal-Id = {hal-00746256},
	Inria = {RMOD},
	Institution = {INRIA},
	Keywords = {lse-pub},
	Labo = {dans},
	Selectif = {non},
	Title = {Contr\^oler la visibilit\'e des aspects avec Aspectboxes},
	X-Editorial-Board = {yes},
	X-International-Audience = {no},
	X-Language = {FR},
	X-Proceedings = {yes},
	Year = {2009}}

@book{Berg13a,
	Abstract = {Pharo is a dynamic object-oriented programming language. Pharo's model and syntax are uniform, simple and expressive. These properties, when added to a powerful and flexible programming environment, regularly attract new developers. The community around Pharo has been steadily increasing over the years. This community is actively creating exciting and innovative software artifacts helping the development of advanced software systems. Pharo heightens the software building experience to its best. It offers open and object-oriented programming environments and libraries. The book covers a large spectrum of topics ranging from central language aspects to innovative frameworks and libraries. This book contains unique material often presented in a tutorial form with many hand-on exercises. Everybody will learn something reading this book: programmers familiar with Pharo will enjoy the highlights made of some particularly beautiful aspects of Pharo as well as discovering new and powerful frameworks. Practitioners making their debut with Pharo will take on a wonderful journey in the realm of objects.  Deep into Pharo presents both internal aspects of Pharo and libraries that prove to be important for academic, business and development perspectives.},
	Annote = {book},
	Author = {Bergel, Alexandre and Cassou, Damien and Ducasse, St\'ephane and Laval, Jannik},
	Hal-Id = {hal-00858725},
	Isbn = {978-3-9523341-6-4},
	Keywords = {Smalltalk Pharo Object-Oriented Programming Live Programming pharo stefPub kzBook},
	Pages = {420},
	Publisher = {Square Bracket Associates},
	Title = {{Deep Into Pharo}},
	Url = {http://rmod.inria.fr/archives/books/Berg13a-PBE2-ESUG-2013-09-06.pdf},
	Website = {http://rmod.inria.fr/pbe2/},
  Year = {2013}}

@techreport{Berg13b,
	Aeres = {COM},
	Aeresstatus = {aeres13},
	Annote = {technicalreport},
	Author = {Alexandre Bergel and St\'ephane Ducasse and Marcus Denker and Johan Fabry},
	Hal-Id = {hal-00871114},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {stefPub marcusdenker lse-pub plomo},
	Labo = {dans},
	Selectif = {non},
	Title = {PLOMO Associate Team Final Report},
	Url = {http://rmod.inria.fr/archives/reports/Berg13b-PLOMOTechReport.pdf},
	X-Country = {CL},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,CL},
	X-Proceedings = {no},
  Year = {2013}}


 @techreport{Berg16a,
 	Aeres = {COM},
 	Aeresstatus = {aeres16},
 	Annote = {technicalreport},
 	Author = {Alexandre Bergel and St\'ephane Ducasse and Marcus Denker and Johan Fabry},
 	Hal-Id = {hal-01389983},
 	Inria = {RMOD},
 	Institution = {INRIA},
 	Keywords = {stefPub marcusdenker lse-pub plomo},
 	Labo = {dans},
 	Type = {Research Report},
 	Selectif = {non},
 	Title = {PLOMO2 Associate Team Final Report},
 	Url = {http://rmod.inria.fr/archives/reports/Berg16a-PLOMO2TechReport.pdf},
 	X-Country = {CL},
 	X-Editorial-Board = {no},
 	X-International-Audience = {yes},
 	X-Language = {EN},
 	X-Pays = {FR,CL},
 	X-Proceedings = {no},
   Year = {2016}}


@inproceedings{Berg14a,
	Abstract = {Graphs are commonly used to visually represent software dependencies. However, adequately visualizing software dependencies as a graph is a non-trivial problem due to the pluridimentional nature of software. We have designed a domain-specific language for visualizing software dependencies as graphs that is both expressive and concise. GRAPH, the implementation of our DSL, features a seamless mapping between visual dimensions to software metrics, composition of graph layouts, graph partition, and hierarchical bundle edges.},
	Annote = {internationalconference},
	Author = {Alexandre Bergel and Sergio Maass and St\'ephane Ducasse and Tudor Girba},
	Booktitle = {Vissoft'14, NIER Track},
	Hal = {http://hal.inria.fr/hal-01369705},
	Hal-Id = {hal-01369705},
	Keywords = {stefPub kzVisualization},
	Title = {A Domain-Specific Language For Visualizing Software Dependencies as a Graph},
	Url = {http://rmod.inria.fr/archives/papers/Berg14a-Vissoft-DomainSpecific.pdf},
  Year = {2014}}

@inproceedings{Bert03a,
	Abstract = {Understanding object-oriented legacy systems is a complex task exacerbated by the presence of late binding and polymorphism. Moreover, the metaphor of message sending and the anthropomorphism promoted by object-oriented languages makes it difficult to statically identify the precise role the objects play at run-time. We propose a lightweight visualization approach enriched with run-time information which allows us to identify precise aspects of the objects lifetime such as the role played in the creation of other objects and the communication architecture they support. Our approach not only supports the run-time understanding of an application but also allows one to evaluate test understanding and test coverage.},
	Annote = {internationalworkshop},
	Author = {Roland Bertuli and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 4th International Workshop on Object-Oriented Reengineering (WOOR'03)},
	Keywords = {stefPub moose kzVisualization kzDynamicInformation},
	Pages = {10--19},
	Publisher = {University of Antwerp},
	Title = {Run-Time Information Visualization for Understanding Object-Oriented Systems},
	Url = {http://scg.unibe.ch/archive/papers/Bert03aEcoopWorkshop.pdf},
  Year = {2003}}

@article{Bert12a,
	Abstract = {We present DiaSuite, a tool suite that uses a
                  software design approach to drive the development
                  process. DiaSuite focuses on a specific domain,
                  namely Sense/Compute/Control (SCC) applications. It
                  comprises a domain-specific design language, a
                  compiler producing a Java programming framework, a
                  2D-renderer to simulate an application, and a
                  deployment framework. We have validated our tool
                  suite on a variety of concrete applications in areas
                  including telecommunications, building automation,
                  robotics and avionics.},
	Annote = {internationaljournal},
	Author = {Bertran, Benjamin and Bruneau, Julien and Cassou, Damien and Loriant, Nicolas and Balland, Emilie and Consel, Charles},
	Coreranking = {A},
	Doi = {10.1016/j.scico.2012.04.001},
	Impactfactor = {Impact Factor (2010) 1.304},
	Issn = {0167-6423},
	Journal = {SCP: Science of Computer Programming, Fourth special issue on Experimental Software and Toolkits},
	Keywords = {diaspec DSL Domain-specific design language Tool-based development methodology Generative programming Pervasive computing},
	Publisher = {Elsevier},
	Title = {DiaSuite: a Tool Suite To Develop Sense/Compute/Control Applications},
	Url = {http://hal.inria.fr/docs/00/70/29/09/PDF/diasuite.pdf},
  Year = {2012}}

@inproceedings{Bezi03a,
	Annote = {internationalconference},
	Author = {B\'ezivin, Jean and Farcet, Nicolas and J\'ez\'equel, Jean-Marc and Langlois, Beno\^\it and Pollet, Damien},
	Booktitle = {UML~2003 --- The Unified Modeling Language --- Modeling Languages and Applications},
	Editor = {Stevens, Perdita and Whittle, Jon and Booch, Grady},
	Isbn = {3-540-20243-9},
	Month = oct,
	Pages = {175--189},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Reflective Model Driven Engineering},
	Url = {http://www.irisa.fr/triskell/publis/2003/Bezivin03.pdf},
	Volume = {2863},
  Year = {2003}}

@inproceedings{Bhat07a,
	Annote = {internationalworkshop},
	Author = {Bhatti, Muhammad Usman and St\'ephane Ducasse},
	Booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
	Hal-Id = {tobedone},
	Keywords = {moose kzRemodularisation},
	Title = {Surgical Information to Detect Design Problems with MOOSE},
	Url = {http://scg.unibe.ch/archive/papers/Bhat07aFamoosRWorkshop.pdf},
  Year = {2007}}

@inproceedings{Bhat08a,
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference shortpaper},
	Author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
	Booktitle = {International Conference on Program Comprehension (ICPC'08)},
	Hal-Id = {tobedone},
	Inria = {RMOD},
	Keywords = {moose kzAspect kzModule kzRemodularisation},
	Selectif = {non},
	Title = {Aspect Mining in Procedural Object-Oriented Code},
	Url = {http://rmod.inria.fr/archives/papers/Bhat08a-ICPC2008-AspectMining.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {UK},
	X-Proceedings = {yes},
  Year = {2008}}

@inproceedings{Bhat08b,
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference stefPub},
	Author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Marianne Huchard},
	Booktitle = {Proceedings of the 15th International Working Conference on Reverse Engineering (WCRE'08)},
	Hal-Id = {tobedone},
	Inria = {RMOD},
	Keywords = {moose stefPub kzRemodularisation},
	Selectif = {non},
	Title = {Reconsidering Classes in Procedural Object-Oriented Code},
	Url = {http://rmod.inria.fr/archives/papers/Bhat08b-WCRE2008-ObjectIdentification.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2008}}

@techreport{Bhat08c,
	Annote = {techreport stefPub},
	Author = {Bhatti, Muhammad Usman and St\'ephane Ducasse and Awais Rashid},
	Institution = {INRIA Lille Nord Europe},
	Keywords = {kzRemodularisation},
	Title = {Aspect Mining in Procedural Object-Oriented Code},
	Url = {http://rmod.inria.fr/archives/papers/Bhat08c-TechReport-AspectMining.pdf},
	X-Pays = {UK},
  Year = {2008}}

@phdthesis{Bhat08d,
	Abstract = {In this dissertation, we present Procedural Object-Oriented Code (POC). POC is the aftermath of the software development activity that involves state of the art object-oriented languages, without employing object-oriented analysis and design. Huge classes, absence of abstractions for domain entities, and shallow inheritance hierarchies are hallmark design defects of procedural object-oriented code. POC also consists of scattered code appearing not only due to the absence of aspects, but it also manifests scattered code appearing due to the non-abstracted domain entities i.e., domain entities that do not have their proper object-oriented classes. The non-abstracted domain logic hinders mining useful crosscutting concerns related to aspects in POC. Confronted with the absence of object-oriented design and the difficulty of mining aspects in POC, we studied it from two perspectives.
	First, we improve aspect mining techniques by classifying various crosscutting concerns identified in POC with a two-pronged approach: Firstly, the approach identifies and groups crosscutting concerns present in a software system: aspects as well as non-abstracted domain logic. Crosscutting concerns pertaining to non- abstracted domain entities are identified and extracted through their usage of application domain entity data. Secondly, a new metric called spread-out is introduced to quantify the divulgence of diverse crosscutting concerns.
	Second, we studied the problem of object identification in procedural object- oriented code. We present a semi-automatic, tool-assisted approach for restructuring POC into an improved object-oriented design. The approach identifies principal classes in POC. These principal classes are then used to extract object-oriented abstractions using Formal Concept Analysis lattices. This is achieved by providing three different concept lattices, namely fundamental, association, and interactions views.
	We developed tools to validate the approaches presented in the thesis. The approaches are validated on a recently developed industrial application. The application is used to run blood plasma analysis automatons. The results of our approach are promising.},
	Author = {Muhammad Usman Bhatti},
	Hal = {tel-00498436},
	School = {UNIVERSITE PARIS I -- PANTHEON -- SORBONNE},
	Title = {Object Identification and Aspect Mining in Procedural Object-Oriented Code},
	Year = {2008}}

@inproceedings{Bhat12a,
	Abstract = {Formal Concept Analysis (FCA) provides an important approach in software reengineering for software understanding,  design anomalies detection and correction.
However, FCA-based approaches  have two problems: (i) they produce lattices that must be interpreted by the user according to his/her understanding of the technique and different elements of the graph; and, (ii) the lattice can rapidly become so big that one is overwhelmed by the mass of information and possibilities.
In this paper, we present  a catalog of important patterns in concept lattices, which can allow automating the task of lattice interpretation. The approach helps the reengineer to concentrate on the task of reengineering rather than understanding a complex lattice.
We provide interpretation of these patterns in a generalized manner and illustrate them on various contexts constructed from program information of different open-source systems. We also present a tool that allows automated extraction of the patterns from concept lattices.
},
	Acceptnum = {59},
	Accepttotal = {219},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Muhammad U.Bhatti and Nicolas Anquetil and Marianne Huchard and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 24th International Conference on Software Engineering \& Knowledge Engineering (SEKE 2012)},
	Hal-Id = {hal-00700046},
	Isbn = {978-1-891706-31-8},
	Keywords = {lse-pub stefPub kzRemodularisation},
	Labo = {oui},
	Misc = {acceptance rate: 59/219 = 27\%},
	Pages = {118--24},
	Selectif = {oui},
	Tagnicolasa = {architecture FCA},
	Title = {A Catalog of Patterns for Concept Lattice Interpretation in Software Reengineering},
	Url = {http://rmod.inria.fr/archives/papers/Bhat12c-SEKE2012-FCA-patterns.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {FR},
  Year = {2012}}

@article{Bhat12b,
	Abstract = {Moose is an open-source platform for the assessment of software and data analysis. Moose provides several engines to build tools, analyses and visualizations. One of Moose's strengths is the possibility to rapidly build domain-specific analysis tools.},
	Aeres = {AP},
	Annote = {vulgarisation},
	Author = {Muhammad U. Bhatti and Nicolas Anquetil and St\'ephane Ducasse},
	Hal-Id = {hal-00759511},
	Inria = {RMOD},
	Journal = {ERCIM News},
	Keywords = {moose lse-pub raweb2012 kzIDE kzMoose},
	Labo = {dans},
	Month = jan,
	Pages = {12--13},
	Selectif = {non},
	Tagnicolasa = {analysis},
	Title = {An Environment for dedicated Software Analysis tools},
	Url = {http://ercim-news.ercim.eu/images/stories/EN88/EN88-web.pdf},
	Volume = {88},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {no},
  Year = {2012}}

@techreport{Blac02a,
	Abstract = {Traits are a programming language technology modeled after mixins but
avoiding their problems. In this paper we refactor the Smalltalk collections hierarchy
using traits. We observed that the original hierarchy contained much duplication of code;
traits let us remove all of it. Traits also make possible much more general reuse of
collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
size of the collection hierarchy by approximately 12 per cent, with no measurable impact on
execution efficiency. More importantly, understandability and reusability of the code was
significantly improved, and the path was paved for a more intensive refactoring.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {report notrefereed},
	Author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
	Institution = {Institut f\"ur Informatik},
	Keywords = {kzTrait},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-007},
	Title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Blac02aTraitsHierarchy.pdf},
  Year = {2002}}

@inproceedings{Blac03a,
	Abstract = {Traits are a programming language technology that promote the reuse of
methods between unrelated classes. This paper reports on a refactoring of the Smalltalk
collections classes using traits. The original collection classes contained much
duplication of code; traits let us remove all of it. We also found places where the
protocols of the collections lacked uniformity; traits allowed us to correct these
non-uniformities without code duplication. Traits also make it possible to reuse fragments
of collection code outside of the existing hierarchy; for example, they make it easy to
convert other collection-like things into true collections. Our refactoring reduced the
number of methods in the collection classes by approximately 10 per cent. More importantly,
understandability maintainability and reusability of the code were significantly improved.},
	Acceptnum = {26},
	Accepttotal = {142},
	Annote = {internationalconference topconference},
	Author = {Andrew P. Black and Nathanael Sch\"arli and St\'ephane Ducasse},
	Booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
	Doi = {10.1145/949305.949311},
	Keywords = {kzTrait},
	Misc = {acceptance rate: 26/142 = 18\%},
	Month = oct,
	Pages = {47--64},
	Title = {Applying Traits to the {Smalltalk} Collection Hierarchy},
	Url = {http://scg.unibe.ch/archive/papers/Blac03aTraitsHierarchy.pdf},
	Volume = {38},
  Year = {2003}}

@book{Blac07a,
	Abstract = {Squeak by Example, intended for both students and developers, will guide you gently through the Squeak language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
	Aeres = {OV},
	Aeresstatus = {2008},
	Annote = {book },
	Author = {Andrew Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Inria = {RMOD},
	Isbn = {978-3-9523341-0-2},
	Keywords = {skipdoi remoose1-pub marcusdenker kzSmalltalk},
	Publisher = {Square Bracket Associates},
	Title = {Squeak by Example},
	Url = {http://SqueakByExample.org/index.html},
  Year = {2007}}

@book{Blac09a,
	Abstract = {Pharo by Example, intended for both students and developers, will guide you gently through the Pharo open-source Smalltalk language and environment by means of a series of examples and exercises. This book is made available under the Creative Commons Attribution-ShareAlike 3.0 license.},
	Address = {Kehrsatz, Switzerland},
	Aeres = {OV},
	Aeresstatus = {2012},
	Annote = {book},
	Author = {Andrew P. Black and St\'ephane Ducasse and Oscar Nierstrasz and Damien Pollet and Damien Cassou and Marcus Denker},
	Hal-Id = {hal-00849020},
	Inria = {RMOD},
	Inriareport = {2009},
	Isbn = {978-3-9523341-4-0},
	Keywords = {skipdoi remoose2-pub pharo-pub marcusdenker kzSmalltalk},
	Pages = 333,
	Publisher = {Square Bracket Associates},
	Title = {Pharo by Example},
	Url = {http://pharobyexample.org/, http://rmod.inria.fr/archives/books/Blac09a-PBE1-2013-07-29.pdf},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CH,US},
	X-Scientific-Popularization = {yes},
  Year = {2009}}

@inproceedings{Blon15a,
	TITLE = {{Software metrics to predict the health of a project?}},
	AUTHOR = {Blondeau, Vincent and Anquetil, Nicolas and Ducasse, St{\'e}phane and Cresson, Sylvain and Croisy, Pascal},
	URL = {https://hal.inria.fr/hal-01185079},
	BOOKTITLE = {{IWST'15}},
	Annote = {internationalworkshop},
	aeresstatus= {aeres16},
	Aeres = {ACT},
	Inria = {RMOD},
	ADDRESS = {Brescia, Italy},
	YEAR = {2015},
	MONTH = jul,
	DOI = {10.1145/2811237.2811294},
	KEYWORDS = {lse-pub ;  moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews},
	PDF = {http://rmod.inria.fr/archives/papers/Blon15a-IWST-Software_metrics_to_predict_the_health_of_a_project.pdf},
	Hal-id = {hal-01185079}
}

@inproceedings{Blon15b,
	TITLE = {{Predicting the Health of a Project? An Assessment in a Major IT Company}},
	AUTHOR = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St{\'e}phane},
	URL = {https://hal.inria.fr/hal-01205468},
	BOOKTITLE = {{SATToSE'15}},
	ADDRESS = {Mons, Belgium},
	Annote = {internationalworkshop},
	aeresstatus= {aeres16},
	Aeres = {ACT},
	Inria = {RMOD},
	YEAR = {2015},
	MONTH = jul,
	PDF = {http://rmod.inria.fr/archives/papers/Blon15b-SATToSE-Predicting_the_Health_of_a _Project-An_Assessment_in_a_Major_IT_company.pdf},
	KEYWORDS = {lse-pub ;  moose-pub ; pharo-pub ; Project health ; Closed-source ; Data-mining ; Interviews},
	Hal-id = {hal-01205468}
}

@inproceedings{Blon15c,
  TITLE = {{Dynamic and Static Approaches Comparison for Test Suite Reduction in Industry}},
  AUTHOR = {Blondeau, Vincent and Cresson, Sylvain and Croisy, Pascal and Etien, Anne and Anquetil, Nicolas and Ducasse, St{\'e}phane},
  URL = {https://hal.inria.fr/hal-01317498},
  BOOKTITLE = {{BENEVOL'15: 14th BElgian-NEtherlands software eVOLution seminar}},
  ADDRESS = {Lille, France},
  annote = {internationalworkshop},
  aeresstatus= {aeres16},
  YEAR = {2015},
  MONTH = dec,
  PDF = {http://rmod.inria.fr/archives/papers/Blon15c-BENEVOL-Blondeau_Vincent-Dynamic_and_Static_Approaches_Comparison_for_Test_Suite_Reduction_in_Industry.pdf},
  KEYWORDS = {lse-pub ;  moose-pub ; pharo-pub ; static; dynamic; test; test selection},
  Hal-id = {hal-01317498}
}

@article{Blon16a,
	Author={Blondeau, Vincent and Etien, Anne and Anquetil, Nicolas and Cresson, Sylvain and Croisy, Pascal and Ducasse, St{\'e}phane},
	Title={{Test Case Selection in Industry: An Analysis of Issues Related to Static Approaches}},
	Journal={Software Quality Journal},
	year={2016},
	pages={1--35},
	abstract={Automatic testing constitutes an important part of everyday development practice. Worldline, a major IT company, is creating more and more tests to ensure the good behavior of its applications and gains in efficiency and quality. But running all these tests may take hours. This is especially true for large systems involving, for example, the deployment of a web server or communication with a database. For this reason, tests are not launched as often as they should be and are mostly run at night. The company wishes to improve its development and testing process by giving to developers rapid feedback after a change. An interesting solution is to reduce the number of tests to run by identifying only those exercising the piece of code changed. Two main approaches are proposed in the literature: static and dynamic. The static approach creates a model of the source code and explores it to find links between changed methods and tests. The dynamic approach records invocations of methods during the execution of test scenarios. Before deploying a test case selection solution, Worldline created a partnership with us to investigate the situation in its projects and to evaluate these approaches on three industrial, closed source, cases to understand the strengths and weaknesses of each solution. We propose a classification of problems that may arise when trying to identify the tests that cover a method. We give concrete examples of these problems and list some possible solutions. We also evaluate other issues such as the impact on the results of the frequency of modification of methods or considering groups of methods instead of single ones. We found that solutions must be combined to obtain better results, and problems have different impacts on projects. Considering commits instead of individual methods tends to worsen the results, perhaps due to their large size.},
	Annote = {internationaljournal},
  	aeresstatus= {aeres16},
  	Aeres = {ACT},
  	Inria = {RMOD},
	issn={1573-1367},
	doi={10.1007/s11219-016-9328-4},
	url={http://dx.doi.org/10.1007/s11219-016-9328-4},
	PUBLISHER = {{Springer Verlag}},
	PDF = {http://rmod.inria.fr/archives/papers/Blon16a-Software_Quality_Journal-Test_Case_Selection_in_Industry-An_Analysis_of_Issues_Related_to_Static_Approaches.pdf},
 	Hal-ID = {hal-01344842},
 	KEYWORDS = {lse-pub ;  moose-pub ; pharo-pub }
}

@inproceedings{Blon16b,
	TITLE = {{Test Selection with Moose In Industry: Impact of Granularity}},
	AUTHOR = {Blondeau, Vincent and Anquetil, Nicolas and Ducasse, St{\'e}phane and Cresson, Sylvain and Croisy, Pascal},
	URL = {https://hal.inria.fr/hal-01352468},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	YEAR = {2016},
	MONTH = aug,
	KEYWORDS = {lse-pub ;  moose-pub ; pharo-pub ; Industrial case ; Static ; Test selection ; Moose ; Dynamic},
	PDF = {http://rmod.inria.fr/archives/papers/Blon16b-IWST-Test_Selection_with_Moose_In_Industry.pdf},
	Hal-Id = {hal-01352468},
	annote = {internationalworkshop}
}

@inproceedings{Bono14a,
	Author = {Bono, Viviana and Mensa, Enrico and Naddeo, Marco},
	Booktitle = {PPPJ'14: International Conference on Principles and Practices of Programming on the Java Platform: virtual machines, languages, and tools},
	Location = {Cracow, Poland},
	annote = {internationalconference},
	Title = {Trait-oriented Programming in Java 8},
	Year = {2014},
	Hal-Id = {hal-01026531}}

@article{Bour01a,
	Author = {Bouraqadi-Sa{\^a}dani, Noury MN and Ledoux, Thomas and S{\"u}dholt, Mario},
	Journal = {Invited presentation at the International Workshop on Experiences with reflective systems},
	Title = {A reflective infrastructure for coarse-grained strong mobility and its tool-based implementation},
	Year = {2001}}

@inproceedings{Bour10a,
	Abstract = {A trait is a programming construct which provides code reusability. Traits are groups of methods that can be reused orthogonally from inheritance. Traits offer a solution to the problems of multiple inheritance by providing a behavior-centric modularity. Since traits offer an alternative to traditional inheritance-based code reuse, a couple of questions arise. For example, what is a good granularity for a Trait enabling reuse as well as plug ease? How much reuse can we expect on large existing inheritance-based hierarchies?
In this paper we take as case study the Smalltalk Collection hierarchy and we start rewriting it from scratch using traits from the beginning. We show how such library can be built using traits and we report such a preliminary experience. Since the Collection library is large, we focused and built the main classes of the library with Traits and report problems we encountered and how we solved them. Results of this experience are positive and show that we can build new collections based on the traits used to define the new library kernel.},
	Address = {Barcelona, Spain},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Tristan Bourgois and Jannik Laval and St\'ephane Ducasse and Damien Pollet},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'10)},
	Hal-Id = {inria-00511902},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {pharo-pub lse-pub pharo kzTrait},
	Labo = {dans},
	Selectif = {oui},
	Title = {BLOC: a Trait-Based Collections Library - a Preliminary Experience Report},
	Url = {http://rmod.inria.fr/archives/workshops/Bour10a-IWST10-bloc.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2010}}

@book{Brif01a,
	Annote = {book},
	Author = {Xavier Briffault and St\'ephane Ducasse},
	Keywords = {smalltalk squeak kzSmalltalk},
	Month = nov,
	Publisher = {Eyrolles, Paris},
	Title = {Squeak},
	Year = {2001}}

@techreport{Brun09a,
	Abstract = {Virtual machines emulating hardware devices are generally implemented in low-level languages and using a low-level style for performance reasons.  This trend results in largely difficult to understand, difficult to extend and unmaintainable systems. As new general techniques for virtual machines arise, it gets harder to incorporate or test these techniques because of early design and optimization decisions. In this paper we show how such decisions can be postponed to later phases by separating virtual machine implementation issues from the high-level machine-specific model. We construct compact models of whole-system VMs in a high-level language, which exclude all low-level implementation details. We use the pluggable translation toolchain PyPy to translate those models to executables. During the translation process, the toolchain reintroduces the VM implementation and optimization details for specific target platforms.  As a case study we implement an executable model of a hardware gaming device. We show that our approach to VM building increases understandability, maintainability and extendability while preserving performance.},
	Annote = {report notrefereed},
	Author = {Camillo Bruni and Toon Verwaest and Marcus Denker},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
	Keywords = {scg09 scg-pub jb09 snf09 skip-doi tverwaes marcusdenker fromscgbib},
	Medium = {2},
	Number = {IAM-09-002},
	Peerreview = {yes},
	Title = {{PyGirl}: Generating Whole-System {VM}s from high-level models using {PyPy}},
	Type = {Technical Report},
	Url = {http://rmod.inria.fr/archives/reports/Brun09a-TechReport-PyGirl.pdf},
  Year = {2009}}

@inproceedings{Brun13a,
	Abstract = {Foreign-Function-Interfaces (FFIs) are a prerequisite for close system integration of a high-level language. With FFIs the high-level environment interacts with low-level functions allowing for a unique combination of features. This duality has a strong impact on the implementation of the FFI: it has to be flexible and fast at the same time.
	We propose NativeBoost a language-side approach to FFIs that only requires minimal changes to the VM. NativeBoost directly creates specific native code at language-side and thus combines the flexibility of a language-side library with the performance of a native plugin.},
	Annote = {internationalworkshop},
	Author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
	Booktitle = {International Workshop on Smalltalk Technologies 2013},
	Hal-Id = {hal-00840781},
	Keywords = {pharo stefPub kzInfrastructure},
	Title = {Language-side Foreign Function Interfaces with NativeBoost},
	Url = {http://rmod.inria.fr/archives/papers/Brun13a-NativeBoostIWST.pdf},
  Year = {2013}}

@inproceedings{Brun14a,
	Abstract = {The goal of high-level low-level programming is to bring the abstraction capabilities of high-level languages to the system programming domain, such as virtual machines (VMs) and language runtimes. However, existing solutions are bound to compilation time and expose limited possibilities to be changed at runtime and from language-side. They do not fit well with fully reflective languages and environments.
We propose Benzo1, a lightweight framework for high- level low-level programming that allows developers to gen- erate and execute at runtime low-level code (assembly). It promotes the implementation, and dynamic modification, of system components with high-level language tools outper- forming existing dynamic solutions.
Since Benzo is a general framework we choose three ap- plications that cover an important range of the spectrum of system programming for validating the infrastructure: a For- eign Function Interface (FFI), primitives instrumentation and a just-in-time bytecode compiler (JIT). With Benzo we show that these typical VM-level components are feasible as reflective language-side implementations. Due to its unique combination of high-level reflection and low-level program- ming, Benzo shows better performance for these three ap- plications than the comparable high-level implementations.},
	Annote = {internationalworkshop},
	Author = {Camillo Bruni and Luc Fabresse and St\'ephane Ducasse and Igor Stasenko},
	Booktitle = {International Workshop on Smalltalk Technologies 2014},
	Hal = {http://hal.inria.fr/hal-01060551},
	Hal-Id = {hal-01060551},
	Keywords = {pharo stefPub kzInfrastructure},
	Title = {Benzo: Reflective Glue for Low-level Programming},
	Url = {http://rmod.inria.fr/archives/papers/Brun14a-IWST-Benzo.pdf},
  Year = {2014}}

@phdthesis{Brun14b,
	Author = {Mart\'in Dias},
	Hal-Id = {tel-01097323v1},
	Title = {Towards Self-aware Virtual Machines},
	School = {University Lille 1 - Sciences et Technologies - France},
	abstract = {High-level languages implement reflection which allows a language runtime to inspect and alter its own execution and state. These high-level languages typically run on top of virtual machines (vms) which have been built to create an abstraction layer over hardware. Due to the isolating nature of the vm, reflection is generally limited to the language-side. Several research vms overcome this separation and provide a unified model where there is no more a clear distinction between language-side and vm-side. In such a language runtime it is possible to reflectively modify vm components from language-side as they reside on the same abstraction layer. In this dissertation we follow the same global direction towards a unified language-runtime or self-aware vm. However, instead of looking for a holistic solution we focus on a minimal approach. Instead of using a custom tailored language runtime we use dynamic native code activation from language-side on top of an existing vm. We first present Benzo our framework for dynamic native code activation. Benzo provides a generic but low-level interface to the vm internals. Based on this framework we then evaluate several applications that typically require direct vm support. We show first how Benzo is used to build an efficient ffi interface, allowing for a more structured access to vm internal functions. To evaluate the limitations of Benzo we target two more applications: dynamic primitives and a language-side jit compiler. Both of them require a tight interaction with the underlying vm.},
	Month = {may},
	Year = {2014},
  Url = {http://rmod.inria.fr/archives/phd/PhD-2014-Bruni.pdf}}

@inproceedings{Casa09a,
	Abstract = {Long-lived systems rely on reflective self-modification to evolve.  Unfortunately, since such a system is at both ends of a causal loop, this means modifications that impact the reflective layer itself can be overly difficult to apply.  This paper introduces ObjectSpaces, a reification of the familiar Smalltalk image as a first-class entity. By confining the system inside an ObjectSpace, we isolate the evolution tools from it, while still giving them reflective access to the confined system.  We describe the ObjectSpaces idea, the interface to communicate, inspect, and debug objects contained inside and ObjectSpace, based on a prototype implementation in GNU Smalltalk.},
	Address = {New York, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Author = {Gwena{\"e}l Casaccio and Damien Pollet and Marcus Denker and St{\'e}phane Ducasse},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'09)},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {remoose2-pub marcusdenker lse-pub kzObjectSpace kzModule},
	Labo = {dans},
	Pages = {77-81},
	Publisher = {ACM digital library},
	Selectif = {non},
	Title = {Object Spaces for Safe Image Surgery},
	Url = {http://rmod.inria.fr/archives/workshops/Casa09a-IWST09-ObjectSpaces.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CL},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Casa11a,
	Abstract = {Smalltalk is a reflective system. It means that it is defined in itself in a causally connected way. Traditionally, Smalltalk systems evolved by modifying and cloning what is called an image (a chunk of memory containing all the objects at a given point in time). During the evolution of the system, objects representing it are modified. However, such an image modification and cloning poses several problems: (1) There is no operational machine-executable algorithm that allows one to build a system from scratch. A system object may be modified but it may be difficult to reproduce its exact state before the changes. Therefore it is difficult to get a reproducible process. (2) As a consequence, certain classes may not have been initialized since years. (3) Finally, since the system acts as a living system, it is not simple to evolve the kernel for introducing new abstractions without performing some kind of brain surgery on oneself. There is a need to have a step by step process to build Smalltalk kernels from scratch. In this paper, after an analysis of past and current practices to mutate or generate kernels, we describe a kernel bootstrap process step-by-step. First the illusion of the existence of a kernel is created via stubs objects. Second the classes and meta-classes hierarchy are generated. Code is compiled and finally information needed by the virtual machine and execution are generated and installed.},
	Address = {Bernal, Buenos Aires, Argentina},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Gwenael Casaccio and St\'ephane Ducasse and Luc Fabresse and Jean-Baptiste Arnaud and van Ryseghem, Benjamin},
	Booktitle = {Proceedings of Smalltalks 2011 International Workshop},
	Hal-Id = {inria-00636785},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 kzReflection},
	Labo = {dans},
	Selectif = {non},
	Title = {Bootstrapping a Smalltalk},
	Url = {http://rmod.inria.fr/archives/workshops/Casa11a-Smalltalks-BootstrappingASmalltalk.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@inproceedings{Cass06a,
	Address = {Prague, Czech Republic},
	Annote = {tooldemo},
	Author = {Cassou, Damien and Kuche, Karsten},
	Booktitle = {European Smalltalk User Group Innovation Technology Award},
	Month = sep,
	Note = {demonstration},
	Selectif = {non},
	Title = {Dakar Testing},
	Year = {2006}}

@inproceedings{Cass07a,
	Abstract = {Recently, traits have been proposed as a single
                  inheritance backward compatible solution in which
                  the composing entity has the control over the trait
                  composition. Traits are fine-grained units used to
                  compose classes, while avoiding many of the problems
                  of multiple inheritance and mixin-based approaches.
                  To evaluate the expressiveness of traits, some
                  hierarchies were refactored, showing code reuse.
                  However, such large refactorings, while valuable,
                  may not be facing all the problems, since the
                  hierarchies were previously expressed within single
                  inheritance and following certain patterns. We
                  wanted to evaluate how traits enable reuse, and what
                  problems could be encountered when building a
                  library using traits from scratch, taking into
                  account that traits are units of reuse. This paper
                  presents our work on designing a new stream library
                  named Nile. We present the reuse that we attained
                  using traits, and the problems we encountered.},
	Address = {Lugano, Switzerland},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {ICDL'07: Proceedings of the 15th International Conference on Dynamic Languages},
	Doi = {10.1145/1352678.1352682},
	Inria = {hors},
	Isbn = {978-1-60558-084-5},
	Keywords = {nile cook kzTrait},
	Month = aug,
	Pages = {50--75},
	Publisher = {ACM Digital Library},
	Selectif = {non},
	Title = {Redesigning with Traits: the {Nile} Stream trait-based Library},
	Url = {http://scg.unibe.ch/archive/papers/Cass07aTraitsStreamRedesign-ICDL.pdf},
  Year = {2007}}

@mastersthesis{Cass07b,
	Abstract = {R\'ecemment, les traits ont propos\'e un solution
                  compatible avec l'h\'eritage simple dans lequel
                  l'entit\'e qui compose a le contr\^ole sur la
                  composition. Les traits sont des \'el\'ements \`a
                  granularit\'e fine qui permettent la composition de
                  classes, mais qui \'evite la plupart des probl\`emes
                  pos\'es par l'h\'eritage multiple et les approches
                  bas\'ees sur les mixins. Pour \'evaluer
                  l'efficacit\'e des traits, des biblioth\`eques ont
                  \'et\'e refactoris\'ees, montrant une
                  r\'eutilisation importante du code. Cependant, bien
                  que ces travaux soient int\'eressants, ils ne
                  permettent pas de rencontrer tous les probl\`emes
                  d'utilisation des traits ; ceci parce que les
                  biblioth\`eques d'origines \'etaient r\'ealis\'ees
                  et pens\'ees avec les contraintes de l'h\'eritage
                  simple. Nous souhaitons \'evaluer l'expressivit\'e
                  des traits lors de la r\'ealisation d'un projet
                  complet, en se servant des traits comme unit\'e de
                  r\'eutilisation de comportement. Ce document
                  pr\'esente le design d'une nouvelle biblioth\`eque
                  de streams appel\'ee Nile. Nous pr\'esentons les
                  traits que nous avons d\'efinis et leur
                  r\'eutilisabilit\'e ainsi que les probl\`emes
                  auxquels nous avons fait face.},
	Annote = {master},
	Author = {Damien Cassou},
	Keywords = {nile cook},
	Month = aug,
	School = {University of Bordeaux},
	Title = {Remodularisation \`a base de traits},
	Url = {http://scg.unibe.ch/archive/external/Cass07b.pdf},
  Year = {2007}}

@inproceedings{Cass07c,
	Address = {Ecole Polytech'Nice-Sophia, France},
	Author = {Cassou, Damien},
	Booktitle = {JM2L'07: Journ\'ees M\'editerran\'eennes du Logiciel Libre},
	Month = nov,
	Note = {invited talk},
	Selectif = {non},
	Title = {Smalltalk et Seaside},
	Year = {2007}}

@article{Cass09a,
	Abstract = {Recent years saw the development of a composition
                  mechanism called Traits. Traits are pure units of
                  behavior that can be composed to form classes or
                  other traits. The trait composition mechanism is an
                  alternative to multiple or mixin inheritance in
                  which the composer has full control over the trait
                  composition. To evaluate the expressiveness of
                  traits, some hierarchies were refactored, showing
                  code reuse. However, such large refactorings, while
                  valuable, may not exhibit all possible composition
                  problems, since the hierarchies were previously
                  expressed using single inheritance and following
                  certain patterns. This paper presents our work on
                  designing and implementing a new trait-based stream
                  library named Nile. It evaluates how far traits
                  enable reuse, what problems can be encountered when
                  building a library using traits from scratch and
                  compares the traits solution to alternative
                  composition mechanisms. Nile's core allows the
                  definition of compact collection and file streaming
                  libraries as well as the implementation of a
                  backward-compatible new stream library. Nile method
                  size shows a reduction of 40\% compared to the Squeak
                  equivalent. The possibility to reuse the same set of
                  traits to implement two distinct libraries is a
                  concrete illustration of trait reuse capability.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Damien Cassou and St\'ephane Ducasse and Roel Wuyts},
	Doi = {10.1016/j.cl.2008.05.004},
	Hal = {inria-00216108,celwz9},
	Hal-Id = {inria-00216108},
	Impactfactor = {Impact factor (2010) 0.619},
	Inria = {RMOD},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {cook nile stlit-traits kzTrait},
	Number = {1},
	Pages = {2--20},
	Publisher = {Elsevier},
	Selectif = {oui},
	Title = {Traits at Work: the design of a new trait-based stream library},
	Url = {http://scg.unibe.ch/archive/papers/Cass08a-NileNewKernel-ComputerLanguages.pdf},
	Volume = {35},
  Year = {2009}}

@inproceedings{Cass09b,
	Abstract = {Developing pervasive computing applications is a
                  difficult task because it requires to deal with a
                  wide range of issues: heterogeneous devices, entity
                  distribution, entity coordination, low-level
                  hardware knowledge... Besides requiring various
                  areas of expertise, programming such applications
                  involves writing a lot of administrative code to
                  glue technologies together and to interface with
                  both hardware and software components. This paper
                  proposes a generative programming approach to
                  providing programming, execution and simulation
                  support dedicated to the pervasive computing domain.
                  This approach relies on a domain-specific language,
                  named DiaSpec, dedicated to the description of
                  pervasive computing systems. Our generative approach
                  factors out features of distributed systems
                  technologies, making DiaSpec-specified software
                  systems portable. The DiaSpec compiler is
                  implemented and has been used to generate dedicated
                  programming frameworks for a variety of pervasive
                  computing applications, including detailed ones to
                  manage the building of an engineering school.},
	Acceptnum = {18},
	Accepttotal = {62},
	Address = {Denver, CO, USA},
	Annote = {InternationalConference},
	Author = {Cassou, Damien and Bertran, Benjamin and Loriant, Nicolas and Consel, Charles},
	Booktitle = {GPCE'09: Proceedings of the 8th International Conference on Generative Programming and Component Engineering},
	Coreranking = {B},
	Doi = {10.1145/1621607.1621629},
	Keywords = {diaspec software architectures generation damiencbib},
	Month = oct,
	Pages = {137--146},
	Publisher = {ACM},
	Title = {A Generative Programming Approach to Developing Pervasive Computing Systems},
	Url = {http://hal.inria.fr/inria-00405819/PDF/gpce42-cassou.pdf},
  Year = {2009}}

@inproceedings{Cass10a,
	Abstract = {Despite much progress, developing a pervasive
                  computing application remains a challenge because of
                  a lack of conceptual frameworks and supporting
                  tools. This challenge involves coping with
                  heterogeneous entities, overcoming the intricacies
                  of distributed systems technologies, working out an
                  architecture for the application, encoding it in a
                  program, writing specific code to test the
                  application, and finally deploying it. We present
                  DiaSuite, a tool suite covering the development
                  life-cycle of a pervasive computing system. This
                  tool suite comprises a domain-specific design
                  language, a compiler for this language, which
                  produces a Java programming framework, an editor to
                  define simulation scenarios, and a 2D-renderer to
                  simulate pervasive computing applications. We have
                  validated our tool suite on a variety of
                  comprehensive applications in areas including
                  telecommunications, building automation, and
                  health-care.},
	Address = {Mannheim, Germany},
	Annote = {tooldemo},
	Author = {Cassou, Damien and Bruneau, Julien and Consel, Charles},
	Booktitle = {PerCom'10: Proceedings of the 8th International Conference on Pervasive Computing and Communications},
	Doi = {10.1109/PERCOMW.2010.5470550},
	Keywords = {damiencbib},
	Month = may,
	Note = {demonstration},
	Pages = {820--822},
	Publisher = {IEEE Computer Society},
	Selectif = {non},
	Title = {A Tool Suite to Prototype Pervasive Computing Applications},
	Url = {http://hal.inria.fr/docs/00/48/40/67/PDF/percom-demo.pdf},
  Year = {2010}}

@misc{Cass10b,
	Abstract = {This poster presents a design language and a tool
                  suite covering the development life-cycle of a
                  Sense/Compute/Control (SCC) application. This
                  language makes it possible to define the
                  architecture of an application, following an
                  architectural pattern commonly used in SCC
                  applications. Our underlying methodology assigns
                  roles to the stakeholders, providing separation of
                  concerns. Our tool suite includes a compiler that
                  takes design artifacts written in our language as
                  input. The compiler generates customized support for
                  subsequent development stages, namely implementation
                  and test. In doing so, it ensures the conformance
                  between the architecture and the code. Our tool
                  suite also includes a simulator for testing SCC
                  applications, without requiring code modification.
                  Our methodology has been applied to a wide spectrum
                  of areas, such as building automation, advanced
                  telecommunications, and health-care.},
	Address = {Reno/Tahoe, NV, USA},
	Annote = {poster},
	Author = {Cassou, Damien and Bruneau, Julien and Mercadal, Julien and Enard, Quentin and Balland, Emilie and Loriant, Nicolas and Consel, Charles},
	Booktitle = {SPLASH'10: Proceedings of the 1st International Conference on Systems, Programming, Languages, and Applications: Software for Humanity},
	Month = oct,
	Note = {poster},
	Pages = {1--2},
	Publisher = {ACM},
	Selectif = {non},
	Title = {Towards a Tool-based Development Methodology for Sense/Compute/Control Applications},
	Url = {http://hal.inria.fr/docs/00/51/03/78/PDF/poster-extended-abstract.pdf},
  Year = {2010}}

@inproceedings{Cass11a,
	Abstract = {A software architecture describes the structure of a
                  computing system by specifying software components
                  and their interactions. Mapping a software
                  architecture to an implementation is a well known
                  challenge. A key element of this mapping is the
                  architecture's description of the data and
                  control-flow interactions between components. The
                  characterization of these interactions can be rather
                  abstract or very concrete, providing more or less
                  implementation guidance, programming support, and
                  static verification. In this paper, we explore one
                  point in the design space between abstract and
                  concrete component interaction specifications. We
                  introduce a notion of interaction contract that
                  expresses allowed interactions between components,
                  describing both data and control-flow constraints.
                  This declaration is part of the architecture
                  description, allows generation of extensive
                  programming support, and enables various
                  verifications. We instantiate our approach in an
                  architecture description language for
                  Sense/Compute/Control applications, and describe
                  associated compilation and verification strategies.},
	Acceptnum = {62},
	Accepttotal = {441},
	Address = {Honolulu, HI, USA},
	Annote = {internationalconference topconference},
	Author = {Cassou, Damien and Balland, Emilie and Consel, Charles and Lawall, Julia},
	Booktitle = {ICSE'11: Proceedings of the 33rd International Conference on Software Engineering},
	Coreranking = {A*},
	Doi = {10.1145/1985793.1985852},
	Keywords = {diaspec diasuite scc generative programming architectural conformance software architectures domain-specific architectures design},
	Month = may,
	Pages = {431--440},
	Publisher = {ACM},
	Title = {Leveraging Software Architectures to Guide and Verify The Development of Sense/Compute/Control Applications},
	Url = {http://hal.inria.fr/docs/00/53/77/89/PDF/icse2011.pdf},
  Year = {2011}}

@phdthesis{Cass11b,
	Abstract = {Nombre d'applications ont pour comportement
                  principal l'attente d'un \'ev\'enement venant d'un
                  environnement ext\'erieur, la pr\'eparation d'un
                  r\'esultat et l'ex\'ecution d'actions sur cet
                  environnement. Les interfaces graphiques et les
                  syst\`emes avioniques en sont des exemples. Le
                  paradigme SCC, pour Sense--Compute--Control, est
                  particuli\`erement adapt\'e \`a la description de ces
                  applications. Le d\'eveloppement d'applications
                  suivant ce paradigme est cependant rendu difficile
                  par le manque de cadre conceptuel et d'outils de
                  support. Cette th\`ese propose un cadre conceptuel
                  d\'edi\'e au paradigme SCC et se concr\'etise par un
                  langage de description d'architectures nomm\'e
                  DiaSpec. Ce langage fournit un cadre de travail pour
                  guider le d\'eveloppement d'une application SCC en
                  assignant des r\^oles aux membres du projet et en
                  proposant une s\'eparation des pr\'eoccupations. En plus
                  de fournir un cadre de conception, cette th\`ese
                  fournit un support de programmation. En effet, \`a
                  partir de descriptions \'ecrites en DiaSpec, un
                  framework de programmation d\'edi\'e est g\'en\'er\'e dans un
                  langage cible. Ce framework de programmation guide
                  l'impl\'ementation d'une application SCC en exposant
                  les m\^emes abstractions que le langage DiaSpec. Ce
                  framework de programmation est con\,cu de fa\,con \`a
                  assurer que l'impl\'ementation d'une application est
                  conforme \`a l'architecture d\'ecrite en DiaSpec, en
                  s'appuyant sur le syst\`eme de types du langage cible.
                  Les contributions de cette th\`ese sont \'evalu\'ees
                  suivant des crit\`eres d'expressivit\'e, d'utilisabilit\'e
                  et de productivit\'e.},
	Author = {Cassou,Damien},
	Keywords = {Software Architecture, Domain-Specific Language, Generative Programming, Architectural Conformance},
	Month = mar,
	School = {University of Bordeaux},
	Title = {D\'eveloppement logiciel orient\'e paradigme de conception : la programmation dirig\'ee par la sp\'ecification},
	Url = {http://tel.archives-ouvertes.fr/docs/00/59/03/61/PDF/thesis.pdf},
  Year = {2011}}

@inproceedings{Cass11c,
	Address = {Campus universitaire de Lille 1, France},
	Arxiv = {1106.4200},
	Author = {Cassou, Damien and Balland, Emilie and Consel, Charles and Lawall, Julia},
	Booktitle = {GDR GPL'11: 3\`eme journ\'ees du G\'enie de la programmation et du logiciel},
	Month = jun,
	Note = {invited talk},
	Pages = {33--34},
	Selectif = {non},
	Title = {Faire levier sur les architectures logicielles pour guider et v\'erifier le d\'eveloppement d'applications {SCC}},
	Year = {2011}}

@inproceedings{Cass11d,
	Address = {Hasso--Plattner--Institute, Potsdam, Germany},
	Arxiv = {1109.2807},
	Author = {Cassou, Damien},
	Booktitle = {FutureSOC'11: 6th HPI Symposium on Future Trends in Service-oriented Computing},
	Month = jun,
	Note = {invited talk},
	Selectif = {non},
	Title = {Leveraging Software Architectures to Guide and Verify the Development of Sense/Compute/Control Applications},
	Url = {http://www.hpi.uni-potsdam.de/research\_school/activities/events/future\_trends\_in\_soc\_2011.html},
	Year = {2011}
	}

@inproceedings{Cass11e,
	Abstract = {A Sense/Compute/Control (SCC) application is one
                  that interacts with the physical environment. Such
                  applications are pervasive in domains such as
                  building automation, assisted living, and autonomic
                  computing. Developing an SCC application is complex
                  because: (1) the implementation must address both
                  the interaction with the environment and the
                  application logic; (2) any evolution in the
                  environment must be reflected in the implementation
                  of the application; (3) correctness is essential, as
                  effects on the physical environment can have
                  irreversible consequences. The SCC architectural
                  pattern and the DiaSpec domain-specific design
                  language propose a framework to guide the design of
                  such applications. From a design description in
                  DiaSpec, the DiaSpec compiler is capable of
                  generating a programming framework that guides the
                  developer in implementing the design and that
                  provides ru=ntime support. In this paper, we report
                  on an experiment using DiaSpec (both the design
                  language and compiler) to develop a standard
                  robotics application. We discuss the benefits and
                  problems of using DiaSpec in a robotics setting
                  and present some changes that would make DiaSpec
                  a better framework in this setting.},
	Address = {San Francisco, CA, USA},
	Arxiv = {1109.2806},
	Author = {Cassou, Damien and Stinckwich, Serge and Koch, Pierrick},
	Booktitle = {DSLRob'11: Proceedings of the 2nd International Workshop on Domain-Specific Languages and models for ROBotic systems},
	Month = sep,
	Selectif = {non},
	Title = {Using the {DiaSpec} design language and compiler to develop robotics systems},
	Url = {http://fr.arxiv.org/pdf/1109.2806},
  Year = {2011}}

@article{Cass11f,
	Abstract = {Despite much progress, developing a pervasive
                  computing application remains a challenge because of
                  a lack of conceptual frameworks and supporting
                  tools. This challenge involves coping with
                  heterogeneous devices, overcoming the intricacies of
                  distributed systems technologies, working out an
                  architecture for the application, encoding it in a
                  program, writing specific code to test the
                  application, and finally deploying it. This paper
                  presents a design language and a tool suite covering
                  the development life-cycle of a pervasive computing
                  application. The design language allows to define a
                  taxonomy of area-specific building-blocks,
                  abstracting over their heterogeneity. This language
                  also includes a layer to define the architecture of
                  an application, following an architectural pattern
                  commonly used in the pervasive computing domain. Our
                  underlying methodology assigns roles to the
                  stakeholders, providing separation of concerns. Our
                  tool suite includes a compiler that takes design
                  artifacts written in our language as input and
                  generates a programming framework that supports the
                  subsequent development stages, namely
                  implementation, testing, and deployment. Our
                  methodology has been applied on a wide spectrum of
                  areas. Based on these experiments, we assess our
                  approach through three criteria: expressiveness,
                  usability, and productivity.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationaljournal},
	Author = {Cassou, Damien and Bruneau, Julien and Consel, Charles and Balland, Emilie},
	Coreranking = {A*},
	Doi = {10.1109/TSE.2011.107},
	Impactfactor = {Impact Factor (2010) 3.468},
	Issn = {0098-5589},
	Journal = {IEEE TSE: Transactions on Software Engineering},
	Keywords = {diaspec diasuite},
	Month = nov,
	Number = {6},
	Pages = {1445--1463},
	Publisher = {IEEE Computer Society},
	Title = {Towards a Tool-based Development Methodology for Pervasive Computing Applications},
	Url = {http://hal.inria.fr/docs/00/68/32/10/PDF/TSE-2010-06-0178.R3\_Cassou.pdf},
	Volume = {38},
  Year = {2012}}

@techreport{Cass13a,
	Abstract = {Isolating programs is an important mechanism to
                  support more secure applications. Isolating program
                  in dynamic languages such as JavaScript is even more
                  challenging since reflective operations can
                  circumvent simple mechanisms that could protect
                  program parts. In this article we present SafeJS, an
                  approach and implementation that offers isolation
                  based on separate sandboxes and control of
                  information exchanged between them. In SafeJS,
                  sandboxes based on web workers do not share any
                  data. Data exchanged between sandboxes is solely
                  based on strings. Using different policies, this
                  infrastructure supports the isolation of the
                  different scripts that usually populate web pages. A
                  foreign component cannot modify the main DOM tree in
                  unexpected manner. Our SafeJS implementation is
                  currently being used in an industrial setting in the
                  context of the Resilience FUI 12 project.},
	Affiliation = {RMoD - Inria Lille-Nord Europe , Laboratoire d'Informatique Fondamentale de Lille - LIFL},
	Annote = {technicalreport},
	Author = {Cassou, Damien and Ducasse, St{\'e}phane and Petton, Nicolas},
	Hal-id = {hal-00862099},
	Institution = {Inria},
	Keywords = {sandboxing javascript web worker DOM isolation lse-pub stefPub KZLanguageDesign},
	Language = {Anglais},
	Month = sep,
	Pages = {7},
	Title = {{SafeJS}: Hermetic Sandboxing for JavaScript},
	Type = {Rapport Technique},
	Url = {http://rmod.inria.fr/archives/reports/Cass13a-Resilience-SafeJS.pdf},
  Year = {2013}}

@book{Cass15a,
	author = {Damien Cassou and St\'ephane Ducasse and Luc Fabresse and Johan Fabry and  Van Caekenberghe, Sven},
	Annote = {book},
	title = {Enterprise Pharo: a Web Perspective},
	year = {2015},
	Hal-ID = {hal-01223026},
	Publisher = {Square Bracket Associates}
}

@inproceedings{Cast12a,
	Acmid = {2307441},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Articleno = {5},
	Author = {Castro, Sergio and Gonz\'{a}lez, Sebasti\'{a}n and Mens, Kim and Denker, Marcus},
	Booktitle = {Proceedings of the International Workshop on Context-Oriented Programming},
	Doi = {10.1145/2307436.2307441},
	Hal-Id = {hal-00720348},
	Inria = {RMOD},
	Inriareport = {2012},
	Isbn = {978-1-4503-1276-9},
	Keywords = {lse-pub raweb2012},
	Labo = {dans},
	Location = {Beijing, China},
	Numpages = {6},
	Pages = {5:1--5:6},
	Publisher = {ACM},
	Selectif = {non},
	Series = {COP '12},
	Title = {DynamicSchema: a lightweight persistency framework for context-oriented data management},
	Url = {http://rmod.inria.fr/archives/papers/Cast12-COP12-DynamicSchema.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BE},
	X-Proceedings = {yes},
  Year = {2012}}

@unpublished{Char13a,
	Abstract = {{Modern languages are typically supported by managed runtimes (Virtual Machines). Since VMs have to deal with many concepts such as memory management, abstract execution model and scheduling, they tend to be very complex. Additionally, VMs have to meet strong performance requirements. This demand of performance is one of the main reasons why many VMs are built statically. Thus, design decisions are frozen at compile time preventing changes at runtime. One clear example is the impossibility to dynamically adapt or change primitives of the VM once it has been compiled. In this work we present a toolchain that allows for altering and configuring components such as primitives and plug-ins at runtime. The main contribution is Waterfall, a dynamic and reflective translator from Slang, a restricted subset of Smalltalk, to native code. Waterfall generates primitives on demand and executes them on the fly. We validate our approach by implementing dynamic primitive modification and runtime customization of VM plug-ins.}},
	Affiliation = {Laboratory on Foundations and Tools for Software Engineering - LAFHIS , RMOD - INRIA Lille - Nord Europe},
	Author = {Chari, Guido and Garbervetsky, Diego and Bruni, Camillo and Denker, Marcus and Ducasse, St{\'e}phane},
	Hal-Id = {hal-00871353},
	Language = {English},
	Month = {sep},
	Note = {Submitted},
  Title = {Waterfall: Primitives Generation on the Fly},
  Url = {http://hal.inria.fr/hal-00871353/PDF/Waterfall.pdf},
  Year = {2013}}

@inproceedings{Char15a,
	Abstract = {Modern development environments promote live programming (LP) mechanisms because it enhances the development experience by providing instantaneous feedback and interaction with live objects. LP is typically supported with advanced reflective techniques within dynamic languages. These languages run on top of Virtual Machines (VMs) that are built in a static manner so that most of their components are bound at compile time. As a consequence, VM developers are forced to work using the traditional edit-compile-run cycle, even when they are designing LP-supporting environments. In this paper we explore the idea of bringing LP techniques to VM development to improve the observabil-ity, evolution and adaptability of VMs at run-time. We define the notion of fully reflective execution environments , systems that provide reflection not only at the application level but also at the level of the execution environment (EE). We characterize such systems, propose a design, and present Mate v1, a prototypical implementation. Based on our prototype, we analyze the feasibility and applicability of incorporating reflective capabilities into different parts of EEs. Furthermore, the evaluation demonstrates the opportunities such reflective capabilities provide for unanticipated dynamic adaptation scenarios, benefiting thus, a wider range of users.},
		Annote = {internationalconference},
		Author = {Guido Chari and Diego Garbervetsky and Stefan Marr and St\'ephane Ducasse},
		Hal-Id = {hal-01185843},
		Inria = {RMOD},
		booktitle = {Onward! 2015},
		Keywords = {kzReflection kzLanguageDesign stefPub},
		Labo = {dans},
		Numpages = {10},
		Selectif = {non},
		Title = {Towards Fully Reflective Environments},
		Url = {http://rmod.inria.fr/archives/papers/Char15a-Onward-ReflectiveVM.pdf},
    Year = {2015}}

@article{Chis15c,
	Abstract = {Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debugger is adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.},
	Annote = {internationaljournal},
	Author = {Andrei Chis and Marcus Denker and Tudor Girba and Oscar Nierstrasz},
	Hal-Id = {inria-01247941},
	Doi = {10.1016/j.cl.2015.08.00},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {marcusdenker},
	Number = {A},
	Pages = {89-113},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Practical domain-specific debuggers using the Moldable Debugger framework},
	Url = {http://rmod.inria.fr/archives/papers/Chis15c-PracticalDomainSpecificDebuggers.pdf},
	Volume = {44},
	Year = {2015}}

@inproceedings{Cout12a,
	Abstract = {Abstract-Bug prediction is an important challenge for software engineering research. It consist in looking for possible early indicators of the presence of bugs in a software. However, despite the relevance of the issue, most experiments designed to evaluate bug prediction only investigate whether there is a linear relation between the predictor and the presence of bugs. However, it is well known that standard regression models can not filter out spurious relations. Therefore, in this paper we describe an experiment to discover more robust evidences towards causality between software metrics (as predictors) and the occurrence of bugs. For this purpose, we have relied on Granger Causality Test to evaluate whether past changes in a given time series are useful to forecast changes in another series. As its name suggests, Granger Test is a better indication of causality between two variables. We present and discuss the results of experiments on four real world systems evaluated over a time frame of almost four years. Particularly, we have been able to discover in the history of metrics the causes --- in the terms of the Granger Test --- for 64\% to 93\% of the defects reported for the systems considered in our experiment.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Cesar Couto and Christofer Silva and Marco T. Valente and Roberto Bigonha and Nicolas Anquetil},
	Booktitle = {Proceedings of the 16th European Conference on Software Maintenance and Reengineering (CSMR'12)},
	Hal-Id = {hal-00668151},
	Inria = {RMOD},
	Inriareport = {2012},
	Keywords = {moose lse-pub raweb2012},
	Labo = {dans},
	Misc = {acceptance rate: 30/108 = 28\%},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Title = {Uncovering Causal Relationships between Bugs and Software Metrics},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2012}}



@inproceedings{Cout13a,
	Abstract = {Despite the increasing number of bug analysis tools for exploring bugs in software systems, there are no tools supporting the investigation of causality relationships between internal quality metrics and bugs. In this paper, we propose an extension of the BugMaps tool called BugMaps-Granger that allows the analysis of source code properties that caused bugs. For this purpose, we relied on Granger Causality Test to evaluate whether past changes to a given time series of source code metrics can be used to forecast changes in a time series of defects. Our tool extracts source code versions from version control platforms, generates source code metrics and defects time series, computes Granger, and provides interactive visualizations for causal analysis of bugs. We also provide a case study in order to evaluate the tool.},
	Aeres = {ACT},
	Annote = {tooldemo},
	Author = {Cesar Couto and Pedro Pires and Marco T\'ulio Valente and Roberto Bigonha and Andre Hora and Nicolas Anquetil},
	Booktitle = {Proceedings of the 4th Brazilian Conference on Software: Theory and Practice (CBSoft'13)},
	Hal-Id = {hal-00854883},
	Inria = {RMOD},
	Inriareport = {2013},
	Keywords = {moose lse-pub kzVisualization},
	Labo = {dans},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Title = {BugMaps-Granger: A Tool for Causality Analysis between Source Code Metrics and Bugs},
	Url = {http://rmod.inria.fr/archives/papers/Cout13a-BugMapsGranger-CBSoft13.pdf},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2013}}

@article{Cout14a,
	Aeres = {ACL},
	Aeresstatus = {aeres14},
	Annote = {internationaljournal},
	Author = {Cesar Couto and Pedro Pires and Marco T\'ulio Valente and Roberto da Silva Bigonha and Nicolas Anquetil},
	Bibsource = {dblp computer science bibliography, http://dblp.org},
	Biburl = {http://dblp.uni-trier.de/rec/bib/journals/jss/CoutoPVBA14},
	Doi = {10.1016/j.jss.2014.01.033},
	Hal-Id = {hal-01086783},
	Impactfactor = {Impact Factor (2013) 1.245},
	Issn = {0164-1212},
	Journal = {Journal of Systems and Software (JSS)},
	Labo = {dans},
	Pages = {24--41},
	Peerreview = {yes},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Timestamp = {Sun, 28 Sep 2014 19:16:50 +0200},
	Title = {Predicting software defects with causality tests},
	Url = {http://dx.doi.org/10.1016/j.jss.2014.01.033},
	Volume = {93},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {EN},
  Year = {2014}}

@article{Cout14b,
	Aeres = {ACL},
	Aeresstatus = {aeres14},
	Annote = {internationaljournal},
	Author = {Cesar Couto and Marco T\'ulio Valente and Pedro Pires and Andr\'e Hora and Nicolas Anquetil and Roberto S. Bigonha},
	Hal-Id = {hal-01003078},
	Impactfactor = {Impact Factor (2011) 0.130},
	Issn = {0218-1940},
	Journal = {Journal of Software Engineering Research and Development},
	Labo = {dans},
	Number = {1},
	Pages = {1},
	Peerreview = {yes},
	Publisher = {Springer},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Title = {BugMaps-Granger: a tool for visualizing and predicting bugs using Granger causality tests},
	Url = {http://rmod.inria.fr/archives/papers/Cout14b-BugMapsGranger-jserd.pdf},
	Volume = {2},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {EN},
  Year = {2014}}

@inproceedings{Cruz99a,
	Abstract = {Although coordination of concurrent objects is a fundamental aspect of object-oriented concurrent programming, there is only little support for its specification and abstraction at the language level.  This is a problem because coordination is often buried in the code of the coordinated objects, leading to a lack of abstraction and reuse. Here we present CoLaS, a coordination model and its implementation based on the notion of Coordination Groups. By clearly identifying and separating the coordination from the co-ordinated objects CoLaS provides a better abstraction and reuse of the coordination and the coordinated objects. Moreover CoLaS's high dynamicity provides better support for coordination of active objects.},
	Annote = {internationalconference},
	Author = {Juan-Carlos Cruz and St\'ephane Ducasse},
	Booktitle = {Proceedings of Coordination'99},
	Keywords = {kzLanguageDesign kzCoordination},
	Misc = {Core A},
	Pages = {355--371},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {A Group Based Approach for Coordinating Active Objects},
	Url = {http://scg.unibe.ch/archive/papers/Cruz99aGroupBasedApproach.pdf},
	Volume = {1594},
  Year = {1999}}

@inproceedings{Cruz99b,
	Abstract = {Open Distributed Systems are the dominating intellectual issue of the end of this century.  Figuring out how to build those systems will become a central issue in distributed system research in the next future. Although CORBA seems to provide all the necessary support to construct those systems. It provides a very limited support to the evolution of requirements in those systems. The main problem is that the description of the elements from which systems are built, and the way in which they are composed are mixed into the application code. Making them difficult to understand, modify and customize.  We think that a solution to this problem goes through the introduction of the so called coordination models and languages into the CORBA model. We propose in this paper the introduction of our object coordination model called CoLaS into the CORBA model.},
	Annote = {internationalworkshop},
	Author = {Juan-Carlos Cruz and St\'ephane Ducasse},
	Booktitle = {Proceedings of International Workshop in Future Trends in Distributed Computing Systems '99},
	Doi = {10.1109/FTDCS.1999.818794},
	Keywords = {stefPub kzLanguageDesign kzCoordination},
	Title = {Coordinating Open Distributed Systems},
	Url = {http://scg.unibe.ch/archive/papers/Cruz99FTDCS.pdf},
  Year = {1999}}

@inproceedings{Cuts09a,
	Abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits.
This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.},
	Address = {London, UK},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference topconference},
	Author = {van Cutsem, Tom and Alexandre Bergel and St\'ephane Ducasse and De Meuter, Wolfgang},
	Booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'09)},
	Editor = {Sophia Drossopoulou},
	Hal-Id = {inria-00498397},
	Halpassword = {v?f3e59},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {traits alexPub stefPub kzTrait},
	Labo = {dans},
	Misc = {21\%},
	Publisher = {Springer},
	Rate = {21\%},
	Selectif = {oui},
	Series = {Lecture Notes in Computer Science},
	Title = {Adding State and Visibility Control to Traits using Lexical Nesting},
	Url = {http://rmod.inria.fr/archives/papers/Cuts09a-ECOOP09-Traits.pdf},
	X-Country = {BE},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {BE},
	X-Proceedings = {yes},
  Year = {2009}}

@article{DeKo16a,
	Abstract = {The actor model is a message-passing concurrency model that avoids
deadlocks and low-level data races by construction. This facilitates concurrent
programming, especially in the context of complex interactive applications
where modularity, security and fault-tolerance are required. The tradeoff is
that the actor model sacrifices expressiveness and safety guarantees with
respect to parallel access to shared state. In this paper we present domains as
a set of novel language abstractions for safely encapsulating and sharing state
within the actor model. We introduce four types of domains, namely immutable,
isolated, observable and shared domains that each are tailored to a certain
access pattern on that shared state. The domains are characterized with an
operational semantics. For each we discuss how the actor model's safety
guarantees are upheld even in the presence of conceptually shared state.
Furthermore, the proposed language abstractions are evaluated with a case study
in Scala comparing them to other synchonisation mechanisms to demonstrate their
benefits in deadlock freedom, parallel reads, and enforced isolation.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {De Koster, Joeri and Marr, Stefan and Van Cutsem, Tom and D'Hondt, Theo},
	Doi = {10.1016/j.cl.2016.01.003},
	Hal-Id = {hal-01273665},
	Impactfactor = {Impact factor (2014) 0.440},
	Inria = {hors},
	Journal = {Computer Languages, Systems \& Structures},
	Keywords = {lse-pub stefanmarr},
	Month = jan,
	Publisher = {Elsevier},
	Selectif = {non},
    numpages = {39},
	Title = {Domains: Sharing State in the Communicating Event-Loop Actor Model},
	Url = {http://rmod.inria.fr/archives/papers/DeKo16a-COMLAN-Domains.pdf},
	Volume = {31},
	Year = {2016}}

@inproceedings{DeWa14a,
	Abstract = {Now that multicore processors are commonplace, developing parallel software has escaped the confines of high-performance computing and enters the mainstream. The Fork/Join framework, for instance, is part of the standard Java platform since version 7. Fork/Join is a high-level parallel programming model advocated to make parallelizing recursive divide-and-conquer algorithms particularly easy. While, in theory, Fork/Join is a simple and effective technique to expose parallelism in applications, it has not been investigated before whether and how the technique is applied in practice. We therefore performed an empirical study on a corpus of 120 open source Java projects that use the framework for roughly 362 different tasks.
On the one hand, we confirm the frequent use of four best-practice patterns (Sequential Cutoff, Linked Subtasks, Leaf Tasks, and avoiding unnecessary forking) in actual projects. On the other hand, we also discovered three recurring anti-patterns that potentially limit parallel performance: sub-optimal use of Java collections when splitting tasks into subtasks as well as when merging the results of subtasks, and finally the inappropriate sharing of resources between tasks. We document these anti-patterns and study their impact on performance.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Mattias {De Wael}, Stefan Marr, Tom {Van Cutsem}},
	Booktitle = {Proceedings of PPPJ 2014},
	Doi = {10.1145/2647508.2647511},
	Hal-Id = {hal-01064872},
	Inria = {RMOD},
	Inriareport = {2014},
	Isbn = {978-1-4503-2926-2},
	Keywords = {lse-pub stefanmarr},
	Month = sep,
	Numpages = {12},
	Pages = {39--50},
	Peer = {yes},
	Publisher = {ACM},
	Series = {PPPJ '14},
	Title = {Fork/Join Parallelism in the Wild: Documenting Patterns and Anti-Patterns in Java Programs using the Fork/Join Framework},
	Url = {http://rmod.inria.fr/archives/papers/DeWa14a-PPPJ14-ForkJoin.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2014}}

@inproceedings{DeWa15a,
	Abstract = {Today, software engineering practices focus on finding the single right data representation (i.e., data structure) for a program. The right data representation, however, might not exist: relying on a single representation of the data for the lifetime of the program can be suboptimal in terms of performance. We explore the idea of developing data structures for which changing the data representation is an intrinsic property. To this end we introduce Just-in-Time Data Structures, which enable representation changes at runtime, based on declarative input from a performance expert programmer. Just-in-Time Data Structures are an attempt to shift the focus from finding the right data structure to finding the right sequence of data representations. We present JitDS-Java, an extension to the Java language, to develop Just-in-Time Data Structures. Further, we show two example programs that benefit from changing the representation at runtime.},
		Annote = {internationalconference},
		Author = {De Wael, Mattias and Marr, Stefan and De Koster, Joeri and Sartor, Jennifer B. and De Meuter, Wolfgang},
		Hal-Id = {hal-01205343},
		Inria = {RMOD},
		booktitle = {Onward! 2015},
		Keywords = {Algorithms DataStructures DynamicReclassification Optimizations Performance},
		Labo = {dans},
		Numpages = {10},
		Selectif = {non},
		Title = {Just-in-Time Data Structures},
		Url = {http://rmod.inria.fr/archives/papers/DaWa15a-Onward-Just-in-Time-Data-Structures.pdf},
		PDF = {http://rmod.inria.fr/archives/papers/DaWa15a-Onward-Just-in-Time-Data-Structures.pdf},
		Year = {2015}}

@article{DeWa16a,
	Abstract = {The Partitioned Global Address Space (PGAS) model is a parallel programming model that aims to improve programmer productivity while at the same time aiming for high performance. The main premise of PGAS is that a globally shared address space improves productivity, but that a distinction between local and remote data accesses is required to allow performance optimizations and to support scalability on large-scale parallel architectures. To this end, PGAS preserves the global address space while embracing awareness of non-uniform communication costs.
Today, about a dozen languages exist that adhere to the PGAS model. This survey proposes a definition and a taxonomy along four axes: how parallelism is introduced, how the address space is partitioned, how data is distributed among the partitions and finally how data is accessed across partitions. Our taxonomy reveals that today's PGAS languages focus on distributing regular data and distinguish only between local and remote data access cost, whereas the distribution of irregular data and the adoption of richer data access cost models remain open challenges.},
	Added-At = {2015-01-26T12:02:26.000+0100},
	Aeres = {ACL},
	Author = {De Wael, Mattias and Marr, Stefan and De Fraine, Bruno and Van Cutsem, Tom and De Meuter, Wolfgang},
	Biburl = {http://www.bibsonomy.org/bibtex/2cb43d130c4e8ddeca20fcb5a8215a1e2/gron},
	Hal-Id = {hal-01109405},
	Inria = {RMOD},
	Journal = {ACM Comput. Surv.},
	Keywords = {Concurrency GlobalAddressSpace HPC LanguageDesign MeMyPublication MessagePassing PGAS Parallelism Performance SharedMemory myown},
	annote = {internationalconference},
	Pdf = {http://stefan-marr.de/downloads/acm-csur-de-wael-et-al-partitioned-global-address-space-languages.pdf},
	Publisher = {ACM},
	Selectif = {oui},
	Title = {Partitioned Global Address Space Languages},
	Url = {http://stefan-marr.de/papers/acm-csur-de-wael-et-al-partitioned-global-address-space-languages/},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2016}}

@inproceedings{Deho13a,
	Abstract = {Traits are reusable building blocks that can be composed to share methods across unrelated class hierarchies. Original traits are stateless and cannot express visibility control for methods. Two extensions, stateful traits and freezable traits, have been proposed to overcome these limitations. However, these extensions introduce complexity and have not yet been combined to simultaneously add both state and visibility control to traits. This paper revisits the addition of state and visibility control to traits. Rather than extending the original traits model with additional operations, we allow traits to be lexically nested within other modules. Traits can then have (shared) state and visibility control by hiding variables or methods in their lexical scope. Although the Traits' flattening property has to be revisited, the combination of traits with lexical nesting results in a simple and expressive trait model. We discuss an implementation of the model in AmbientTalk and specify its operational semantics.Software analysis and in particular reverse engineering often involves a large amount of structured data. This data should be pre- sented in a meaningful form so that it can be used to improve soft- ware artefacts. The software analysis community has produced nu- merous visual tools to help understand different software elements. However, most of the visualization techniques, when applied to software elements, produce results that are difficult to interpret and comprehend.
This paper presents five graph layouts that are both expressive for polymetric views and agnostic to the visualization engine. These layouts favor spatial space reduction while emphasizing on clarity. Our layouts have been implemented in the Roassal visualization engine and are available under the MIT License.},
	Annote = {internationalworkshop},
	Author = {Dehouck, Mathieu and Bhatti, Usman and Bergel, Alexandre and Ducasse, St\'ephane},
	Booktitle = {International Workshop on Smalltalk Technologies},
	Hal-Id = {hal-00862065},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {stefPub lse-pub kzVisualization},
	Title = {Pragmatic Visualizations for Roassal: a Florilegium},
	Url = {http://rmod.inria.fr/archives/papers/Deho13a-IWST2013-AlgoRoassal.pdf},
	Year = {2013}}

@inproceedings{Dema14a,
	Address = {Cambridge, United Kingdom},
	Author = {Demarey, Christophe and Cassou, Damien and Ducasse, St{\'e}phane},
	Booktitle = {IWST'14: Proceedings of the 6th International Workshop on Smalltalk Technologies},
	Hal-Id = {hal-01086083},
	Keywords = {package management system ; package manager ; dependency},
	annote = {internationalworkshop},
	Month = {aug},
	Title = {Towards a new package dependency model},
	Url = {https://hal.inria.fr/hal-01086083},
  Year = {2014}}

@inproceedings{Deme00a,
	Abstract = {Reverse engineering is the process of uncovering the design and the design rationale from a functioning software system. Reverse engineering is an integral part of any successful software system, because changing requirements lead to implementations that drift from their original design. In contrast to traditional reverse engineering techniques -which analyse a single snapshot of a system- we focus the reverse engineering effort by determining where the implementation has changed. Since changes of object-oriented software are often phrased in terms of refactorings, we propose a set of heuristics for detecting refactorings by applying lightweight, object-oriented metrics to successive versions of a software system. We validate our approach with three separate case studies of mature object-oriented software systems for which multiple versions are available. The case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system.},
	Acceptnum = {26},
	Accepttotal = {142},
	Address = {New York NY},
	Annote = {internationalconference topconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of 15th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '00)},
	Doi = {10.1145/353171.353183},
	Keywords = {olit scg-pub jb00 snf00 oorp stefPub moose kzMetric},
	Misc = {acceptance rate: 26/142 = 18\%, SCI impact factor 0.190, ranked 66/77},
	Note = {Also in ACM SIGPLAN Notices 35 (10)},
	Pages = {166--178},
	Publisher = {ACM Press},
	Title = {Finding Refactorings via Change Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Deme00aFindingRefactoring.pdf},
  Year = {2000}}

@inproceedings{Deme00d,
	Abstract = {Since object-oriented programming is usually associated with iterative development, reverse engineering must be considered an essential facet of the object-oriented paradigm. The reverse engineering pattern language presented here summarises the reverse engineering experience gathered as part of the FAMOOS project, a project with the explicit goal of investigating reverse and reengineering techniques in an object-oriented context. Due to limitations on EuroPLOP submissions, only part of the full pattern language is presented, namely the patterns describing how to gain an initial understanding of a software system.},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '00},
	Isbn = {3-87940-775-4},
	Keywords = {snf-none stefPub scg-pub skip-doi jb00 kzMetric},
	Pages = {189--208},
	Publisher = {UVK GmbH},
	Title = {A Pattern Language for Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme00dRevEng.pdf},
  Year = {2000}}

@techreport{Deme01y,
	Annote = {report notrefereed},
	Author = {Serge Demeyer and Sander Tichelaar and St\'ephane Ducasse},
	Institution = {University of Bern},
	Keywords = {kzMeta},
	Title = {{FAMIX} 2.1 --- {The} {FAMOOS} {Information} {Exchange} {Model}},
	Year = {2001}}

@book{Deme02a,
	Abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems. This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
	Annote = {book},
	Author = {Serge Demeyer and St{\'e}phane Ducasse and Oscar Nierstrasz},
	Isbn = {1-55860-639-4},
	Keywords = {kzBook},
	Publisher = {Morgan Kaufmann},
	Title = {Object-Oriented Reengineering Patterns},
	Url = {http://www.iam.unibe.ch/~scg/OORP},
  Year = {2002}}

@inproceedings{Deme03a,
	Annote = {workshopproceedings},
	Author = {Serge Demeyer and St\'ephane Ducasse and Kim Mens and Adrian Trifu and Rajesh Vasa},
	Booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
	Keywords = {kzEditor},
	Pages = {72-85},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Reengineering},
	Year = {2003}}

@misc{Deme03b,
	Annote = {workshopproceedings},
	Author = {Wolfgang Demeuter and St\'ephane Ducasse and Theo D'hondt and Ole Lehrmann Madsen},
	Booktitle = {Object-Oriented Technology (ECOOP'03 Workshop Reader)},
	Keywords = {kzEditor},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
	Year = {2003}}

@inproceedings{Deme05a,
	Abstract = {The notion of refactoring --- transforming the source-code of an object-oriented program without changing its external behaviour --- has been studied intensively within the last decade. This diversity has created a plethora of toy-examples, cases and code snippets, which make it hard to assess the current state-of-the-art.  Moreover, due to this diversity, there is currently no accepted way of teaching good refactoring practices, despite the acknowledgment in the software engineering body of knowledge. Therefore, this paper presents a common example --- the LAN simulation --- which has been used by a number of European Universities for both research and teaching purposes.},
	Acceptnum = {13},
	Accepttotal = {54},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and Filip Van Rysselberghe and Tudor G\^irba and Jacek Ratzinger and Radu Marinescu and Tom Mens and Bart Du Bois and Dirk Janssens and St\'ephane Ducasse and Michele Lanza and Matthias Rieger and Harald Gall and Michel Wermelinger and Mohammad El-Ramly},
	Booktitle = {Proceedings of IWPSE 2005 (8th International Workshop on Principles of Software Evolution)},
	Doi = {10.1109/IWPSE.2005.30},
	Inri = {hors},
	Keywords = {kzEvolution},
	Location = {Lisbon, Portugal},
	Misc = {acceptance rate: 13/54=24\%},
	Pages = {123--131},
	Publisher = {IEEE Computer Society Press},
	Rate = {24\%},
	Selectif = {oui},
	Title = {The {LAN}-simulation: A Research and Teaching Example for Refactoring},
	Url = {http://scg.unibe.ch/archive/papers/Deme05aLANRefactoring.pdf},
  Year = {2005}}

@misc{Deme05b,
	Abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Software engineers are now confronted with millions of lines of industrial source code, developed using object-oriented design methods and languages of the late 80s and early 90s.  These systems exhibit a range of problems, effectively preventing them from satisfying the evolving requirements imposed by their customers.  This paper shares our knowledge concerning the reengineering of object-oriented legacy systems. We draw upon our experiences, to show you techniques and tools we have applied on real industrial OO systems to detect and repair problems. In particular, we discuss issues like reverse engineering, design extraction, metrics, refactoring and program visualisation.},
	Address = {Washington, DC, USA},
	Annote = {tutorial},
	Author = {Serge Demeyer and St\'{e}phane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 21st IEEE International Conference on Software Maintenance (ICSM'05)},
	Doi = {10.1109/ICSM.2005.67},
	Isbn = {0-7695-2368-4},
	Keywords = {kzTutorial},
	Note = {tutorial},
	Pages = {723--724},
	Publisher = {IEEE Computer Society},
	Title = {Object-Oriented Reengineering: Patterns and Techniques},
	Url = {http://scg.unibe.ch/archive/papers/Deme05bOORP-Tutorial.pdf},
  Year = {2005}}

@inproceedings{Deme06a,
	Annote = {workshopproceedings},
	Author = {Serge Demeyer and Kim Mens and Roel Wuyts and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Andy Zaidman and Neil Walkinshaw and Ademar Aguiar and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology. ECOOP'05 Workshop Reader},
	Keywords = {scg-pub skip-abstract skip-doi stefPub kzEditor},
	Title = {Report of the 6th ECOOP'05 Workshop on Object-Oriented Reengineering},
	Url = {http://rmod.inria.fr/archives/papers/Deme06a-ECOOP2006-WOOR.pdf},
  Year = {2006}}

@book{Deme08a,
	Abstract = {The rapid growth of object-oriented development over the past twenty years has given rise to many object-oriented systems that are large, complex and hard to maintain. Object-Oriented Reengineering Patterns addresses the problem of understanding and reengineering such object-oriented legacy systems.  This book collects and distills successful techniques in planning a reengineering project, reverse-engineering, problem detection, migration strategies and software redesign. The material in this book is presented as a set of "reengineering patterns" --- recurring solutions that experts apply while reengineering and maintaining object-oriented systems. The principles and techniques described in this book have been observed and validated in a number of industrial projects, and reflect best practice in object-oriented reengineering.},
	Annote = {book},
	Author = {Serge Demeyer and St{\'e}phane Ducasse and Oscar Nierstrasz},
	Isbn = {978-3-9523341-2-6},
	Keywords = {scg-pub skip-doi stefPub moose kzBook},
	Medium = {2},
	Peerreview = {no},
	Publisher = {Square Bracket Associates},
	Title = {Object-Oriented Reengineering Patterns},
	Url = {http://scg.unibe.ch/download/oorp/},
  Year = {2008}}

@unpublished{Deme97z,
	Abstract = {Applying object-oriented design methods and languages does not guarantee that the resulting software systems will be flexible and adaptable. The industrial partners in the FAMOOS project have learned this lesson the hard way: they are now faced with large and rigid software systems that hamper them in meeting a diverse and evolving set of customer requirements. Object-oriented frameworks are touted as a promising solution, but it is unclear how to transform object-oriented legacy systems into frameworks. This paper proposes an approach --i.e, a methodology and tools-- for re-engineering object-oriented systems towards frameworks by means of high-level and low-level restructuring transformations that detect and resolve architectural and detailed design anomalies, and improve application flexibility and adaptability.},
	Author = {Serge Demeyer and St\'ephane Ducasse and Robb Nebbe and Oscar Nierstrasz and Tamar Richner},
	Keywords = {famoos-techrep skip-doi kzEvolution},
	Month = may,
	Note = {technical report},
	Title = {Using Restructuring Transformations to Reengineer Object-Oriented Systems},
	Url = {http://www.iam.unibe.ch/~demeyer/Deme97z/index.html http://scg.unibe.ch/archive/papers/Deme97zWCRE.pdf},
  Year = {1997}}

@inproceedings{Deme98n,
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {famoos scg-pub skip-pdf skip-abstract skip-doi metrics stefPub kzEditor},
	Pages = {247--249},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Do Metrics Support Framework Development?},
	Volume = {1543},
	Year = {1998}}

@inproceedings{Deme99a,
	Abstract = {Maturing a well designed framework requires a set of software metrics to steer the iterative development process. Based on a case study of the VisualWorks/Smalltalk framework for user-interface building, we conclude that today's size and inheritance metrics are not reliable to detect problems but are useful in measuring stability. We expect that this work will contribute to the application of metrics as a project management tool.},
	Annote = {nationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse},
	Booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO'99)},
	Editor = {Jacques Malenfant},
	Keywords = {famoos scg-pub skip-doi oorp stefPub moose kzMetric},
	Pages = {69--82},
	Publisher = {HERMES Science Publications, Paris},
	Title = {Metrics, Do They Really Help?},
	Url = {http://scg.unibe.ch/archive/papers/Deme99aDemeyerDucasseLMO99.pdf},
  Year = {1999}}

@inproceedings{Deme99c,
	Abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. Consequently, reverse engineering techniques are relevant in an object-oriented context as well. This paper investigates a hybrid approach, combining the immediate appeal of visualisations with the scalability of metrics. We validate such a hybrid approach by showing how CodeCrawler ---the experimental platform we built--- allowed us to understand the program structure of, and identify potential design anomalies in a public domain software system.},
	Annote = {internationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of Working Conference on Reverse Engineering (WCRE'99)},
	Doi = {10.1109/WCRE.1999.806958},
	Editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
	Keywords = {famoos scg-pub oorp stefPub moose kzVisualization},
	Month = oct,
	Publisher = {IEEE Computer Society},
	Title = {A Hybrid Reverse Engineering Platform Combining Metrics and Program Visualization},
	Url = {http://scg.unibe.ch/archive/papers/Deme99cCodeCrawler.pdf},
  Year = {1999}}

@inproceedings{Deme99d,
	Abstract = {UML is currently embraced as "the" standard in object-oriented modeling languages, the recent work of OMG on the Meta Object Faci lity (MOF) being the most noteworthy example. We welcome these standardisation efforts, yet warn against the tendency to use UML as the panacea for all exchange standards. In particular, we argue that UML is not sufficient to serve as a tool-interoperability standard for integrating round-trip engineering tools, because one is forced to rely on UML's built-in extension mechanisms to a dequately model the reality in source-code. Meanwhile, our argumentation includes a number of constructive suggestions that we ho pe will influence future releases of the UML and MOF standards.},
	Acceptnum = {44},
	Accepttotal = {166},
	Address = {Kaiserslautern, Germany},
	Annote = {internationalconference},
	Author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
	Booktitle = {Proceedings of the International Conference on The Unified Modeling Language (UML'99)},
	Editor = {Bernhard Rumpe},
	Keywords = {famoos-papref scg-pub skip-doi stefPub moose kzMeta},
	Misc = {acceptance rate: 44/166 = 26\%, SCI impact 0.515, ranked 39/69},
	Month = oct,
	Pages = {630--644},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Why Unified is not Universal. {UML} Shortcomings for Coping with Round-trip Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme99dUML99.pdf},
	Volume = {1723},
  Year = {1999}}

@inproceedings{Deme99n,
	Abstract = {This pattern language describes how to reverse engineer an object-oriented software system. Since the only way to achieve a truly reusable object-oriented design is recognised to be iterative development, reverse engineering is indeed an essential facet of any object-oriented development process. The pattern language itself covers the different phases one encounters when reverse engineering a large software system: from being unfamiliar with a software system up untill preparations for actual reengineering. What you read here is a short version of a complete pattern language. We present only five patterns in full detail and include a summary for the remaining patterns.},
	Address = {Konstanz, Germany},
	Annote = {internationalworkshop},
	Author = {Serge Demeyer and St\'ephane Ducasse and Sander Tichelaar},
	Booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing},
	Editor = {Paul Dyson},
	Keywords = {scg-pub skip-doi stefPub kzPattern},
	Month = jul,
	Publisher = {UVK Universit\"atsverlag Konstanz GmbH},
	Title = {A Pattern Language for Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Deme99nEuroplop99.pdf},
  Year = {1999}}

@inproceedings{Deni04a,
	Address = {Paris, France},
	Author = {Simon Denier},
	Booktitle = {Actes de la Premi\`ere Journ\'ee Francophone sur le D\'eveloppement du Logiciel par Aspects (JFDLPA'04)},
	Editor = {Pierre Cointe},
	Month = sep,
	Pages = {62--78},
	Title = {Traits Programming with {AspectJ}},
	Url = {http://www.emn.fr/x-info/obasco/events/jfdlpa04/},
  Year = {2004}}

@inproceedings{Deni09a,
	Abstract = {The goal of this work is to visualize inheritance in object-oriented programs to help its comprehension. We propose a single, compact view of all class hierarchies at once using a custom Sunburst layout. It enables to quickly discover interesting facts across classes while preserving the essential relationship between parent and children classes. We explain how standard inheritance metrics are mapped into our visualization. Additionally, we define a new metric characterizing similar children classes. Using these metrics and the proposed layout, a set of common visual patterns is derived.  These patterns allow the programmer to quickly understand how inheritance is used and provide answers to some essential questions when performing program comprehension tasks. Our approach is evaluated through a case study that involves examples from large programs, demonstrating its scalability.},
	Address = {Lake Buena Vista, FL, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Simon Denier and Houari A. Sahraoui},
	Booktitle = {Proceedings of the 3rd International Symposium on Empirical Software Engineering and Measurement (ESEM'09)},
	Editor = {James Miller and Rick Selby},
	Hal-Id = {hal-00746244},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {lse-pub remoose},
	Labo = {dans},
	Publisher = {IEEE Computer Society Press},
	Rate = {39\%},
	Selectif = {non},
	Title = {Understanding the Use of Inheritance with Visual Patterns},
	Url = {http://rmod.inria.fr/archives/papers/Deni09a-ESEM09-VisuInheritance.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CA},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Deni09b,
	Abstract = {Smalltalk was at the birth of current IDEs. Current Smalltalk
IDEs, however, lost their abilities to adapt to developer needs
(edit and jump, back button, auto-completion,...). Therefore
while offering a powerful sets of tools current Smalltalk
IDEs looks clunky and often lacks the application of a consistent set of guidelines. In this paper we sketch some possible IDEs future features or reorganization.},
	Address = {Brest, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Simon Denier and Damien Pollet and St\'ephane Ducasse},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'09)},
	Hal-Id = {hal-00746260},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {lse-pub pharo-pub kzIDE},
	Labo = {dans},
	Selectif = {non},
	Title = {Proposals for the Reborn Pharo Developer},
	Url = {http://rmod.inria.fr/archives/workshops/Deni09b-IWST09-PharoBrowsers.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2009}}

@proceedings{Deni09c,
	Abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. MOOSE is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. MOOSE accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from MOOSE and FAMIX as shared infrastructure.},
	Aeres = {AP},
	Aeresstatus = {aeres12},
	Annote = {workshopproceedings},
	Author = {Simon Denier and Tudor G\^irba},
	Editor = {Simon Denier and Tudor G\^irba},
	Hal-Id = {hal-00746250},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub},
	Labo = {dans},
	Pages = {27},
	Title = {Proceedings of the 3rd Workshop on FAMIX and MOOSE in Software Reengineering (FAMOOSr'09)},
	Url = {http://rmod.inria.fr/archives/workshops/Deni09c-famoosr09-proceedings.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CH},
	X-Proceedings = {yes},
  Year = {2009}}

@techreport{Deni10a,
	Abstract = {The objective of this deliverable is to define a model for (i) assessing the effort of software modification, (ii) identifying healing actions following practices from the Squale quality model defined in the previous workpackage (WP1.3). It defines the input for the next deliverable which is about planning actions once their effort is characterized.},
	Author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
	Hal-Id = {inria-00533656},
	Inriareport = {2010},
	Institution = {INRIA},
	Keywords = {Squale report2010 kzQualityModel},
	Title = {Technical and Economical Model (Squale Deliverable 2.1)},
	Url = {http://rmod.inria.fr/archives/reports/Deni10a-Squale-deliverable21-EcoModel.pdf},
  Year = {2010}}

@techreport{Deni10b,
	Abstract = {The objective of this workpackage is the definition of the global remediation effort on a project. It defines strategies for upgrading quality through assessment and organization of the single remediation tasks as described in WorkPackage 2.1.},
	Author = {Simon Denier and Jannik Laval and St\'ephane Ducasse and Fabrice Bellingard},
	Hal-Id = {inria-00533659},
	Inriareport = {2010},
	Institution = {INRIA},
	Keywords = {Squale report2010 kzQualityModel},
	Title = {Technical Model for Remediation (Squale Deliverable 2.2)},
	Url = {http://rmod.inria.fr/archives/reports/Deni10a-Squale-deliverable21-EcoModel.pdf},
  Year = {2010}}

@inproceedings{Denk00a,
	Abstract = {Mittels CORBA k\"onnen verteilte Applikationen einfach \"uber ein Netzwerk miteinander kommunizieren. Doch das von CORBA zur Verf\"ugung gestellte Kommunikationsmodell reicht in manchen F\"allen nicht aus, es wird ein Modell zur asynchronen Kommunikation zwischen lose gekoppelten Objekten ben\"otigt. Der CORBA Event Service ist ein Versuch, ein solches Kommunikationsmodell bereitzustellen. Der Event Service hat sich aber als unzureichend herausgestellt. Daher wurde er um einige Aspekte zum Notiocation Service erweitert.},
	Author = {Marcus Denker},
	Booktitle = {Architektur vernetzter Systeme},
	Issn = {1432-7864},
	Keywords = {marcusdenker fromscgbib},
	Page = {7--13},
	Publisher = {Universit\"at Karlsruhe, Institut fuer Telematik (Interner Bericht)},
	Title = {Event und Notification Service in CORBA},
	Url = {http://rmod.inria.fr/archives/reports/Denk00a-TechReport-Corba.pdf},
  Year = {2000}}

@article{Denk01a,
	Annote = {notrefereed},
	Author = {Marcus Denker},
	Journal = {Der Eulenspiegel},
	Keywords = {Etoys Squeak Education marcusdenker fromscgbib},
	Number = {2},
	Publisher = {Fachschaft Mathematik/Informatik, University of Karlsruhe},
	Selectif = {non},
	Title = {Squeak: Zur\"uck in die Zukunft},
	Url = {http://rmod.inria.fr/archives/popular/Denk01a-EulenSpiegel-Squeak.pdf},
	Volume = {2001},
  Year = {2001}}

@misc{Denk02a,
	Abstract = {Das Squeak-System m\"ochte eine flexible Programmierumgebung und ein m\"achtiges multimediales Autorensystem f\"ur Kinder bereitstellen. Die besonderen Eigenschaften eines solchen Systems stellen besondere Anforderungen an die Implementierung. Die Studienarbeit zeigt die Probleme der bestehenden Implementierungen auf und stellt einen verbesserten Entwurf vor.},
	Author = {Marcus Denker},
	Keywords = {Squeak marcusdenker fromscgbib},
	Note = {Studienarbeit, Universit\"at Karlsruhe},
	Title = {Entwurf von Optimierungen f\"ur Squeak},
	Url = {http://rmod.inria.fr/archives/reports/Denk02a-Studienarbeit-J3.pdf},
  Year = {2002}}

@mastersthesis{Denk04a,
	Author = {Marcus Denker},
	Keywords = {marcusdenker fromscgbib},
	School = {University of Karlsruhe},
	Title = {Erweiterung eines statischen \"Ubersetzers zu einem Laufzeit\"ubersetzungssystem},
	Type = {diploma thesis},
	Url = {http://rmod.inria.fr/archives/reports/Denk04a-Thesis-Karlsruhe.pdf},
  Year = {2004}}

@inproceedings{Denk04b,
	Abstract = {This is not a real article. While putting together
                  the demo image for for 21C3, I decided to not write
                  an article that is just to be read (mostly because
                  these are really boring to write...) This text is
                  just a short user manual for that thing (we call it
                  Squeak Image) that I will use for the demo at 21C3.
                  So if you follow the instructions, you will be able
                  to go through the slides and play with everything
                  yourself.},
	Author = {Marcus Denker},
	Booktitle = {Proceedings of the 21st Chaos Communication Congress},
	Isbn = {3-934636-02-0},
	Keywords = {fromscgbib marcusdenker},
	Page = {52--59},
	Publisher = {Chaos Computer Club},
	Title = {Squeak@21c3},
	Url = {http://rmod.inria.fr/archives/popular/Denk04b-21C3-Squeak.pdf},
  Year = {2004}}

@inproceedings{Denk05a,
	Abstract = {Squeak allows kids of all ages to be creative with their computer. The goal of the Squeak Project is to build a system without constraints: It is used at schools, universities and in industry. Squeak is an open System: It is implemented in Squeak itself, all parts are available for learning and hacking. The whole source code is available and can be changed while the system is running. Squeak is available on the internet under a free license, it is highly portable and currently used on over 20 different platforms. This talk will give an overview over the Squeak Project: From the eToy kids programming environment up to the Seaside system for professional web development. The eToys make programming fun for children from around age 8. The talk will show how to build simple eToy programs and how Squeak is used at school. But even professional developers are using Squeak; The Seaside framework shows how the openness of Squeak can help to make developers more productive. The last part of the talk will give a glimpse into the future: OpenCroquet. The Croquet project is building a revolutionary collaborative environment based on Squeak. It provides a scalable, peer-to-peer multiuser 3D environment that is completely open for exploration and makes novel ways for communication and interaction possible.},
	Author = {Marcus Denker},
	Booktitle = {Proceedings of LinuxTag 2005},
	Keywords = {fromscgbib marcusdenker},
	Title = {Squeak and Croquet},
	Url = {http://rmod.inria.fr/archives/popular/Denk05a-LinuxTag-Squeak.pdf},
  Year = {2005}}

@article{Denk06a,
	Abstract = {Transforming programs to alter their semantics is of
                  wide interest, for purposes as diverse as
                  off-the-shelf component adaptation, optimization,
                  trace generation, and experimentation with new
                  language features. The current wave of interest in
                  advanced technologies for better separation of
                  concerns, such as aspect-oriented programming, is a
                  solid testimony of this fact. Strangely enough,
                  almost all proposals are formulated in the context
                  of {Java}, in which tool providers encounter severe
                  restrictions due to the rigidity of the environment.
                  This paper present ByteSurgeon, a library to
                  transform binary code in Smalltalk. ByteSurgeon
                  takes full advantage of the flexibility of the
                  Squeak environment to enable bytecode transformation
                  at runtime, thereby allowing dynamic, on-the-fly
                  modification of applications. ByteSurgeon operates
                  on bytecode in order to cope with situations where
                  the source code is not available, while providing
                  appropriate high-level abstractions so that users do
                  not need to program at the bytecode level. We
                  illustrate the use of ByteSurgeon via the
                  implementation of method wrappers and a simple MOP,
                  and report on its efficiency.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Marcus Denker and St\'ephane Ducasse and {\'E}ric Tanter},
	Doi = {10.1016/j.cl.2005.10.002},
	Impactfactor = {Impact factor (2010) 0.541},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub stefPub mdPub fromscgbib marcusdenker kzReflection},
	Month = jul,
	Number = {2-3},
	Pages = {125--139},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Runtime Bytecode Transformation for {Smalltalk}},
	Url = {http://rmod.inria.fr/archives/papers/Denk06a-COMLAN-RuntimeByteCode.pdf},
	Volume = {32},
  Year = {2006}}

@inproceedings{Denk06c,
	Abstract = {The developers of tools for dynamic analysis are faced with choosing from the many approaches to gathering runtime data. Typically, dynamic analysis involves instrumenting the program under investigation to record its runtime behavior.  Current approaches for byte-code based systems like Java and Smalltalk rely often on inserting byte-code into the program under analysis. However, detailed knowledge of the target programming language or virtual machine is required to implement dynamic analysis tools. Obtaining and exploiting this knowledge to build better analysis tools is cumbersome and often distracts the tool builder from the actual goal, which is the analysis of the runtime behavior of a system. In this paper, we argue that we need to adopt a higher level view of a software system when considering the task of abstracting runtime information. We focus on object-oriented virtual machine based languages. We want to be able to deal with the runtime system as a collection of reified first-class entities. We propose to achieve this by introducing a layer of abstraction, i.e., a behavioral middle layer. This has the advantage that the task of collecting dynamic information is not concerned with low level details of a specific language or virtual machine.  The positive effect of such a behavioral middle layer is twofold: on the one hand it provides us with a standard API for all dynamic analysis based tools to use, on the other hand it allows the tool developer to abstract from the actual implementation technique.},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and Orla Greevy and Michele Lanza},
	Booktitle = {2nd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2006)},
	Keywords = {scg-pub skip-doi snf07 jb07 fb06 reflectivity fromscgbib marcusdenker},
	Medium = {2},
	Pages = {32--38},
	Peerreview = {yes},
	Title = {Higher Abstractions for Dynamic Analysis},
	Url = {http://rmod.inria.fr/archives/workshops/Denk06c-PCODA06-HigherAbstractions.pdf},
  Year = {2006}}

@inproceedings{Denk07a,
	Abstract = {Over the last few years, we actively participated in the maintenance and evolution of Squeak, an open-source Smalltalk. The community is constantly faced with the problem of enabling changes while at the same time preserving compatibility. In this paper we describe the current situation, the problems that faced the community and we outline the solutions that have been put in place. We also identify some areas where problems continue to exist and propose these as potential problems to addressed by the research community.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and St\'ephane Ducasse},
	Booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
	Doi = {10.1016/j.entcs.2006.08.003},
	Inria = {hors},
	Issn = {1571-0661},
	Keywords = {scg07 stefPub scg-pub snf06 recast06 jb07 marcusdenker kzEvolution},
	Medium = {2},
	Month = jan,
	Pages = {81--91},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Series = {Electronic Notes in Theoretical Computer Science},
	Title = {Software Evolution from the Field: an Experience Report from the {Squeak} Maintainers},
	Url = {http://rmod.inria.fr/archives/workshops/Denk07a-Ercim06-EvolutionSqueak.pdf},
	Volume = {166},
  Year = {2007}}

@inproceedings{Denk07b,
	Abstract = {Reflection has proved to be a powerful feature to support the design of development environments and to extend languages. However, the granularity of structural reflection stops at the method level.  This is a problem since without sub-method reflection developers have to duplicate efforts, for example to introduce transparently pluggable type-checkers or fine-grained profilers. In this paper we present Persephone, an efficient implementation of a sub-method meta-object protocol (MOP) based on AST annotations and dual methods (a compiled method and its meta-object) that reconcile AST expressiveness with bytecode execution. We validate the MOP by presenting TreeNurse, a method instrumentation framework and TypePlug, an optional, pluggable type system which is based on Persephone.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Marcus Denker and St\'ephane Ducasse and Adrian Lienhard and Philippe Marschall},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Inria = {hors},
	Issn = {1660-1769},
	Keywords = {skip-doi jot snf-bmcc reflectivity fromscgbib marcusdenker kzReflection},
	Medium = {2},
	Month = oct,
	Pages = {231--251},
	Peerreview = {yes},
	Publisher = {ETH},
	Selectif = {non},
	Title = {Sub-Method Reflection},
	Url = {http://rmod.inria.fr/archives/papers/Denk07b-TOOLS07-Submethod.pdf},
	Volume = {6/9},
  Year = {2007}}

@inproceedings{Denk07c,
	Abstract = {Real world software systems change continuously to meet new demands. Most programming languages and development environments, however, are more concerned with limiting the effects of change rather than enabling and exploiting change. Various techniques and technologies to exploit change have been developed over the years, but there exists no common support for these approaches. We propose Changeboxes as a general-purpose mechanism for encapsulating change as a first-class entity in a running software system. Changeboxes support multiple, concurrent and possibly inconsistent views of software artifacts within the same running system.  Since Changeboxes are first-class, they can be manipulated to control the scope of change in a running system.Furthermore, Changeboxes capture the semantics of change. Changeboxes can be used, for example, to encapsulate refactorings, or to replay or analyze the history of changes. In this paper we introduce Changeboxes by means of a prototype implementation. We illustrate the benefits that Changeboxes offer for evolving software systems, and we present the results of a preliminary performance evaluation that assesses the costs associated with Changeboxes while suggesting possible strategies for improvement.},
	Annote = {internationalconference},
	Author = {Marcus Denker and Tudor G\^irba and Adrian Lienhard and Oscar Nierstrasz and Lukas Renggli and Pascal Zumkehr},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352681},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08 girba cop-lit marcusdenker fromscgbib},
	Pages = {25--49},
	Peer = {yes},
	Publisher = {ACM Digital Library},
	Title = {Encapsulating and Exploiting Change with {Changeboxes}},
	Url = {http://rmod.inria.fr/archives/papers/Denk07c-ICDL07-Changeboxes.pdf},
  Year = {2007}}

@inproceedings{Denk07d,
	Abstract = {The dynamic analysis approach to feature identification describes a technique for capturing feature behavior and mapping it to source code.  Major drawbacks of this approach are (1) large amounts of data and (2) lack of support for sub-method elements. In this paper we propose to leverage sub-method reflection to identify and model features. We perform an on-the-fly analysis resulting in annotating the operations participating in a feature's behavior with meta-data.The primary advantage of our annotation approach is that we obtain a fine-grained level of granularity while at the same time eliminating the need to retain and analyze large traces for feature analysis.},
	Annote = {internationalworkshop},
	Author = {Marcus Denker and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 3rd International Workshop on Program Comprehension through Dynamic Analysis (PCODA 2007)},
	Issn = {1872-5392},
	Keywords = {scg07 scg-pub skip-doi snf08 jb08 reflectivity fromscgbib marcusdenker},
	Medium = {2},
	Pages = {29--33},
	Peerreview = {yes},
	Publisher = {Technische Universiteit Delft},
	Title = {Supporting Feature Analysis with Runtime Annotations},
	Url = {http://rmod.inria.fr/archives/workshops/Denk07d-PCODA07-FeatureAnnotation.pdf},
  Year = {2007}}

@phdthesis{Denk08a,
	Abstract = {Computational reflection is a fundamental mechanism in object oriented languages. Reflection has proved useful in many contexts, such as in the design of development environments, language extension, and the dynamic, unanticipated adaptation of running systems We identify three problems with the current approach to reflection in object oriented languages: partial behavioral reflection needs to be anticipated, structural reflection is limited to the granularity of a method, and behavioral reflection cannot be applied to the whole system. To address these problems, we extend structural reflection to cover sub-method elements and present how sub-method structural reflection supports unanticipated partial behavioral reflection. We add the concept of context to represent meta-level execution and show how this allows behavioral reflection to be applied even to system classes. We describe an implementation in Smalltalk. Benchmarks validate the practicability of our approach. In addition, we present an experimental evaluation in which we show how the system is used for dynamic analysis. We realize dynamic feature analysis by annotating the sub-method structure of the system directly to denote features instead of recording full execution traces.},
	Author = {Marcus Denker},
	Keywords = {scg-phd reflectivity marcusdenker fromscgbib},
	Month = may,
	School = {University of Bern},
	Title = {Sub-method Structural and Behavioral Reflection},
	Type = {{PhD} thesis},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2008-Denker.pdf},
  Year = {2008}}

@inproceedings{Denk08b,
	Abstract = {Behavioral reflection is crucial to support for example functional upgrades, on-the-fly debugging, or monitoring critical applications. However the use of reflective features can lead to severe problems due to infinite metacall recursion even in simple cases. This is especially a problem when reflecting on core language features since there is a high chance that such features are used to implement the reflective behavior itself. In this paper we analyze the problem of infinite meta-object call recursion and solve it by providing a first class representation of meta-level execution: at any point in the execution of a system it can be determined if we are operating on a meta-level or base level so that we can prevent infinite recursion. We present how meta-level execution can be represented by a meta-context and how reflection becomes context-aware. Our solution makes it possible to freely apply behavioral reflection even on system classes: the meta-context brings stability to behavioral reflection. We validate the concept with a robust implementation and we present benchmarks.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
  Author = {Marcus Denker and Mathieu Suen and St\'ephane Ducasse},
	Booktitle = {Proceedings of TOOLS EUROPE 2008},
	Doi = {10.1007/978-3-540-69824-1\_13},
	Hal = {inria-00271286,p56w09p},
	Inria = {RMOD},
	Issn = {1865-1348},
	Keywords = {scg-pub jb08 fb08 snf08 reflectivity marcusdenker remoose kzReflection},
	Pages = {218--237},
	Peer = {yes},
	Publisher = {Springer-Verlag},
	Selectif = {non},
	Series = {LNBIP},
	Title = {The Meta in Meta-object Architectures},
	Url = {http://rmod.inria.fr/archives/papers/Denk08b-Tools08-MetaContext.pdf},
	Volume = {11},
  Year = {2008}}

@inproceedings{Denk10a,
	Abstract = {A feature represents a functional requirement fulfilled by a system. Since many maintenance tasks are expressed in terms of features, it is important to establish the correspondence between a feature and its implementation in source code.  Traditional approaches to establish this correspondence exercise features to generate a trace of runtime events, which is then processed by post-mortem analysis.  These approaches typically generate large amounts of data to analyze. Due to their static nature, these approaches do not support incremental and interactive analysis of features. We propose a radically different approach called live feature analysis, which provides a model at runtime of features. Our approach analyzes features on a running system and also makes it possible to grow feature representations by exercising different scenarios of the same feature, and identifies execution elements even to the sub-method level.  We describe how live feature analysis is implemented effectively by annotating structural representations of code based on abstract syntax trees. We illustrate our live analysis with a case study where we achieve a more complete feature representation by exercising and merging variants of feature behavior and demonstrate the efficiency or our technique with benchmarks.},
  Author = {Marcus Denker and Jorge Ressia and Orla Greevy and Oscar Nierstrasz},
	Booktitle = {Proceedings of MODELS 2010},
	Doi = {10.1007/978-3-642-16129-2\_11},
	Inria = {RMOD},
	Inriareport = {2010},
	Isbn = {978-3-642-16128-5},
	Keywords = {snf10 jb11 scg-pub lse-pub marcusdenker pharo},
	Misc = {Acceptance rate: 20.8\%},
	Month = oct,
	Pages = {138--152},
	Peer = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Modeling Features at Runtime},
	Url = {http://rmod.inria.fr/archives/papers/Denk10a-Models10-FeatureModels.pdf},
	Volume = {6395},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@incollection{Denk13a,
	Annote = {articlebook},
	Author = {Christian Denker and Norbert Hartl and Marcus Denker},
	Booktitle = {Mobile Apps - Rechtsfragen und rechtliche Rahmenbedingungen},
	Editor = {Christian Solmecke and Juergen Taeger and Thorsten Feldmann},
	Hal-Id = {hal-00865117},
	Isbn = {978-3-11-030503-6},
	Keywords = {lse-pub},
	Month = {aug},
	Pages = {1-8},
	Publisher = {De Gruyter},
	Title = {Kapitel 1: Apps},
	Year = {2013}}

@techreport{Denk14a,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
	Hal-Id = {hal-00936375},
	Inria = {RMOD},
	Inriareport = {2014},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2013 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Denk14a-RAWEB-RMOD-2013-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2014}}

@techreport{Denk15a,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
	Hal-Id = {hal-01247323},
	Inria = {RMOD},
	Inriareport = {2015},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2014 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Denk15a-RAWEB-RMOD-2014-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2015}}

@techreport{Denk16a,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {Marcus Denker and Nicolas Anquetil and Damien Cassou and St\'ephane Ducasse and Anne Etien and Damien Pollet},
	Hal-Id = {hal-01267026},
	Inria = {RMOD},
	Inriareport = {2016},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2015 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Denk16a-RAWEB-RMOD-2015-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2016}}

@inproceedings{Dery96a,
	Annote = {nationalconference},
	Author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
	Booktitle = {Actes d'Interfaces Hommes Machine (IHM'96)},
	Keywords = {stefPub kzDependency},
	Title = {Inhibition et resynchronisation des contr\^oleurs de dialogue},
	Year = {1996}}

@incollection{Dery96b,
	Annote = {articlebook},
	Author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
	Booktitle = {Ing\'eni\`erie Objet},
	Editor = {O. Mourad},
	Keywords = {stefPub kzDependency},
	Note = {ISBN: 2-7296-0642-4},
	Pages = {131--155},
	Publisher = {Inter-Editions},
	Title = {Objets et D\'ependances},
	Year = {1996}}

@techreport{Dery96c,
	Annote = {report notrefereed},
	Author = {Anne-Marie Dery and St\'ephane Ducasse and Mireille Fornarino},
	Institution = {Laboratoire I3S},
	Keywords = {stefPub kzDependency},
	Number = {I3S Lab, RR-96-06},
	Title = {A New Vision of Control in the {PAC} Model},
	Year = {1996}}

@article{Dias03a,
	Abstract = {Knowledge engineering emerged as a very promising area to help improve software engineering practice. One of its possible applications would be to help in solving the numerous problems that affect the software maintenance activity. Maintainers of legacy systems developed years ago with obsolete techniques and tools, and not documented, need all kinds of knowledge (application domain, programming skills, software engineering techniques, etc.) It is generally assumed that formalizing all this knowledge and recording it would be a worthwhile effort. However, research is still in a early stage and numerous questions need to be answered: What knowledge should be targeted first? Where to find this knowledge? etc. To answer these questions, one needs a precise understanding of what knowledge is at stake here. We, therefore, propose an ontology of the knowledge needed to perform software maintenance. This ontology would be most useful as a framework for future research in knowledge engineering for software maintenance.},
	Aeres = {ACLN},
	Annote = {internationaljournal},
	Author = {M\'{a}rcio G. B. Dias and Nicolas Anquetil and K\'{a}thia M. de Oliveira},
	Doi = {10.1049/ip-sen:20030581},
	Journal = {Journal of Universal Computer Science},
	Labo = {non},
	Number = {7},
	Pages = {641--658},
	Selectif = {non},
	Tagnicolasa = {knowledge},
	Title = {Organizing the Knowledge Used in Software Maintenance},
	Url = {http://www.jucs.org/jucs\_9\_7/organizing\_the\_knowledge\_used/Dias\_M\_G\_B.pdf},
	Volume = {9},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2003}}

@inproceedings{Dias03b,
	Aeres = {ACT},
	Annote = {internationalworkshop},
	Author = {M{\'a}rcio Greyck Batista Dias and Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira},
	Booktitle = {WM 2003: Professionelles Wissesmanagement - Erfahrungen und Visionen, Beitr{\"a}ge der 2. Konferenz Professionelles Wissensmanagement},
	Editor = {Ulrich Reimer and Andreas Abecker and Steffen Staab and Gerd Stumme},
	Isbn = {3-88579-357-1},
	Labo = {non},
	Pages = {65-72},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Organizing the Knowledge Used in Software Maintance},
	Volume = {28},
	X-Editorial-Board = {yes},
	X-International-Audience = {no},
	X-Pays = {BR},
	Year = {2003}}

@inproceedings{Dias11a,
	Abstract = {Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.},
	Address = {Edinburgh, Scotland},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
	Doi = {10.1145/2166929.2166930},
	Hal-Id = {inria-00614838},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter kzInfrastructure},
	Labo = {dans},
	Selectif = {non},
	Title = {Clustered Serialization with {Fuel}},
	Url = {http://rmod.inria.fr/archives/workshops/Dia11a-IWST11-Fuel.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,AR},
	X-Proceedings = {yes},
  Year = {2011}}

@inproceedings{Dias13a,
	Abstract = {Modern development environments handle information about the intent of the programmer: for example, they use abstract syntax trees for providing high-level code manipulation such as refactorings; nevertheless, they do not keep track of this information in a way that would simplify code sharing and change understanding. In most Smalltalk systems, source code modifications are immediately registered in a transaction log often called a ChangeSet. Such mechanism has proven reliability, but it has several limitations. In this paper we analyse such limitations and describe scenarios and requirements for tracking fine-grained code history with a semantic representation. We present Epicea, an early prototype implementation. We want to enrich code sharing with extra information from the IDE, which will help understanding the intention of the changes and let a new generation of tools act in consequence.},
	Annote = {internationalworkshop},
	Author = {Mart\'in Dias and Damien Cassou and St\'ephane Ducasse},
	Booktitle = {IWST'13: International Workshop on Smalltalk Technologies 2013},
	Hal-Id = {hal-00862626},
	Keywords = {pharo lse-pub kzMerging kzMeta},
	Selectif = {non},
	Title = {Representing Code History with Development Environment Events},
	Url = {http://rmod.inria.fr/archives/papers/Dias13a-IWST13-Epicea.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,AR},
	X-Proceedings = {yes},
  Year = {2013}}

@article{Dias14a,
	Annote = {internationaljournal},
  Author = {Mart\'in Dias and Martinez Peck, Mariano and St\'ephane Ducasse and Gabriela Ar\'evalo},
	Doi = {10.1002/spe.2136},
	Hal-Id = {hal-00703574},
	Impactfactor = {Impact Factor (2012) 0.519},
	Journal = {Journal of Software: Practice and Experience},
	Keywords = {lse-pub pharo kzInfrastructure},
	Pages = {433-453},
	Peerreview = {yes},
	Publisher = {John Wiley \& Sons, Ltd.},
	Title = {Fuel: A Fast General-Purpose Object Graph Serializer},
	Url = {http://rmod.inria.fr/archives/papers/Dias14a-Official-SPE-Fuel.pdf},
	Volume = {44},
  Year = {2014}}

@techreport{Dias14b,
	Annote = {technicalReport},
	Author = {Mart\'in Dias and Uquillas G\'{o}mez, Ver\'{o}nica and Damien Cassou and St\'ephane Ducasse},
	Hal-Id = {hal-01093496},
	Inria = {RMOD},
	Institution = {INRIA Lille},
	Keywords = {lse-pub},
	Title = {Software Integration Questions: A Quantitative Survey},
	Url = {https://hal.inria.fr/hal-01093496},
	Year = {2014}}

@inproceedings{Dias15a,
  Acceptnum    = {39},
  Accepttotal  = {144},
  Address      = {Montreal, Canada},
  Abstract     = {After working for some time, developers commit their code changes to a version control system. When doing
 so, they often bundle unrelated changes (e.g., bug fix and refactoring) in a single commit, thus creating a so-called tangled commit. Sharing tangled commits is problematic because it makes review, reversion, and integration of these commits harder and historical analyses of the project less reliable. Researchers have worked at untangling existing commits, i.e., finding which part of a commit relates to which task. In this paper, we contribute to this line of work in two ways: (1) A publicly available dataset of untangled code changes, created with the help of two developers who accurately split their code changes into self contained tasks over a period of four months; (2) a novel approach, EpiceaUntangler, to help developers share untangled commits (aka. atomic commits) by using fine-grained code change information. EpiceaUntangler is based and tested on the publicly available dataset, and further evaluated by deploying it to 7 developers, who used it for 2 weeks. We recorded a median success rate of 91% and average one of 75\%, in automatically creating clusters of untangled fine-grained code changes.},
  Annote       = {internationalconference},
  Author       = {Mart\'in Dias and Alberto Bacchelli and Georgios
                  Gousios and Damien Cassou and St{\'e}phane Ducasse},
  Booktitle    = {SANER'15: Proceedings of the 22nd International Conference on Software Analysis, Evolution, and Reengineering},
  Hal-Id       = {hal-01116225},
  Keywords     = {lse-pub pharo kzAnalysis kzChange kzMerging},
  Pages        = {341--350},
  Note         = {(candidate for IEEE Research Best Paper Award)},
  Title        = {Untangling Fine-Grained Code Changes},
  Url          = {https://hal.inria.fr/hal-01116225},
  PDF          = {http://rmod.inria.fr/archives/papers/Dias15a-Saner-FineGrainedChanges.pdf},
  Year         = {2015},
  pages        = {341--350}
}

@inproceedings{Dias15b,
	Abstract = {In software development, version control systems (VCS) provide branching and merging support tools. Such tools are popular among developers to concurrently change a codebase in separate lines and reconcile their changes automatically afterwards. However, two changes that are correct independently can introduce bugs when merged together. We call semantic merge conflicts this kind of bugs.
Change impact analysis (CIA) aims at estimating the effects of a change in a codebase. In this paper, we propose to detect semantic merge conflicts using CIA. On a merge, DELTAIMPACTFINDER analyzes and compares the impact of a change in its origin and destination branches. We call the difference between these two impacts the delta-impact. If the delta-impact is empty, then there is no indicator of a semantic merge conflict and the merge can continue automatically. Otherwise, the delta-impact contains what are the sources of possible conflicts.},
	Annote = {internationalworkshop},
	Author = {Mart\'in Dias and Guillermo Polito and Damien Cassou and St\'ephane Ducasse},
	Booktitle = {IWST'15: International Workshop on Smalltalk Technologies 2015},
	Keywords = {pharo lse-pub kzMerging kzMeta},
	Selectif = {non},
	Title = {DeltaImpactFinder: Assessing Semantic Merge Conflicts with Dependency Analysis},
	Inria = {RMOD},
	Institution = {INRIA Lille},
	Url = {https://hal.inria.fr/hal-01199035},
	pdf = {http://rmod.inria.fr/archives/papers/Dias15b-IWST-DeltaImpactFinder.pdf},
	Hal-Id = {hal-01199035},
	Year = {2015}}

@phdthesis{Dias15c,
	Author = {Mart\'in Dias},
	Hal-Id = {tel-01247696v1},
	Title = {Supporting Software Integration Activities with First-Class Code Changes},
	School = {University Lille 1 - Sciences et Technologies - France},
	abstract = {In this work, we study the activities involved in codebase integration, and propose approaches to support integration. First, we conducted an exploratory study to understand what are the most relevant problems in integration activities that have little tool support. We used such information as guidelines to propose:
Epicea, a first-class change model and associated IDE tools and  EpiceaUntangler, an approach to help developers share untangled commits (aka. atomic commits) by using fine-grained code change information gathered from the IDE through Epicea model and tools.},
	Month = {nov},
	Year = {2015},
	pdf = {http://rmod.inria.fr/archives/papers/Dias16a-IntegratorSurvey.pdf},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2015-Dias.pdf}}

@article{Dias16a,
  Annote = {internationaljournal},
  author = {Mart\'in Dias and St\'ephane Ducasse and Damien Cassou and Uquillas G\'{o}mez, Ver\'{o}nica},
  title = {Do Tools Support Code Integration? A Survey},
  journal = {Journal of Object Technology},
  keywords = {lse-pub kzMerging},
  volume = {16},
  number = {2},
  issn = {1660-1769},
  year = {2016},
  month = mar,
  pages = {2:1-20},
  doi = {10.5381/jot.2016.15.2.a2},
  pdf = {http://rmod.inria.fr/archives/phd/PhD-2015-Dias.pdf},
  url = {http://www.jot.fm/issues/issue_2016_02/article2.pdf}}

@inproceedings{Duca00a,
	Abstract = {Reengineering is an inherent aspect of modern software development, with its emphasis on iterative and incremental development. The reengineering pattern presented in this paper shows how you can support your understanding during system reengineering by linking your questions or information about the code in the code itself.},
	Annote = {internationalworkshop},
	Author = {St{\'e}phane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '2000},
	Keywords = {snf-none olit scg-pub skip-doi jb00 stefPub kzPattern},
	Pages = {209--217},
	Title = {Tie Code And Questions: a Reengineering Pattern},
	Url = {http://scg.unibe.ch/archive/papers/Duca00aTieCode.pdf},
  Year = {2000}}

@inproceedings{Duca00b,
	Abstract = {Surprising as it may seem, many of the early adopters of the object-oriented paradigm already face a number of problems typically encountered in large-scale legacy systems. The reengineering of those systems often poses problems because of the considerable size and complexity of such systems. In the context of the FAMOOS project we have developed a language independent environment called Moose which can deal with that complexity. This paper describes the architecture of Moose, the tools which have been developed around it and the industrial experiences we have obtained.},
	Annote = {internationalworkshop},
	Author = {Ducasse, St\'ephane and Lanza, Michele and Tichelaar, Sander},
	Booktitle = {Proceedings of the 2nd International Symposium on Constructing Software Engineering Tools},
	Keywords = {components scg-pub skip-doi repository oorp stefPub moose kzMoose},
	Month = jun,
	Series = {CoSET '00},
	Title = {Moose: an {Extensible} {Language}-{Independent} {Environment} for {Reengineering} {Object}-{Oriented} {Systems}},
	Url = {http://scg.unibe.ch/archive/papers/Duca00bMooseCoset.pdf},
  Year = {2000}}

@inproceedings{Duca00c,
	Abstract = {Conditionals -i.e., switch statements, nested ifs- that are used to simulate polymorphism hamper evolution and flexibility of applications. The reengineering patterns presented in this paper show you how to transform conditionals in object-oriented code to improve the flexibility of application.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of EuroPLoP '2000},
	Keywords = {snf-none skip-doi olit scg-pub jb00 stefPub kzPattern},
	Pages = {219--252},
	Title = {Transform Conditionals to Polymorphism},
	Url = {http://scg.unibe.ch/archive/papers/Duca00cTransform.pdf},
  Year = {2000}}

@inproceedings{Duca00d,
	Abstract = {Tuple spaces have turned out to be one of the most fundamental abstractions for coordinating communicating agents. At the same time, researchers continue to propose new variants of tuple spaces, since no one approach seems to be universally applicable to all problem domains. Some models offer a certain configurability, but existing approaches generally stop at afixed set of configuration options and static configuration at instantiation time. We argue that a more open approach is needed, and present OpenSpaces, an object-oriented framework that supports static configurability through subclassing across several dimensions, as well as dynamic configurability of policies through runtime composition. We introduce OpenSpaces by showing how it can be used to instantiate a typical application, and we present an overview of the framework, implemented in Smalltalk, detailing the various degrees of configurability.},
	Acceptnum = {18},
	Accepttotal = {52},
	Address = {Limassol, Cyprus},
	Annote = {internationalconference},
  Author = {St{\'e}phane Ducasse and Thomas Hofmann and Oscar Nierstrasz},
	Booktitle = {Coordination Languages and Models},
	Doi = {10.1007/3-540-45263-X\_1},
	Editor = {Ant{\'o}nio Porto and Gruia-Catalin Roman},
	Isbn = {978-3-540-41020-1},
	Keywords = {scg-pub coordination stefPub kzCoordination},
	Misc = {acceptance rate: 18/52 = 35\%},
	Month = sep,
	Pages = {1--19},
	Series = {LNCS},
	Title = {OpenSpaces: An Object-Oriented Framework For Reconfigurable Coordination Spaces},
	Url = {http://scg.unibe.ch/archive/papers/Duca00dOpenSpaces.pdf},
	Volume = {1906},
  Year = {2000}}

@inproceedings{Duca00f,
	Annote = {internationalworkshop},
	Author = {St{\'e}phane Ducasse and Michele Lanza and Lukas Steiger},
	Booktitle = {ECOOP 2000 International Workshop of Architecture Evolution},
	Keywords = {scg-pub skip-abstract skip-pdf skip-doi stefPub design-recovery moose kzHistory},
	Title = {Supporting Evolution Recovery: a Query-based Approach},
	Year = {2000}}


@techreport{Duca00g,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse and Michele Lanza and Oscar Nierstrasz and Matthias Rieger and Sander Tichelaar},
	Institution = {University of Bern},
	Keywords = {skip-abstract skip-pdf skip-doi stefPub kzOut},
	Title = {BEOC Analysis Report},
	Year = {2000}}

@article{Duca00x,
	Address = {13 rue du Jura, Paris 13},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Florence Ducasse},
	Journal = {Journal de l'association EPI Enseignement Public et Informatiques},
	Keywords = {scg-pub skip-abstract skip-doi stefPub kzTeaching},
	Month = sep,
	Number = 97,
	Title = {De l'enseignement de concepts informatiques},
	Url = {http://scg.unibe.ch/archive/papers/Duca00xExperienceEnseig.pdf},
	Volume = {4},
  Year = {2000}}

@booklet{Duca00z,
	Annote = {lectures},
	Author = {St\'ephane Ducasse and Florence Ducasse},
	Keywords = {scg-old scg-misc stefPub kzTeaching},
	Note = {Support de cours de Technologie, 150 pages, http://www.iam.unibe.ch/~ducasse/},
	Title = {Caro, Dis-moi c'est quoi programmer?},
	Url = {http://scg.unibe.ch/archive/papers/Duca00zCaroLecturesFr.pdf},
  Year = {2000}}

@article{Duca01a,
	Abstract = {The reverse engineering of object-oriented legacy systems presents a number
of problems typically encountered in large-scale legacy systems: the lack of overview and
the need to focus on interesting parts. To help in reverse engineering large
object-oriented legacy systems, we proposed a hybrid approach combining the immediate
appeal of visualisations with the scalability of metrics. However, our approach lacked of a
methodology that guides the reverse engineer. In this paper we present a first methodology
that we developed from our industrial experiments.},
	Annote = {nationaljournal},
	Author = {St\'ephane Ducasse and Michele Lanza},
	Journal = {Technique et science informatiques},
	Keywords = {scg-pub skip-doi jb01 snf02 stePub kzVisualization},
	Number = {4},
	Pages = {539--566},
	Title = {Towards a Methodology for the Understanding of Object-Oriented Systems},
	Url = {http://scg.unibe.ch/archive/papers/Duca01aTowardsAMethod.pdf},
	Volume = {20},
  Year = {2001}}

@article{Duca01b,
	Abstract = {This article presents the Moose Reengineering
                  Environment, a language-independent tool environment
                  to reverse engineer, i.e., understand, and
                  reengineer software systems, as well as the tools
                  which have been developed around it and the
                  experience, both academic and industrial, we have
                  obtained.},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Michele Lanza and Sander Tichelaar},
	Journal = {Smalltalk Chronicles},
	Keywords = {scg-pub skip-doi reengineering stefPub moose kzEvolution},
	Month = aug,
	Title = {The Moose Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca01bMoose.pdf http://www.smalltalkchronicles.net/edition3-2/Pages/moose.htm},
  Year = {2001}}

@techreport{Duca01c,
	Abstract = {Reengineering object-oriented applications is becoming a vital activity in today industry where the developer turnover drains the system oral memory out of the systems themselves and where applications should constantly evolve to meet new requirements.  This document summarizes the research effort led on reverse engineering and reengineering ob ject-oriented legacy systems. It includes (1) the definition of a suitable meta-model for reengineering, FAMIX. This meta-model, even if flat, supports both reverse engineering and code refac- toring analysis, (2) the presentation of a reengineering platform, MOOSE, (3) the evalution of software metrics for reengineer, (4) the definition of simple visual techniques to support large system understanding or finer grain code element, (5) the identification and cure sup- port for duplicated code, (6) the use of dynamic information to support composable views and collaboration extraction, and (7) the identification of reengineer patterns.  Keywords. Meta-Modeling, Language Independence, Reengineering, Reverse Engineering, Code Duplication, Reengineering Patterns, Program Traces, Dynamic Information, Program Visualization, Software Metrics, Refactorings, Interexchange Format, CODECRAWLER, FAMIX, MOOSE, FAMOOS, Smalltalk, Java, C\+\+.},
	Annote = {habilitation},
	Author = {Ducasse, St\'ephane},
	Institution = {Universit\'e Pierre et Marie Curie (Paris 6)},
	Keywords = {scg-pub skip-doi jb-none reengineering snf02 stefPub moose kzHDR},
	Month = sep,
	Note = {TR University of Bern, Institute of Computer Science and Applied Mathematics --- iam-03-008},
	Title = {Reengineering Object-Oriented Applications},
	Url = {http://scg.unibe.ch/archive/papers/Duca01cHab.pdf},
  Year = {2001}}

@article{Duca01s,
	Annote = {vulgarisation},
	Author = {Ducasse, St\'ephane},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = nov,
	Number = 37,
	Title = {Squeak: Introspection},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2001}}

@article{Duca01t,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = oct,
	Number = 36,
	Title = {Squeak: Classes},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2001}}

@article{Duca01u,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = sep,
	Number = 35,
	Title = {Squeak: Syntaxe par l'example},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2001}}

@article{Duca01v,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = jul,
	Number = 34,
	Title = {Squeak: Une syntaxe minimaliste},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2001}}

@article{Duca01w,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = jun,
	Number = 33,
	Title = {Squeak: Un smalltalk open-source d\'etonnant},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2001}}

@inproceedings{Duca02a,
	Abstract = {In this paper we stress the fact that a language and an environment for teaching object-oriented programming should support the anthropomorphic metaphor promoted by the paradigm. We show that all the cultural aspects of Smalltalk, i.e., the vocabulary and the syntax support the object metaphor. In addition, we stress that the programming environment should also support the metaphor. We show that Smalltalk environments offer an important property we named liveness or object proximity that promotes the anthropomorphic perception of objects. By providing excerpt from our forth coming book, we show how Squeak with the Morphic framework reinforces this ability to make object into living entities.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Proceedings of the Ecoop'02 International Educator Symposium},
	Keywords = {stefPub scg-pub skip-doi kzTeaching},
	Title = {Supporting Objects as An Anthropomorphic View at Computation or Why {Smalltalk} for Teaching Objects?},
	Url = {http://scg.unibe.ch/archive/papers/Duca02aTeacherWorkshop.pdf},
  Year = {2002}}

@article{Duca02v,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = sep,
	Number = 46,
	Title = {Refactoring Browser et SmallLint},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2002}}

@article{Duca02w,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = jan,
	Number = 39,
	Title = {SUnit: Ces tests que souvent l'on deteste},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
	X-Scientific-Popularization = {oui},
  Year = {2002}}

@article{Duca03a,
	Abstract = {Although component-based software development (CBSD) has become mainstream for conventional applications, it has remained elusive for embedded applications due to non-functional constraints. The PECOS project has demonstrated that CBSD can also be applied to severely constrained embedded devices, with timing and memory requirements being taken into account.},
	Annote = {notrefereed},
  Author = {St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Cvs = {ErcimPecos},
	Journal = {ERCIM News},
	Keywords = {scg-pub skip-doi pecos stefPub kzLanguageDesign},
	Month = jan,
	Title = {Composing Embedded Real-Time Software Components: the {PECOS} Data-Centric Approach},
	Url = {http://www.ercim.org/publication/Ercim\_News/enw52/nierstrasz.html},
	Volume = {52},
	Year = {2003}}

@inproceedings{Duca03b,
	Abstract = {Current languages contain visibility mechanisms such as private, protected, or public to control who can see what. However, these visibility mechanisms are fixed once for all. Moreover, they do not solve all problems related to the visibility, and are typically of a static nature. In this position paper we present an open and uniform way of dealing with visibility and introduce surfaces: i.e., list of methods that control the way the behavior of an ob ject is accessible. We introduce two problems that other visibility mechanisms cannot solve, and show how surfaces can.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Keywords = {snf03 scg-pub skip-doi jb03 stefPub schaerli kzLanguageDesign},
	Month = jul,
	Title = {Open Surfaces for Controlled Visibility},
	Url = {http://scg.unibe.ch/archive/papers/Duca03bSurfaces.pdf},
  Year = {2003}}

@inproceedings{Duca03c,
	Abstract = {Array programming shines in its ability to express computations at a high-level of abstraction, allowing one to manipulate and query whole sets of data at once. This paper presents the OOPAL model that enhances object-oriented programming with array programming features. The goal of OOPAL is to determine a minimum set of modifications that must be made to the traditional object model in order to take advantage of the possibilities of array programming. It is based on a minimal extension of method invocation and the definition of a kernel of methods implementing the fundamental array programming operations. The model is validated in F-SCRIPT, a new scripting language.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Philippe Mougin},
	Booktitle = {Proceedings of the ECOOP '03 Workshop on Object-oriented Language Engineering for the Post-Java Era},
	Keywords = {snf03 scg-pub skip-doi jb03 stefPub kzLanguageDesign},
	Month = jul,
	Title = {Power to Collections: Generalizing Polymorphism by Unifying Array Programming and Object-Oriented Programming},
	Url = {http://scg.unibe.ch/archive/papers/Duca03cOOPALEcoop.pdf},
  Year = {2003}}

@article{Duca03d,
	Abstract = {Over the last decade many research groups and commercial companies have been developing reengineering environments. However, many design decisions such as support for multiple models, incremental loading of information, tool integration, entity grouping, and their impacts on the underlying meta-model and resulting environment have remained implicit. Based on the experience accumulated while developing the Moose reengineering environment and on a survey of reengineering environments, we present a design space defined by a set of criteria that makes explicit the different options and especially their dependencies and trade-offs. Using this design space, developers of future environments should have a better understanding of the problems they face and the impact of design choices.},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Sander Tichelaar},
	Doi = {10.1002/smr.279},
	Impactfactor = {5 Year ISI impact factor (2010) 1.523},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast04 jb04 stefPub moose kzMoose kzEvolution},
	Month = oct,
	Number = 5,
	Pages = {345--373},
	Title = {Dimensions of Reengineering Environment Infrastructures},
	Url = {http://scg.unibe.ch/archive/papers/Duca03dInfrastructures.pdf},
	Volume = {15},
  Year = {2003}}

@misc{Duca03e,
	Abstract = {SUnit is a minimal yet powerful framework that supports the creation of tests. In this article we start by discussing why we test, then we present an example with SUnit and we go deep into the SUnit implementation.},
	Author = {St\'ephane Ducasse},
	Keywords = {kzVulgarisation},
	Title = {{SUnit} Explained},
  Url = {http://www.iam.unibe.ch/~ducasse/Programmez/OnTheWeb/SUnitEnglish2.pdf}}

@article{Duca03w,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = may,
	Number = 53,
	Title = {Seaside: Des composants pour le web},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
  Year = {2003}}

@article{Duca03x,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = apr,
	Number = 52,
	Title = {Seaside: Des applications web complexes simplement...},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
  Year = {2003}}

@article{Duca03y,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = mar,
	Number = 51,
	Title = {Squeak: R\'eflexion pour Prototyper},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
  Year = {2003}}

@article{Duca03z,
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse},
	Journal = {Programmez! Le Magazine du D\'eveloppement},
	Keywords = {stefPub kzVulgarisation},
	Month = feb,
	Number = 50,
	Title = {Espionnage en Squeak},
	Url = {http://www.iam.unibe.ch/~ducasse/WebPages/Books.html},
	Volume = {1},
  Year = {2003}}

@inproceedings{Duca04a,
	Abstract = {Understanding the run-time behavior of object-oriented legacy systems is a complex task due to factors such as late binding and polymorphism.  Current approaches extract and use information from the complete execution trace of a system. The sheer size and complexity of such traces make their handling, storage, and analysis difficult. Current software systems which run almost non-stop do not permit such a full analysis. In this paper we present a lightweight approach based on the extraction of a condensed amount of information, e.g., measurements, that does not require a full trace. Using this condensed information, we propose a visualization approach which allows us to identify and understand certain aspects of the objects' lifetime such as their role played in the creation of other objects and the communication architecture they support.},
	Acceptnum = {33},
	Accepttotal = {62},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Michele Lanza and Roland Bertuli},
	Booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
	Doi = {10.1109/CSMR.2004.1281433},
	Keywords = {recast04 scg-pub stefPub jb04 moose kzVisualisation kzDynamicInformation},
	Misc = {acceptance rate: 33/62 = 52\%},
	Pages = {309--318},
	Publisher = {IEEE Computer Society Press},
	Title = {High-Level Polymetric Views of Condensed Run-Time Information},
	Url = {http://scg.unibe.ch/archive/papers/Duca04aRuntimePolymetricViews.pdf},
  Year = {2004}}

@inproceedings{Duca04b,
	Abstract = {Due to the size and the extreme complexity of legacy systems, it is nearly impossible to write from scratch tests before refactoring them. In addition object-oriented legacy systems present specific requirements to test them. Indeed late-binding allow subclasses to change fundamental aspects of the superclass code and in particular call flows.  Moreover Object-oriented programming promotes a distribution of the responsibilities to multiple entities leading to complex scenario to be tested.  In such a context one of the few trustable source of information is the execution of the application itself. Traditional forward engineering approaches such as unit testing do not really provide adequate solution to this problem. Therefore there is a need for a more expressive way of testing the execution of object-oriented applications. We propose to represent the trace of object-oriented applications as logic facts and express tests over the trace.  This way complex sequences of message exchanges, sequence matching, or expression of negative information are expressed in compact form. We validated our approach by implementing TestLog a prototype tool and testing the Moose reengineering environment and a meta-interpreter.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michael Freidig and Roel Wuyts},
	Booktitle = {Fifth International Workshop on Object-Oriented Reengineering (WOOR 2004)},
	Keywords = {scg-pub skip-doi recast04 evolution visualization test stefPub kzDynamicInformation},
	Title = {Logic and Trace-based Object-Oriented Application Testing},
	Url = {http://scg.unibe.ch/archive/papers/Duca04bTestLogicWoor04.pdf},
  Year = {2004}}

@techreport{Duca04d,
	Abstract = {Understanding packages is an important activity in the reengineering of large object-oriented systems.  The relationships between packages and their contained classes can affect the cost of modifying the system. The main problem of this task is to quickly grasp the structure of a package and how it interacts with the rest of the system. In this paper we present a top-down program comprehension strategy based on polymetric views, radar charts, and software metrics. We illustrate this approach on two applications and show how we can retrieve the important characteristics of packages.},
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
	Institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
	Keywords = {jb05 scg-pub skip-doi stefPub snf04 recast05 moose kzMetric},
	Number = {IAM-04-007},
	Title = {A Top-Down Program Comprehension Strategy for Packages},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Duca04dPackageVisualization.pdf},
  Year = {2004}}

@inproceedings{Duca04e,
	Abstract = {Developing web applications is difficult since (1) the client-server relationship is asymmetric: the server cannot update clients but only responds to client requests and (2) the navigation facilities of web browsers lead to a situation where servers cannot control the state of the clients.  Page-centric web application frameworks fail to offer adequate solutions to model control flow at a high-level of abstraction. Developers have to work manually around the shortcomings of the HTTP protocol. Some approaches offer better abstractions by composing an application out of components, however they still fail to offer modeling control flow at a high level. Continuation-based approaches solve this problem by providing the facilities to model a control flow over several pages with one piece of code. However combining multiple flows inside the same page is difficult. This article presents Seaside. Seaside is a framework which combines an object-oriented approach with a continuation-based one. A Seaside application is built out of components (i.e., objects) and the logic of the application benefits from the continuation-based program flow infrastructure.  Seaside offers a unique way to have multiple control flows on a page, one for each component. This enables the developer to write components that are highly reusable and that can be used to compose complex web applications with higher quality in less time.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
	Booktitle = {Proceedings of 12th International Smalltalk Conference (ISC'04)},
	Cvs = {seaside},
	Keywords = {scg-pub skip-doi stefPub seaside kzWeb},
	Misc = {Also Technical Report IAM-04-008},
	Month = sep,
	Pages = {231--257},
	Title = {Seaside --- a Multiple Control Flow Web Application Framework},
	Url = {http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf http://www.iam.unibe.ch/publikationen/techreports/2004/iam-04-008},
  Year = {2004}}

@inproceedings{Duca04f,
	Abstract = {The histories of software systems hold useful information when reasoning about the systems at hand or about general laws of software evolution. Yet, the approaches developed so far, do not rely on an explicit meta-model and do not facilitate the comparison of different evolutions. We argue for the need to define history as a first class entity and propose a meta-model centered around the notion of history. We show the usefulness of our a meta-model by discussing the different analysis it enables.},
	Address = {Amsterdam},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Jean-Marie Favre},
	Booktitle = {Proceedings Workshop on Software Evolution Through Transformation (SETra 2004)},
	Doi = {10.1016/j.entcs.2004.08.035},
	Keywords = {scg-pub evolution van stefPub recast05 girba hismo moose kzMeta},
	Pages = {75--86},
	Publisher = {Elsevier},
	Title = {Modeling Software Evolution by Treating History as a First Class Entity},
	Url = {http://scg.unibe.ch/archive/papers/Duca04fHismo.pdf},
  Year = {2004}}

@incollection{Duca05a,
	Abstract = {Software systems are complex and difficult to analyze. Reverse engineering is a complex analysis that usually involves combining different techniques and tools. Moreover, oftentimes the existing tools are not perfectly suitable for the task, and customization of existing tools, or development of new tools is required. Moose is an extensible reengineering environment designed to provide the necessary infrastructure for tool integration. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and advanced tool integration mechanism.},
	Address = {Milano},
	Aeres = {OS},
	Aeresstatus = {aeres08},
	Annote = {articlebook},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Michele Lanza and Serge Demeyer},
	Booktitle = {Tools for Software Maintenance and Reengineering},
	Inria = {hors},
	Isbn = {88-464-6396-X},
	Keywords = {moose scg-pub skip-doi jb05 recast05 stefPub jointERCIM girba kzMoose kzEvolution},
	Pages = {55--71},
	Publisher = {Franco Angeli},
	Series = {RCOST / Software Technology Series},
	Title = {Moose: a Collaborative and Extensible Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca05aMooseBookChapter.pdf},
  Year = {2005}}

@article{Duca05b,
	Abstract = {Understanding source code is an important task in the maintenance of software systems. Legacy systems are not only limited to procedural languages, but are also written in object-oriented languages. In such a context, understanding classes is a key activity as they are the cornerstone of the object-oriented paradigm and the primary abstraction from which applications are built. Such an understanding is however difficult to obtain because of reasons such as the presence of late binding and inheritance. A first level of class understanding consists of the understanding of its overall structure, the control flow among its methods, and the accesses on its attributes. We propose a novel xvisualization of classes called class blueprint that is based on a semantically enriched visualization of the internal structure of classes. This visualization allows a software engineer to build a first mental model of a class that he validates via opportunistic code-reading. Furthermore, we have identified visual patterns that represent recurrent situations and as such convey additional information to the viewer. The contributions of this article are the class blueprint, a novel visualization of the internal structure of classes, the identification of visual patterns, and the definition of a vocabulary based on these visual patterns. We have performed several case studies of which one is presented in depth, and validated the usefulness of the approach in a controlled experiment.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Michele Lanza},
	Doi = {10.1109/TSE.2005.14},
	Impactfactor = {5 Year ISI impact factor (2010) 4.865},
	Inria = {hors},
	Journal = {Transactions on Software Engineering (TSE)},
	Keywords = {scg-pub stefPub recast05 mooseCincom moose kzVisualization},
	Month = jan,
	Number = {1},
	Pages = {75--90},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Title = {The {Class} {Blueprint}: Visually Supporting the Understanding of Classes},
	Url = {http://scg.unibe.ch/archive/papers/Duca05bTSEClassBlueprint.pdf},
	Volume = {31},
  Year = {2005}}

@inproceedings{Duca05d,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of CHASE International Workshop 2005},
	Keywords = {stefPub jb05 kzEvolution},
	Title = {Being a Long-Living Software Mayor --- the SimCity Metaphor to Explain the Challenges Behind Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Duca05dChaseSimCity.pdf},
  Year = {2005}}

@inproceedings{Duca05e,
	Abstract = {Understanding sets of classes, or packages, is an important activity in the
development and reengineering of large object-oriented systems. Packages represent the
coarse-grained structure of an application. They are artefacts to deploy and structure
software, and therefore more than a simple generalization of classes. The relationships
between packages and their contained classes are key in the decomposition of an application
and its (re)-modularisation. However, it is difficult to quickly grasp the structure of a
package and to understand how a package interacts with the rest of the system. We tackle
this problem using butterfly visualizations, i.e. dedicated radar charts built from simple
package metrics based on a language-independent meta-model. We illustrate our approach on
two applications and show how we can retrieve the relevant characteristics of packages.},
	Acceptnum = {39},
	Accepttotal = {89},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Michele Lanza and Laura Ponisio},
	Booktitle = {Proceedings of the 11th IEEE International Software Metrics Symposium (METRICS'05)},
	Cvs = {AlchemistPackageMETRICS05},
	Doi = {10.1109/METRICS.2005.15},
	Inria = {hors},
	Keywords = {scg-pub stefPub moose recast06 kzMetric},
	Misc = {acceptance rate: 39/89 = 44\%},
	Pages = {70--77},
	Publisher = {IEEE Computer Society},
	Rate = {44\%},
	Secondurl = {http://rmod.inria.fr/archive/papers/Duca05ePackageVisualization.pdf},
	Selectif = {non},
	Title = {Butterflies: A Visual Approach to Characterize Packages},
	Url = {http://rmod.inria.fr/archives/papers/Duca05e-Metrics-Butterflies-Ponisio.pdf},
  Year = {2005}}

@inproceedings{Duca05f,
	Abstract = {Software systems are complex and difficult to analyze. Reengineering is a complex activity that usually involves combining different techniques and tools. Moose is an reengineering environment designed to provide the necessary infrastructure for building new tools and for integrating them. Moose centers on a language independent meta-model, and offers services like grouping, querying, navigation, and meta-descriptions. Several tools have been built on top of Moose dealing with different aspects of reengineering like: visualization, evolution analysis, semantic analysis, concept analysis or dynamic analysis.},
	Annote = {conference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of ESEC/FSE 2005},
	Cvs = {MooseDemoESEC05},
	Doi = {10.1145/1081706.1081723},
	Keywords = {scg-pub moose stefPub recast06 girba kzEvolution kzMoose},
	Month = sep,
	Note = {Tool demo},
	Pages = {99--102},
	Title = {{Moose}: an Agile Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Duca05fMooseDemo.pdf},
  Year = {2005}}

@article{Duca05g,
	Abstract = {In pure object-oriented languages, classes are objects, instances of other classes called metaclasses. In the same way as classes define the properties of their instances, metaclasses define the properties of classes. It is therefore very natural to wish to reuse class properties, utilizing them amongst several classes. However this introduced metaclass composition problems, i.e., code fragments applied to one class may break when used on another class due to the inheritance relationship between their respective metaclasses.  Numerous approaches have tried to solve metaclass composition problems, but they always resort to an ad-hoc manner of handling conflicting properties, alienating the meta-programmer. We propose a uniform approach that represents class properties as traits, groups of methods that act as a unit of reuse from which classes are composed. Like all the other classes in the system, metaclasses are composed out of traits. This solution supports the reuse of class properties, and their safe and automatic composition based on explicit conflict resolution. The paper discusses traits and our solution, shows concrete examples implemented in the Smalltalk environment Squeak, and compares our approach with existing models for composing class properties.},
	Aeres = {ACL},
	Aeresstastus = {2008},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Nathanael Sch{\"a}rli and Roel Wuyts},
	Doi = {10.1016/j.cl.2004.11.003},
	Impactfactor = {Impact factor (2009) 0.619},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub stefPub kzReflection},
	Month = dec,
	Number = {3-4},
	Pages = {143--164},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Uniform and Safe Metaclass Composition},
	Url = {http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf},
	Volume = {31},
  Year = {2005}}

@inproceedings{Duca05h,
	Abstract = {Wikis are often implemented using string-based approaches to parse and generate their pages. While such approaches work well for simple wikis, they hamper the customization and adaptability of wikis to the variety of end-users when more sophisticated needs are required (i.e., different output formats, user-interfaces, wiki managment, security policies, ...). In this paper we present SmallWiki, the second version of a fully object-oriented implementation of a wiki. SmallWiki is implemented with objects from the top to the bottom and it can be customized easily to accommodate new needs. In addition, SmallWiki is based on a powerful meta-description called Magritte that allows one to create user-interface elements declaratively.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Lukas Renggli and Roel Wuyts},
	Booktitle = {Proceedings ACM International Symposium on Wikis (WikiSym'05)},
	Cvs = {SmallWikiTwoOOPSLASymp2005},
	Doi = {10.1145/1104973.1104981},
	Inria = {hors},
	Keywords = {scg-pub snf-none stefPub kzOut},
	Pages = {75--82},
	Publisher = {ACM Computer Society},
	Selectif = {non},
	Title = {{SmallWiki} --- A Meta-Described Collaborative Content Management System},
	Url = {http://scg.unibe.ch/archive/papers/Duca05hSmallwikiWikiSymp05.pdf},
  Year = {2005}}

@inproceedings{Duca05i,
	Abstract = {Understanding classes and methods is a key activity in object-oriented programming, since classes represent the primary abstractions from which applications are built, while methods contain the actual program logic. The main problem of this task is to quickly grasp the purpose and inner structure of a class. To achieve this goal, one must be able to overview multiple methods at once. In this paper, we present microprints, pixel-based representations of methods enriched with semantical information. We present three specialized microprints each dealing with a specific aspect we want to understand of methods: (1) state access, (2) control flow, and (3) invocation relationship.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michele Lanza and Romain Robbes},
	Booktitle = {Proceedings of {VISSOFT} 2005 (3th IEEE International Workshop on Visualizing Software for Understanding)},
	Keywords = {scg-pub skip-doi stefPub recast06 kzVisualization},
	Month = sep,
	Title = {Multi-level Method Understanding Using {Microprints}},
	Url = {http://scg.unibe.ch/archive/papers/Duca05imicroprintsVissoft.pdf},
  Year = {2005}}

@book{Duca05j,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {book},
	Author = {St\'ephane Ducasse},
	Keywords = {stefPub scg-pub kzVulgarisation kzBook},
	Note = {ISBN: 1-59059-491-6},
	Publisher = {APress},
	Title = {Squeak: Learn Programming with Robots},
	X-Scientific-Popularization = {yes},
	Year = {2005}}

@misc{Duca05k,
	Aeres = {OV},
	Aeresstastus = {2008},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Hilaire Fernandes},
	Inria = {hors},
	Journal = {Linux Pratique},
	Keywords = {stefPub kzVulgarisation},
	Month = mar,
	Number = 89,
	Pages = {18--23},
	Selectif = {non},
	Title = {Squeak: un Smalltalk libre multim\'edia},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2005}}

@inproceedings{Duca06a,
	Abstract = {When reengineering legacy systems, it is crucial to assess if the legacy behavior has been preserved or how it changed due to the reengineering effort.  Ideally if a legacy system is covered by tests, running the tests on the new version can identify potential differences or discrepancies. However, writing tests for an unknown and large system is difficult due to the lack of internal knowledge. It is especially difficult to bring the system to an appropriate state. Our solution is based on the acknowledgment that one of the few trustable piece of information available when approaching a legacy system is the running system itself. Our approach reifies the execution traces and uses logic programming to express tests on them. Thereby it eliminates the need to programatically bring the system in a particular state, and handles the test-writer a high-level abstraction mechanism to query the trace. The resulting system, called TESTLOG, was used on several real-world case studies to validate our claims.},
	Acceptnum = {27},
	Accepttotal = {65},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Roel Wuyts},
	Booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
	Doi = {10.1109/CSMR.2006.37},
	Inria = {hors},
	Keywords = {scg-pub recast06 stefPub kzDynamicInformation},
	Medium = {2},
	Misc = {acceptance rate: 27/65 = 42 \%},
	Pages = {35--44},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society Press},
	Selectif = {non},
	Title = {Object-Oriented Legacy System Trace-based Logic Testing},
	Url = {http://scg.unibe.ch/archive/papers/Duca06aTestLogtestingCSMR.pdf},
  Year = {2006}}

@article{Duca06b,
	Abstract = {Inheritance is well-known and accepted as a mechanism for reuse in object-oriented languages.  Unfortunately, due to the coarse granularity of inheritance, it may be difficult to decompose an application into an optimal class hierarchy that maximizes software reuse. Existing schemes based on single inheritance, multiple inheritance, or mixins, all pose numerous problems for reuse. To overcome these problems we propose traits, pure units of reuse consisting only of methods. We develop a formal model of traits that establishes how traits can be composed, either to form other traits, or to form classes. We also outline an experimental validation in which we apply traits to refactor a non-trivial application into composable units.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Nathanael Sch{\"a}rli and Roel Wuyts and Andrew P. Black},
	Cvs = {TraitsTOPLAS2005},
	Doi = {10.1145/1119479.1119483},
	Impactfactor = {5-Year ISI impact factor (2010) 1.478},
	Inria = {hors},
	Issn = {0164-0925},
	Journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	Keywords = {scg-pub stefPub toplas traits schaerli kzTrait},
	Month = mar,
	Number = {2},
	Pages = {331--388},
	Secondurl = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Selectif = {oui},
	Title = {Traits: A Mechanism for fine-grained Reuse},
	Url = {http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf},
	Volume = {28},
  Year = {2006}}

@inproceedings{Duca06c,
	Abstract = {Understanding large software systems is a challenging task, and to support it many approaches have been developed. Often, the result of these approaches categorize existing entities into new groups or associates them with mutually exclusive properties. In this paper we present the Distribution Map as a generic technique to visualize and analyze this type of result. Our technique is based on the notion of focus, which shows whether a property is well-encapsulated or cross-cutting, and the notion of spread, which shows whether the property is present in several parts of the system.  We present a basic visualization and complement it with measurements that quantify focus and spread. To validate our technique we show evidence of applying it on the result sets of different analysis approaches. As a conclusion we propose that the Distribution Map technique should belong to any reverse engineering toolkit.},
	Acceptnum = {41},
	Accepttotal = {147},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn},
	Booktitle = {Proceedings of 22nd IEEE International Conference on Software Maintenance},
	Doi = {10.1109/ICSM.2006.22},
	Inria = {hors},
	Keywords = {scg-pub stefPub moose recast07 kzVisualization},
	Medium = {2},
	Misc = {acceptance rate: 41/147 = 28\%},
	Pages = {203--212},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {28\%},
	Selectif = {oui},
	Series = {ICSM'06},
	Title = {Distribution Map},
	Url = {http://scg.unibe.ch/archive/papers/Duca06cDistributionMap.pdf},
  Year = {2006}}

@inproceedings{Duca06d,
	Abstract = {Object-oriented meta-languages such as MOF or EMOF are often used to specify domain specific languages.  However, these meta-languages lack the ability to describe behavior or operational semantics. Several approaches used a subset of Java mixed with OCL as executable meta-languages. In this paper, we report our experience of using Smalltalk as an executable and integrated meta-language. We validated this approach in incrementally building over the last decade, Moose, a meta-described reengineering environment. The reflective capabilities of Smalltalk support a uniform way of letting the base developer focus on his tasks while at the same time allowing him to meta-describe his domain model. The advantage of our this approach is that the developer uses the same tools and environment},
	Address = {Berlin, Germany},
	Aeres = {ACT},
	Annote = {internationalconference},
  Author = {St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {International Conference on Model Driven Engineering Languages and Systems (Models/UML 2006)},
	Doi = {10.1007/11880240\_42},
	Inria = {hors},
	Isbn = {978-3-540-45772-5},
	Keywords = {scg-pub girba moose stefPub recast07 norex06 kzMeta},
	Medium = {2},
	Pages = {604--618},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Rate = {28\%},
	Selectif = {oui},
	Series = {LNCS},
	Title = {Using {Smalltalk} as a Reflective Executable Meta-Language},
	Url = {http://scg.unibe.ch/archive/papers/Duca06dMOOSEMODELS2006.pdf},
	Volume = {4199},
  Year = {2006}}

@misc{Duca06e,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Hilaire Fernandes},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = may,
	Number = 83,
	Pages = {18--23},
	Selectif = {non},
	Title = {La syntaxe Smalltalk par la pratique},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@misc{Duca06f,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Serge Stinckwich},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = sep,
	Number = 86,
	Selectif = {non},
	Title = {Seaside: d\'eveloppement d'applications web en Smalltalk},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@misc{Duca06g,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Serge Stinckwich},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = nov,
	Number = 88,
	Selectif = {non},
	Title = {Seaside: d\'evelopper des composants r\'eutilisables},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@article{Duca06h,
	Aeres = {OV},
	Annote = {vulgarisation },
	Author = {St\'ephane Ducasse and Serge Stinckwich},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = dec,
	Number = 89,
	Selectif = {non},
	Title = {Smalltalk: un mod\`ele pur objet},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@article{Duca06i,
	Abstract = {Although duplicated code is known to pose severe problems for software maintenance, it is difficult to identify in large systems. Many different techniques have been developed to detect software clones, some of which are very sophisticated, but are also expensive to implement and adapt.  Lightweight techniques based on simple string matching are easy to implement, but how effective are they? We present a simple stringbased approach which we have successfully applied to a number of different languages such COBOL, {Java}, C\+\+, Pascal, Python, Smalltalk, C and PDP-11 assembler. In each case the maximum time to adapt the approach to a new language was less than 45 minutes. In this article we investigate a number of simple variants of string-based clone detection that abstract away from common editing operations, and assess the quality of clone detection for very different case studies. Our results confirm that this inexpensive clone detection technique generally achieves high recall and acceptable precision. Over-zealous normalization of the code before comparison, however, can result in unacceptable numbers of false positives.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Oscar Nierstrasz and Matthias Rieger},
	Cvs = {DuplocJournalPaper},
	Doi = {10.1002/smr.317},
	Impactfactor = {5 Year ISI impact factor (2010) 1.523},
	Inria = {hors},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast06 jb06 stefPub duploc kzDuplication},
	Month = jan,
	Number = 1,
	Pages = {37--58},
	Selectif = {non},
	Title = {On the Effectiveness of Clone Detection by String Matching},
	Url = {http://scg.unibe.ch/archive/papers/Duca06iDuplocJSMEPaper.pdf},
	Volume = {18},
  Year = {2006}}

@article{Duca07a,
	Abstract = {Nowadays, many complex applications are built with a web browser as their main user interface. However, despite the increasing popularity of the web as an application platform, implementing and maintaining web applications still remains difficult and lags behind conventional desktop application development.  The underlying technologies such as HTTP for the interaction and XHTML/CSS for the presentation were originally built to display and link static documents. Unfortunately, most mainstream frameworks provide only little abstraction over the page-oriented structure imposed by those technologies. Inevitably, the goto-like manner of how pages are linked leads to spaghetti code and hampers reuse. In this article we present Seaside, a web application framework that provides an uniform and pure object-oriented view on web applications.  In this way, Seaside avoids the unwieldily goto-like style. Exploiting the reflective features of Smalltalk, Seaside reintroduces procedure call abstraction in the client-server context. Seaside's key concepts are: (i) a component architecture supporting multiple, simultaneously active control flows, (ii) a programmatic XHTML generation, and (iii) fully supported on-the-fly debugging, code-editing, and recompilation. In this article we discuss these key features of Seaside and explain how they are made possible by the dynamic nature and the reflective capabilities of Smalltalk.},
	Address = {Los Alamitos, CA, USA},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse and Adrian Lienhard and Lukas Renggli},
	Doi = {10.1109/MS.2007.144},
	Impactfactor = {5-year ISI impact factor (2010) 2.551},
	Inria = {hors},
	Issn = {0740-7459},
	Journal = {IEEE Software},
	Keywords = {scg-pub seaside kzWeb},
	Number = {5},
	Pages = {56--63},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Title = {Seaside: A Flexible Environment for Building Dynamic Web Applications},
	Url = {http://rmod.inria.fr/archives/papers/Duca07a-IEEESoftware-Seaside.pdf},
	Volume = {24},
  Year = {2007}}

@inproceedings{Duca07b,
	Abstract = {A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method m is composed with another trait defining a different method m then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present freezable traits, which provide an expressive composition mechanism to support unanticipated method composition conflicts.  Our solution introduces private trait methods and lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.},
	Acceptnum = {33},
	Accepttotal = {156},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {St\'ephane Ducasse and Roel Wuyts and Alexandre Bergel and Oscar Nierstrasz},
	Booktitle = {Proceedings of 22nd International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA'07)},
	Doi = {10.1145/1297027.1297040},
	Inria = {hors},
	Isbn = {978-1-59593-786-5},
	Keywords = {stefPub alexPub scg-pub kzTrait},
	Location = {Montreal, Quebec, Canada},
	Medium = {2},
	Misc = {Acceptance rate: 33/156=21\%},
	Month = oct,
	Pages = {171--190},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Rate = {21\%},
	Selectif = {oui},
	Title = {User-Changeable Visibility: Resolving Unanticipated Name Clashes in Traits},
	Url = {http://scg.unibe.ch/archive/papers/Duca07b-FreezableTrait.pdf},
  Year = {2007}}

@inproceedings{Duca07c,
	Abstract = {Large object-oriented applications are structured over large number of packages. Packages are important but complex structural entities that may be difficult to understand since they play different development roles (i.e., class containers, code ownership basic structure, architectural elements...). Maintainers of large applications face the problem of understanding how packages are structured in general and how they relate to each others. In this paper, we present a compact visualization, named Package Surface Blueprint, that qualifies the relationships that a package has with its neighbours. A Package Surface Blueprint represents packages around the notion of package surfaces: groups of relationships according to the packages they refer to. We present two specific views one stressing the references made by a package and another showing the inheritance structure of a package. We applied the visualization on two large case studies: ArgoUML and Squeak.},
	Acceptnum = {46},
	Accepttotal = {214},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference stefPub},
	Author = {St\'ephane Ducasse and Damien Pollet and Mathieu Suen and Hani Abdeen and Ilham Alloui},
	Booktitle = {ICSM'07: Proceedings of the IEEE International Conference on Software Maintenance},
	Inria = {hors},
	Keywords = {moose kzCycle kzVisualization},
	Misc = {acceptance rate: 46/214 = 21\%},
	Pages = {94--103},
	Rate = {21\%},
	Selectif = {oui},
	Title = {Package Surface Blueprints: Visually Supporting the Understanding of Package Relationships},
	Url = {http://scg.unibe.ch/archive/papers/Duca07cPackageBlueprintICSM2007.pdf},
  Year = {2007}}

@misc{Duca07o,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Serge Stinckwich},
	Inria = {RMOD},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub kzVulgarisation},
	Month = nov,
	Number = 99,
	Selectif = {non},
	Title = {R\'eflexion en Squeak},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2007}}

@misc{Duca07p,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Serge Stinckwich},
	Inria = {RMOD},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub kzVulgarisation},
	Month = apr,
	Number = 93,
	Selectif = {non},
	Title = {Introspection et m\'eta-manipulations en Squeak},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2007}}

@misc{Duca07y,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Hilaire Fernandes},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = mar,
	Number = 92,
	Pages = {18--23},
	Selectif = {non},
	Title = {Smalltalk et design patterns, un couple assorti},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2007}}

@misc{Duca07z,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Hilaire Fernandes},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = may,
	Number = 94,
	Pages = {18--23},
	Selectif = {non},
	Title = {Tests unitaires en Smalltalk},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2007}}

@article{Duca08a,
	Abstract = {No abstract},
	Aeres = {ACL},
	Annote = {internationaljournal cook-pub remoose1-pub},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Adrian Kuhn and Lukas Renggli},
	Doi = {10.1007/s10270-008-0081-4},
	Hal-Id = {hal-00746255},
	Impactfactor = {Impact Factor (2011) 1.061},
	Inria = {RMOD},
	Inriareport = {2009},
	Journal = {Journal of Software and Systems Modeling (SOSYM)},
	Keywords = {stefPub kzMeta},
	Labo = {dans},
	Month = feb,
	Number = {1},
	Pages = {5--19},
	Publisher = {Springer Verlag},
	Selectif = {oui},
	Title = {Meta-Environment and Executable Meta-Language using {Smalltalk}: an Experience Report},
	Url = {http://scg.unibe.ch/archive/drafts/Duca08a-Sosym-ExecutableMetaLanguage.pdf},
	Volume = {8},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CH},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Duca08b,
	Abstract = {The increasing amount of data available about software systems poses new challenges for re- and reverse engineering research, as the proposed approaches need to scale. In this context, concerns about meta-modeling and analysis techniques need to be augmented by technical concerns about how to reuse and how to build upon the efforts of previous research. Moose is an extensive infrastructure for reverse engineering evolved for over 10 years that promotes the reuse of engineering efforts in research. Moose accommodates various types of data modeled in the FAMIX family of meta-models. The goal of this half-day workshop is to strengthen the community of researchers and practitioners who are working in re- and reverse engineering, by providing a forum for building future research starting from Moose and FAMIX as shared infrastructure.},
	Annote = {workshop},
	Author = {St\'ephane Ducasse and Tudor G\^irba and Orla Greevy and Michele Lanza and Oscar Nierstrasz},
	Booktitle = {15th Working Conference on Software Maintenance and Reengineering (WCRE 2008)},
	Doi = {10.1109/WCRE.2008.51},
	Keywords = {scg08 scg-pub greevy girba jb09 hasler08 moose stefPub kzFeature kzDynamicInformation},
	Month = oct,
	Pages = {343--344},
	Peerreview = {yes},
	Title = {Workshop on {FAMIX} and {Moose} in Software Reengineering ({FAMOOSr} 2008)},
	Url = {http://scg.unibe.ch/archive/papers/Duca08bFAMOOSr2008.pdf},
  Year = {2008}}

@inproceedings{Duca09a,
	Abstract = {Single inheritance often forces developers to
                  duplicate code and logic. This widely recognized
                  situation affects both business code and tests. In a
                  large and complex application whose classes
                  implement many groups of methods (protocols),
                  duplication may also follow the application's
                  idiosyncrasies, making it difficult to specify,
                  maintain, and reuse tests. The research questions we
                  faced are (i) how can we reuse test specifications
                  across and within complex inheritance hierarchies,
                  especially in presence of orthogonal protocols; (ii)
                  how can we test interface behavior in a modular way;
                  (iii) how far can we reuse and parametrize
                  composable tests. In this paper, we compose tests
                  out of separately specified behavioral units of
                  reuse ---traits. We propose test traits, where: (i)
                  specific test cases are composed from independent
                  specifications; (ii) executable behavior
                  specifications may be reused orthogonally to the
                  class hierarchy under test; (iii) test fixtures are
                  external to the test specifications, thus are easier
                  to specialize. Traits have been successfully applied
                  to test two large and critical class libraries in
                  Pharo, a new Smalltalk dialect based on Squeak, but
                  are applicable to other languages with traits.},
	Acceptnum = {17},
	Accepttotal = {67},
	Address = {Zurich, Switzerland},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Ducasse, St\'ephane and Pollet, Damien and Bergel, Alexandre and Cassou, Damien},
	Booktitle = {TOOLS'09: Proceedings of the 47th International Conference on Objects, Models, Components, Patterns},
	Coreranking = {B},
	Hal-Id = {inria-00403568},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {tools09 traits stefPub pharo pharo-pub kzTrait},
	Labo = {dans},
	Misc = {acceptance rate: 17/67 = 25\%},
	Month = jun,
	Pages = {252--271},
	Rate = {24\%},
	Selectif = {oui},
	Title = {Reusing and Composing Tests with Traits},
	Url = {http://rmod.inria.fr/archives/papers/Duca09a-Tools2009-TraitTests.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Duca09b,
	Abstract = {Traits are method groups that can be used to compose classes. They do not have a runtime existence and are conceptually folded into the classes that use them. Traits have been implemented in different languages. While implementing them in Smalltalk, our first reflex was to take advantage of the fact that traits are not run-time entities: we optimized the implementation for space and hence shared methods between traits and classes. However, by doing so we broke the introspective API of Smalltalk. This paper illustrates a more general problem seen in all reflective systems: the implementation serves both as a model for execution and as the model that is exposed to the programmer. There is a conflict of interests between the information necessary for execution and the information the programmer is interested in. In addition, as soon as the implementation is exposed via reflection, we are not free to optimize. As the complete implementation is visible reflectively, there is no way to hide the optimizations. Few papers report errors and this is one of them. We report our experience facing the initial API mismatch, which has a significant impact on the system because the language is reflective (i.e., written in itself and causally connected). We present the new introspective API we put in place.},
	Address = {Brest, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Ducasse, St\'ephane and Denker, Marcus and Lienhard, Adrian},
	Booktitle = {Proceedings of the International Workshop on Smalltalk Technologies},
	Doi = {10.1145/1735935.1735949},
	Hal-Id = {hal-00746130},
	Inria = {RMOD},
	Isbn = {978-1-60558-899-5},
	Keywords = {stefPub internationalworkshop lse-pub pharo pharo-pub kzTrait},
	Labo = {dans},
	Location = {Brest, France},
	Month = {aug},
	Pages = {82--86},
	Publisher = {ACM},
	Selectif = {non},
	Series = {IWST'09},
	Title = {Evolving a Reflective Language},
	Url = {http://rmod.inria.fr/archives/workshops/Duca09b-IWST09-TraitMop.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {CL,CH},
	X-Proceedings = {yes},
  Year = {2009}}

@article{Duca09c,
	Abstract = {To maintain and understand large applications, it is crucial to know their
architecture. The first problem is that unlike classes and packages, architecture is not
explicitly represented in the code. The second problem is that successful applications
evolve over time, so their architecture inevitably drifts. Reconstructing the architecture
and checking whether it is still valid is therefore an important aid. While there is a
plethora of approaches and techniques supporting architecture reconstruction, there is no
comprehensive state of the art and it is often difficult to compare the approaches. This
article presents a state of the art in software architecture reconstruction approaches.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Ducasse, St\'ephane and Pollet, Damien},
	Doi = {10.1109/TSE.2009.19},
	Hal-Id = {inria-00498407 / @4049m},
	Impactfactor = {5-year ISI impact factor (2010) 4.865},
	Inria = {RMOD},
	Inriareport = {2009},
	Journal = {IEEE Transactions on Software Engineering},
	Keywords = {lse-pub StefPub kzArchi},
	Labo = {dans},
	Month = jul,
	Number = 4,
	Pages = {573-591},
	Selectif = {oui},
	Title = {Software Architecture Reconstruction: A Process-Oriented Taxonomy},
	Url = {http://rmod.inria.fr/archives/papers/Duca09c-TSE-SOAArchitectureExtraction.pdf},
	Volume = {35},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2009}}

@techreport{Duca09t,
	Abstract = {Measuring applications is a challenge and one of the goal of the Squale project is to propose a sound quality model. Now presenting the results of such analysis is also a challenge since it is complex to output and present to the user for the following reasons: first a lot of data should be presented and at different audience. Second displaying information is one aspect another one is navigating the information. Finally it is important not to overwhelm the users with too much visualizations. This deliverable presents a state of the art in terms of software visualization approaches that are specifically designed to display metrics. In addition it sets up the context for the application of such visualization to practices.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Simon Denier and Fran\c{c}oise Balmas and Alexandre Bergel and Jannik Laval and Karine Mordal-Manet and Fabrice Bellingard},
	Hal-Id = {inria-00533618},
	Inria = {RMOD},
	Inriareport = {2009},
	Institution = {INRIA},
	Keywords = {squale-pub lse-pub deliverable12 kzMetric},
	Title = {Visualization of Practices and Metrics (Squale Deliverable 1.2)},
	Url = {http://rmod.inria.fr/archives/reports/Duca09t-Squale-deliverable12-MetricVisualization.pdf},
	X-Language = {EN},
  Year = {2009}}

@techreport{Duca09x,
	Abstract = {This is the yearly report of the RMOD team. A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
	Hal-Id = {hal-00639727},
	Inria = {RMOD},
	Inriareport = {2009},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2009 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Duca09x-RAWEB-RMOD-2009-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2009}}

@book{Duca10a,
	Abstract = {Seaside is the open source framework of choice for developing sophisticated and dynamic web applications. Seaside uses the power of objects to master the web. With Seaside web applications is as simple as building desktop applications. Seaside lets you build highly dynamic and interactive web applications. Seaside supports agile development through interactive debugging and unit testing.  Seaside is based on Smalltalk, a proven and robust language implemented by different vendors. Seaside is now available for all the major Smalltalk including Pharo, Squeak, GNU Smalltalk, Cincom Smalltalk, GemStone Smalltalk, and VA Smalltalk.},
	Aeres = {OS},
	Aeresstatus = {aeres12},
	Annote = {book},
	Author = {St\'ephane Ducasse and Lukas Renggli and C. David Shaffer and Rick Zaccone and Michael Davies},
	Hal-Id = {inria-00531503},
	Inria = {RMOD},
	Inriareport = {2010},
	Isbn = {978-3-9523341-1-9},
	Keywords = {skipdoi remoose2-pub pharo-pub pharo kzWeb},
	Labo = {dans},
	Publisher = {Square Bracket Associates},
	Selectif = {non},
	Title = {Dynamic Web Development with Seaside},
	Url = {http://book.seaside.st/book},
	X-Country = {CH,US,FR},
	X-International-Audience = {yes},
	X-Pays = {CH,US,FR},
	X-Scientific-Popularization = {yes},
  Year = {2010}}

@misc{Duca10t,
	Aeres = {OV},
	Aeresstatus = {aeres12},
	Annote = {vulgarisation},
	Author = {St\'ephane Ducasse and Alexandre Bergel},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub pharo kzVulgarisation},
	Month = nov,
	Number = 110,
	Selectif = {non},
	Title = {Exceptions en Smalltalk},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2008}}

@techreport{Duca10x,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
	Hal-Id = {hal-00639726},
	Inria = {RMOD},
	Inriareport = {2010},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2010 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Duca10x-RAWEB-RMOD-2010-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2010}}

@inproceedings{Duca11a,
	Abstract = {Automated random testing is a proven way to identify bugs and precondition violations, and this even in well tested libraries.
In the context of statically typed languages, current automated random testing tools heavily take advantage of static method declaration (argument types, thrown exceptions) to constrain input domains while testing and to identify errors. For such reason, automated random testing has not been investigated in the context of dynamically typed languages. In this paper we present the key challenges that have to be addressed to support automated testing in dynamic languages.},
	Address = {Edinburgh, Scotland},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Manuel Oriol and Alexandre Bergel},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2011)},
	Hal-Id = {inria-00614769},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzChecking},
	Labo = {dans},
	Selectif = {non},
	Title = {Challenges to support automated random testing for dynamically typed languages},
	Url = {http://rmod.inria.fr/archives/workshops/Duca11a-IWST11-RandomTesting},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,CL,GB},
	X-Proceedings = {yes},
  Year = {2011}}

@techreport{Duca11b,
	Abstract = {There is a plethora of software metrics \cite{Lore94a, Fent96a, Hend96a, Han00a, Lanz06a} and a large amount of research articles.  Still there is a lack for a serious and practically-oriented evaluation of metrics. Often metrics lack the property that the software reengineer or quality expert can easily understand the situation  summarized by the metrics.  In particular, since the exact notion of coupling and cohesion is complex, a particular focus on such point is important. In the first chapter of the present document, we present a list of software metrics, that are commonly used to measure object-oriented programs. In the second chapter we present our proposition for package metrics that capture package aspects such as information hiding and change impact limits.},
	Aeres = {COM},
	Aeresstatus = {aeres12},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Anquetil and Usman Bhatti and Cavalcante Hora, Andre},
	Hal-Id = {hal-00646878},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {Coupling Cohesion Packages Modularity Cutter Metric Cohesion Remodularisation StefPub lse-pub kzMetric},
	Labo = {dans},
	Selectif = {non},
	Tagnicolasa = {metric},
	Title = {Software Metrics for Package Remodularisation},
	Url = {http://rmod.inria.fr/archives/reports/Duca11b-Cutter-deliverable11-SoftwareMetrics.pdf},
	X-Country = {FR},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,BR},
	X-Proceedings = {no},
  Year = {2011}}

@techreport{Duca11c,
	Abstract = {Software systems exceeding a certain critical size easily become difficult to maintain and adapt. Requirements change, platforms change and if a system does not evolve properly, its usefulness will decay over time. This document presents MSE a robust, scalable, extensible interexchange format and FAMIX 3.0 a family of metamodels to represent source code.},
	Aeres = {COM},
	Aeresstatus = {aeres12},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Anquetil and Usman Bhatti and Cavalcante Hora, Andre and Jannik Laval and Tudor Girba},
	Hal-Id = {hal-00646884},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {Software Metrics; Software Modularization; Coupling; Cohesion; Packages; Modularity, Cutter kzMeta},
	Labo = {dans},
	Numpages = {40},
	Selectif = {non},
	Tagnicolasa = {analysis},
	Title = {{MSE and FAMIX 3.0: an Interexchange Format and Source Code Model Family}},
	Url = {http://rmod.inria.fr/archives/reports/Duca11c-Cutter-deliverable22-MSE-FAMIX30.pdf},
	X-Country = {FR},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,BR},
	X-Proceedings = {no},
  Year = {2011}}

@techreport{Duca11x,
	Abstract = {This is the yearly report of the RMOD team (http://rmod.inria.fr/). A good way to understand what we are doing.},
	Aeres = {AP},
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Anquetil and Marcus Denker and Damien Pollet},
	Hal-Id = {hal-00667079},
	Inria = {RMOD},
	Inriareport = {2011},
	Institution = {INRIA},
	Keywords = {rmod raweb lse-pub kzTeamReport},
	Title = {Project-Team RMoD (Analyses and Language Constructs for Object-Oriented Application Evolution) 2011 Activity Report},
	Url = {http://rmod.inria.fr/archives/reports/Duca11x-RAWEB-RMOD-2011-TeamActivityReport.pdf},
	X-Language = {EN},
  Year = {2011}}

@techreport{Duca12a,
	Abstract = {There is a plethora of research articles describing the deep semantics of JavaScript. Nevertheless, such articles are often difficult to grasp for readers not familiar with formal semantics. In this report, we propose a digest of the semantics of JavaScript centered around security concerns. This document proposes an overview of the JavaScript language and the misleading semantic points in its design. The first part of the document describes the main characteristics of the language itself. The second part presents how those characteristics can lead to problems. It finishes by showing some coding patterns to avoid certain traps and presents some ECMAScript 5 new features.},
	Annote = {technicalreport},
	Author = {Ducasse, St{\'e}phane and Petton, Nicolas and Polito, Guillermo and Cassou, Damien},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {JavaScript Dynamic Language Security Isolation Semantics Web HTTP lse-pub stefPub kzLanguageDesign},
	Title = {Semantics and Security Issues in JavaScript},
	Year = {2012}}

@techreport{Duca12z,
	Annote = {technicalreport},
	Author = {St\'ephane Ducasse and Nicolas Petton and Guillermo Polito and Damien Cassou},
	Institution = {Inria Lille-Nord Europe},
	Keywords = {kzLanguageDesign stefPub lse-pub},
	Month = dec,
	Note = {Deliverable Resilience FUI 12: 7.3.2.1 Failles de s\'ecurit\'e en JavaScript / JavaScript security issues},
	Title = {Semantics and Security Issues in JavaScript},
	Url = {http://rmod.inria.fr/archives/reports/Duca12z-deliverable-7321-FUI12.pdf},
  Year = {2012}}

@inproceedings{Duca16a,
	TITLE = {{Pragmas: Literal Messages as Powerful Method Annotations}},
	AUTHOR = {Ducasse, St{\'e}phane and Eliot Miranda and Alain Plantec},
	URL = {http://rmod.inria.fr/archives/papers/Duca16a-Pragmas-IWST.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01353592},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@mastersthesis{Duca93a,
	Annote = {dea},
	Author = {St\'ephane Ducasse},
	Keywords = {flo kzDependency},
	Month = sep,
	Note = {Equipe Janus, Supervis\'e par M. Blay-Fornarino et E. Gall\'esio, Team Janus, supervised by M. Blay-Fornarino and E. Gall\'esio},
	School = {Laboratoire I3S-Universit\'e de Nice-Sophia Antipolis},
	Title = {Protocole meta pour l'expression de relations dans un langage \`a objets},
	Year = {1993}}

@inproceedings{Duca93b,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Mireille Fornarino},
	Booktitle = {OOPSLA '93 International Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming},
	Keywords = {stefPub flo kzReflection kzDependency},
	Note = {Technical Report, University of Nice-Sophia Antipolis, I3S Lab, RR-94-62},
	Organization = {ACM},
	Title = {Protocol for Managing Dependencies between Objects by controlling Generic Function Invocation},
	Year = {1993}}

@inproceedings{Duca94a,
	Annote = {nationalconference},
	Author = {St\'ephane Ducasse and Mireille Fornarino},
	Booktitle = {Actes des Journ\'ees Francophones des Langages Applicatifs (JFLA'94)},
	Editor = {Pierre Cointe, Christian Queinnec et Bernard Serpette},
	Keywords = {stefPub flo kzDependency},
	Pages = {239--258},
	Title = {Protocole pour la gestion des d\'ependances entre objets gr\^ace au contr\^ole des fonctions g\'en\'eriques},
	Year = {1994}}

@techreport{Duca94b,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna},
	Institution = {Laboratoire I3S},
	Keywords = {stefPub flo kzDependency},
	Number = {I3S Lab, RR-94-60},
	Title = {Embedding behavioral relationships between objects using computational relection},
	Year = {1994}}

@inproceedings{Duca95b,
	Acceptnum = {27},
	Accepttotal = {167},
	Annote = {internationalconference topconference},
	Author = {St{\'e}phane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
	Booktitle = {Proceedings of 10th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '95)},
	Keywords = {stefPub flo kzReflection kzDependency kzReflection},
	Misc = {acceptance rate: 27/167 = 16\%},
	Month = oct,
	Pages = {265--280},
	Publisher = {ACM},
	Title = {A Reflective Model for First Class Dependencies},
	Url = {http://scg.unibe.ch/archive/papers/Duca95bAReflectiveModel.pdf},
  Year = {1995}}

@inproceedings{Duca95c,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse},
	Booktitle = {Proceedings of the International IJCAI'95 Workshop on Reflection and Meta-Level Architectures and their Applications in AI},
	Institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
	Keywords = {flo kzDependency},
	Note = {RR-95-12},
	Pages = {39--49},
	Title = {Inheritance Mechanism Reification by Means of First Class Object},
	Year = {1995}}

@techreport{Duca95d,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse and Mireille Fornarino and Anne-Marie Pinna-Dery},
	Institution = {University of Nice-Sophia Antipolis, Laboratoire I3S},
	Keywords = {stefPub flo kzDependency},
	Number = {RR-95-03},
	Title = {Control et PAC model},
	Year = {1995}}

@techreport{Duca96a,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse},
	Institution = {University of Nice Sophia-Antipolis, Laboratoire I3S},
	Keywords = {flo kzDependency},
	Note = {I3S Lab, RR-95-28},
	Title = {Reifying Inheritance in a Reflective Language},
	Url = {http://scg.unibe.ch/archive/papers/Duca96aInhReify.ps.gz},
  Year = {1996}}

@inproceedings{Duca96b,
	Abstract = {The FLO language integrates management of inter-object dependencies into the object oriented paradigms. In this paper, we focus on the use of reactive dependencies (links) in object-oriented knowledge representation. In particular, we present different meta-links (links between links) and show how the FLO links allow one to design some composition relationships.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Mireille Blay-Fornarino and Anne-Marie Pinna},
	Booktitle = {Proceedings of International Symposium on Methodologies for Intelligent Systems (ISMIS '96)},
	Doi = {10.1007/3-540-61286-6\_154},
	Keywords = {flo scg-old scg-pub stefPub kzDependency},
	Month = jun,
	Number = 1079,
	Pages = {295--304},
	Publisher = {Springer-Verlag},
	Series = {LNIA (Lectures Notes in Artificial Intelligence)},
	Title = {Object and Dependency Oriented Programming in FLO},
	Url = {http://scg.unibe.ch/archive/papers/Duca96bDependencyOP.pdf},
  Year = {1996}
	}

@phdthesis{Duca97a,
	Annote = {phdthesis},
	Author = {St\'ephane Ducasse},
	Keywords = {stefPub flo kzDependency},
	Month = jan,
	Note = {Th\`ese de l'Universit\'e de Nice-Sophia Antipolis},
	School = {Universit\'e de Nice-Sophia Antipolis},
	Title = {Int\'egration r\'eflexive de d\'ependances dans un mod\`ele \`a classes},
	Url = {http://scg.unibe.ch/archive/papers/Duca97aPhD.pdf},
  Year = {1997}}

@inproceedings{Duca97b,
	Abstract = {The decomposition of a software application into components and connectors at the design stage has been promoted as a way to describe and reason about complex software architectures. There is, however, surprisingly little language support for this decomposition at implementation level. Interaction relationships which are identified at design time are lost as they get spread out into the participating entities at implementation. In this paper, we propose first-class connectors in an object-oriented language as a first step towards making software architecture more explicit at implementation level. Our connectors are run-time entities which control the interaction of components and can express a rich repertoire of interaction relationships. We show how connectors can be reused and how they enhance the reuse of components.},
	Acceptnum = {19},
	Accepttotal = {197},
	Annote = {internationalconference topconference},
	Author = {St\'ephane Ducasse and Tamar Richner},
	Booktitle = {Proceedings of European Software Engineering Conference and Foundations on Software Engineering (ESEC/FSE'97)},
	Doi = {10.1007/3-540-63531-9\_32},
	Isbn = {978-3-540-63531-4},
	Keywords = {scg-pub flo stefPub kzDependency},
	Misc = {acceptance rate: 19/197 = 9\%},
	Pages = {483--500},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Executable Connectors: Towards Reusable Design Elements},
	Url = {http://rmod.inria.fr/archives/papers/Duca97bExecutableConnectors.pdf},
	Volume = {1301},
  Year = {1997}}

@inproceedings{Duca97c,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP '97 Workshop Reader)},
	Editor = {Jan Bosch and Stuart Mitchell},
	Keywords = {scg-pub flo stefPub kzDependency kzReflection},
	Month = jun,
	Pages = {96--99},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Message Passing Abstractions as Elementary Bricks for Design Pattern Implementation},
	Volume = {1357},
	Year = {1997}}

@inproceedings{Duca97d,
	Annote = {nationalconference},
	Author = {St\'ephane Ducasse},
	Booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'97)},
	Keywords = {scg-pub skip-doi skip-abstract stefPub flo kzDependency},
	Pages = {95--110},
	Title = {R\'eification de Sch\'emas de Conception: Une Exp\'erience},
	Url = {http://scg.unibe.ch/archive/papers/Duca97dReificationDP.ps.gz},
  Year = {1997}}

@article{Duca97e,
	Annote = {nationaljournal},
	Author = {St\'ephane Ducasse},
	Journal = {Revue des Sciences et Technologies de l'Information (RSTI) --- L'Objet},
	Keywords = {scg-pub skip-abstract skip-doi stefPub flo kzReflection},
	Number = {4},
	Pages = {355--377},
	Publisher = {Hermes, Paris},
	Title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Duca97eMessagePassing.pdf},
	Volume = {3},
  Year = {1997}}

@techreport{Duca97g,
	Annote = {report notrefereed},
	Author = {St\'ephane Ducasse},
	Institution = {University of Bern, Institut of Applied Mathematics and Computer Sciences},
	Keywords = {scg-pub skip-doi skip-pdf skip-abstract jb-none kzReflection},
	Note = {Extension version of Duca97e: Des techniques de contr\^ole de l'envoi de messages en Smalltalk},
	Number = {97-004},
	Title = {Des techniques de contr\^ole de l'envoi de messages en {Smalltalk}},
	Year = {1997}}

@inproceedings{Duca98b,
	Abstract = {A reengineering pattern describes how to go from an existing legacy solution to a new refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with design patterns and antipatterns. We then highlight the structure of a reengineering pattern and present two simple, related patterns for type-check elimination.},
	Address = {Konstanz, Germany},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Robb Nebbe and Tamar Richner},
	Booktitle = {Proceedings of the 4th European Conference on Pattern Languages of Programming and Computing, 1999},
	Editor = {Paul Dyson},
	Keywords = {scg-pub skip-doi pattern kzPattern stefPub},
	Month = jul,
	Publisher = {UVK Universit\"atsverlag Konstanz GmbH},
	Title = {Two Reengineering Patterns: Eliminating Type Checking},
	Url = {http://scg.unibe.ch/archive/papers/Duca98bTwoReengPatterns.pdf},
  Year = {1998}}

@inproceedings{Duca98c,
	Abstract = {Although coordination of multiple activities is a fundamental goal of object-oriented concurrent programming languages, there is only limited support for their specification and abstraction at the language level. This leads to a mismatch between conceptional designs, using high-level abstractions, and the implementation, using the low-level coordination constructs. Often coordination is hard-wired into the components they coordinate, which leads to evolution, maintenance and composibility problems. We propose a model called FLO/C that relies on the notion of connectors. A connector is an entity that enforces the coordination of the entities it coordinates. This model supports a clear separation between the coordinated active objects and their coordination.  An active object only defines specific domain information and a connector only defines coordination between a group of active objects (its participants). The coordination is abstractly defined refering to components in terms of the object interface. Coordination and coordinated entities are independant and can evolve separately.  Coordination can be composed and replaced easily.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Manuel G{\"u}nter},
	Booktitle = {Proceedings of the DEXA workshops},
	Keywords = {scg-pub skip-doi flo floc coordination stefPub kzDependency},
	Month = aug,
	Pages = {572--577},
	Publisher = {IEEE Computer Society Press},
	Title = {Coordination of Active Objects by Means of Explicit Connectors},
	Url = {http://scg.unibe.ch/archive/papers/Duca98cExplicitConnectors.pdf},
  Year = {1998}}

@misc{Duca98z,
	Annote = {workshopproceedings},
	Author = {St\'ephane Ducasse and Joachim Weisbrod},
	Booktitle = {Object-Oriented Technology (ECOOP'98 Workshop Reader)},
	Keywords = {skip-pdf scg-pub skip-abstract skip-doi jb-none stefPub kzPattern},
	Number = 1543,
	Pages = {72--96},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'98 Workshop on Experiences in Object-Oriented Re-Engineering},
	Year = {1998}}

@article{Duca99a,
	Abstract = {In a language like Smalltalk in which objects communicate only via message passing, message passing control is a fundamental tool for the analysis of object behavior (trace, spying) or for the definition of new semantics (asynchronous messages, proxy,...). Different techniques exist, from the well known approach based on the specialization of the doesNotUnderstand: method to the exploitation the method lookup algorithm done by the virtual machine. Until now no comparison between these techniques has been made. In this article we compare the different techniques taking into account the reflective aspects used, the scope, the limit and the cost of the control.},
	Annote = {internationaljournal},
	Author = {St\'ephane Ducasse},
	Impactfactor = {Impact factor 0.306},
	Journal = {Journal of Object-Oriented Programming (JOOP)},
	Keywords = {scg-pub skip-doi stefPub kzReflection},
	Month = jun,
	Number = {6},
	Pages = {39--44},
	Publisher = {SIGS Press},
	Title = {Evaluating Message Passing Control Techniques in {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Duca99aMsgPassingControl.pdf},
	Volume = {12},
  Year = {1999}}

@inproceedings{Duca99b,
	Abstract = {Code duplication is one of the factors that severely complicates the maintenance and evolution of large software systems. Good tools for detecting duplicated code are scarce because of the large amount of data to be checked, because duplicated code is not known a priori and because especially it requires parsing technology. In this paper we show that is possible to circumvent these complicating factors by applying a language independent and lightweigth approach, i.e. a tool that requires no parsing and a little learning and configuration time, yet is able to detect a significant amount of code duplication. We validate our approach on a number of case studies, involving five different implementation languages and ranging from 256 K up untill 26Mb of source code.},
	Acceptnum = {49},
	Accepttotal = {100},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Matthias Rieger and Serge Demeyer},
	Booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
	Doi = {10.1109/ICSM.1999.792593},
	Editor = {Hongji Yang and Lee White},
	Keywords = {scg-pub toBeChecked duploc stefPub moose kzDuplication},
	Misc = {acceptance rate: 49/100 = 49\%},
	Month = sep,
	Pages = {109--118},
	Publisher = {IEEE Computer Society},
	Title = {A Language Independent Approach for Detecting Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Duca99bCodeDuplication.pdf},
  Year = {1999}}

@inproceedings{Duca99c,
	Abstract = {In reengineering an object-oriented system we want to benefit from the expertise developed in earlier efforts. It is therefore essential to have a way to communicate expertise at different levels: from knowledge about how to approach a system to be reengineered, to knowledge about improving code by eliminating 'bad' style. In this paper we propose to use a pattern form to communicate knowledge about reengineering. A reengineering pattern connects an observable problem in the code to a reengineering goal: it describes the process of going from the existing legacy solution causing or aggravating the problem to a new refactored solution which meets the reengineering goal. It thus gives a method appropriate for a specific problem, rather than proposing a general methodology, and makes reference to the appropriate tools or techniques for obtaining the refactored solution. In this paper we discuss the role of reengineering patterns and contrast them with related kinds of patterns. We then highlight the form of reengineering patterns and present two simple patterns for type-check elimination.},
	Annote = {internationalconference},
	Author = {St\'ephane Ducasse and Tamar Richner and Robb Nebbe},
	Booktitle = {Proceedings of 6th Working Conference on Reverse Engineering (WCRE'99)},
	Doi = {10.1109/WCRE.1999.806956},
	Editor = {Fran\c{c}oise Balmas and Mike Blaha and Spencer Rugaber},
	Keywords = {olit famoos-papref scg-pub jb99 stefPub kzPattern},
	Month = oct,
	Pages = {157--168},
	Publisher = {IEEE Computer Society},
	Title = {Type-Check Elimination: Two Object-Oriented Reengineering Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Duca99cTypeCheckElim.pdf},
  Year = {1999}}

@inproceedings{Duca99d,
	Abstract = {Code duplication is an important problem in application maintenance. Tools exist that support code duplication detection. However, few of them propose a solution for the problem, i.e.  refactorings. We propose an approach that uses the information given by code duplication detection to guide the refactorings of OO applications.},
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Matthias Rieger and Georges Golomingi},
	Booktitle = {Proceedings of the ECOOP '99 Workshop on Experiences in Object-Oriented Re-Engineering},
	Editor = {St\'ephane Ducasse and Oliver Ciupke},
	Keywords = {olit famoos-papref scg-pub skip-doi jb99 stefPub kzDuplication},
	Month = jun,
	Note = {FZI-Report 2-6-6/99},
	Publisher = {Forschungszentrum Informatik, Karlsruhe},
	Title = {Tool Support for Refactoring Duplicated {OO} Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
  Year = {1999}}

@inproceedings{Duca99s,
	Annote = {internationalworkshop},
	Author = {St\'ephane Ducasse and Michele Lanza and Serge Demeyer},
	Booktitle = {Object-Oriented Technology (ECOOP'99 Workshop Reader)},
	Keywords = {scg-pub snf-none skip-pdf jb-skip skip-abstract skip-doi kzVisualization},
	Number = {1743},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Reverse Engineering based on Metrics and Program Visualization},
	Year = {1999}}

@inproceedings{Dure13a,
	Annote = {internationalconference},
	Author = {Durelli, Rafael S. and Santib{\'a}{\~n}ez, Daniel S.M. and Anquetil, Nicolas and Delamaro, M{\'a}rcio E. and de Camargo, Valter Vieira},
	Booktitle = {Proceedings of the 28th Annual ACM Symposium on Applied Computing},
	Misc = {Acceptance rate: 255/1063 = 24\%},
	Organization = {ACM},
	Pages = {1080--1087},
	Tagnicolasa = {analysis},
        annote = {internationalconference},
	Title = {A systematic review on mining techniques for crosscutting concerns},
	Year = {2013}}

@inproceedings{Dure14a,
  author={Durelli, Rafael S. and Santib{\'a}{\~n}ez, Daniel S.M. and Marinho, B. and Honda, R. and Delamaro, M{\'a}rcio E. and Anquetil, Nicolas and de Camargo, Valter Vieira},
  booktitle={Information Reuse and Integration (IRI), 2014 IEEE 15th International Conference on},
  title={A mapping study on architecture-driven modernization},
  year={2014},
  month={aug},
  pages={577-584},
  language = {English},
  Publisher = {IEEE},
  Tagnicolasa = {architecture},
  annote = {internationalconference},
  doi={10.1109/IRI.2014.7051941}
}

@article{Etie15a,
	Author = {Etien, Anne and Muller, Alexis and Legrand, Thomas and Paige, Richard F.},
	Doi = {10.1007/s10270-013-0379-8},
	issn={1619-1374},
	Journal = {Software \& Systems Modeling},
	Hal-Id = {hal-01354324},
	annote = {internationaljournal},
	Keywords = {Model transformation; Reusable transformation; Transformation chaining},
	Language = {English},
	volume={14},
        number={3},
        pages={1189--1213},
	Publisher = {Springer},
	Title = {Localized model transformations for building large-scale transformations},
  Year = {2015}}

@techreport{Etien16b,
  author = 	 {Anne Etien},
  title = 	 {HDR - Supporting Software Evolution in the Organizations},
  institution = {{Universit{\'e} des Sciences et Technologie de Lille - Lille I}},
  Hal-Id = {tel-01352817},
  year = 	 {2016},
  month = 	 {jun},
  annote = 	 {habilitation}
}

@techreport{Fabr10a,
	Annote = {technicalReport notrefereed},
	Author = {Johan Fabry and Andy Kellens and St\'ephane Ducasse},
	Institution = {University of Chile},
	Keywords = {kzVisualization kzAspect},
	Month = apr,
	Title = {AspectMaps: A Scalable Visualization of Join Point Shadows},
	Type = {TR/DCC-2010-2},
	Year = {2010}}

@inproceedings{Fabr11a,
	Abstract = {When using Aspect-Oriented Programming, it is sometimes difficult to determine at which join point an aspect executes. Similarly, when considering one join point, knowing which aspects will execute there and in what order is non- trivial. This makes it difficult to understand how the application will behave. A number of visualizations have been proposed that attempt to provide support for such program understanding. However, they neither scale up to large code bases nor scale down to understanding what happens at a single join point. In this paper, we present AspectMaps - a visualization that scales in both directions, thanks to a multi-level selective structural zoom. We show how the use of AspectMaps allows for program understanding of code with aspects, revealing both a wealth of information of what can happen at one particular join point as well as allowing to see the ``big picture'' on a larger code base. We demonstrate the usefulness of AspectMaps on an example and present the results of a small user study that shows that AspectMaps outperforms other aspect visualization tools.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 19th International Conference on Program Comprehension},
	Hal-Id = {inria-00614773},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {lse-pub plomo raweb2011 pharo kzVisualization kzAspect kzModule},
	Labo = {dans},
	Misc = {Acceptance rate: 18/76 = 23\%},
	Pages = {121-130},
	Publisher = {IEEE Computer Society Press},
	Rate = {23\%},
	Selectif = {non},
	Series = {ICPC'11},
	Title = {{AspectMaps}: A Scalable Visualization of Join Point Shadows},
	Url = {http://rmod.inria.fr/archives/papers/Fabr11a-ICPC2011-AspectMaps.pdf},
	Urldoi = {http://dx.doi.org/10.1109/ICPC.2011.11},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,BE,CL},
	X-Proceedings = {yes},
  Year = {2011}}

@article{Fabr14a,
	Abstract = {Integrated development environments (IDEs) have become the primary way to develop software. Besides just using the built-in features, it becomes more and more important to be able to extend the IDE with new features and extensions. Plugin architectures exist, but they show weaknesses related to unanticipated extensions and event handling. In this paper, we argue that a more general solution for extending IDEs is needed. We present and discuss a solution, motivated by a set of concrete examples: a domain specific aspect language for IDE events. In it, join points are events of interest that may trigger the advice in which the behavior of the IDE extension is called. We show how this allows for the development of IDE plugins and demonstrate the advantages over traditional publish/subscribe systems.},
	Annote = {internationaljournal},
	Author = {Johan Fabry and Romain Robbes and Marcus Denker},
	Date = {2014-02-01},
	Hal-Id = {inria-00936376},
	Journal = {Journal of Universal Computer Science},
	Keywords = {lse-pub plomo2 raweb2014 pharo},
	Labo = {dans},
	Month = {feb},
	Number = {2},
	Pages = {135--168},
	Selectif = {non},
	Title = {DIE: A Domain Specific Aspect Language for IDE Events},
	Url = {http://rmod.inria.fr/archives/papers/Fabr14a-DIE-JUCS.pdf},
	Volume = {20},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CL},
  Year = {2014}}

@article{Fabr14b,
	Annote = {internationaljournal},
	Author = {Johan Fabry and Andy Kellens and Simon Denier and St\'ephane Ducasse},
	Doi = {10.1016/j.scico.2012.02.007},
	Hal-Id = {hal-01086997},
	Inria = {RMOD},
	Issn = {0167-6423},
	Journal = {Science of Computer Programming},
	Keywords = {lse-pub plomo lse-pub stefPub kzVisualization},
	Note = {lse-pub stefPub kzVisualization},
	Pages = {6-22},
	Title = {AspectMaps: Extending Moose to visualize AOP software},
	Url = {http://rmod.inria.fr/archives/papers/Fabr14b-Official-SCP-AspectMaps.pdf},
	Volume = {79},
  Year = {2014}}

@inproceedings{Fall11a,
	Abstract = {Many design guidelines state that a software system architecture should avoid cycles between its packages. Yet such cycles appear again and again in many programs. We believe that the existing approaches for cycle detection are too coarse to assist the developers to remove cycles from their programs. In this paper, we describe an efficient algorithm that performs a fine-grained analysis of the cycles among the packages of an application. In addition, we define a metric to rank cycles by their level of undesirability, prioritizing the cycles that seems the more undesired by the developers. Our approach is validated on two large and mature software systems in Java and Smalltalk.},
	Address = {Zurich, Switzerland},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Jean R\'emi Falleri and Simon Denier and Jannik Laval and Philipe Vismara and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 49th International Conference on Objects, Models, Components, Patterns (TOOLS'11)},
	Hal-Id = {inria-00614770},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {lse-pub cutter raweb2011 pharo kzCycle kzRemodularisation},
	Labo = {dans},
	Month = jun,
	Selectif = {oui},
	Title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
	Url = {http://rmod.inria.fr/archives/papers/Fall11a-Tools2011-UndesirableCycles.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@misc{Fern05a,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {Hilaire Fernandes and St\'ephane Ducasse},
	Inria = {hors},
	Journal = {Linux Pratique},
	Keywords = {stefPub kzVulgarisation},
	Month = oct,
	Number = 31,
	Pages = {18--23},
	Selectif = {non},
	Title = {Squeak: mon premier programme},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2005}}

@misc{Fern06a,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {Hilaire Fernandes and St\'ephane Ducasse},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {stefPub kzVulgarisation},
	Month = apr,
	Number = 82,
	Selectif = {non},
	Title = {Smalltalk: Le pouvoir et la simplicit\'e du tout objet},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@misc{Fern06b,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {Hilaire Fernandes and Serge Stinckwich},
	Inria = {hors},
	Journal = {Linux Magazine},
	Month = jul,
	Number = 84,
	Selectif = {non},
	Title = {Environnement de d\'eveloppement Smalltalk},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2006}}

@inproceedings{Fern07a,
	Abstract = {Interactive geometry environments support the creation and exploitation of interactive geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with: i. the internal cognitive representation of the learner about the geometric domain and ii. the way a geometric sketch is used in a paper-pen environment. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of the interactive geometry environments. We think additional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed DR. GEO II, an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our first results.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Caron},
	Booktitle = {Proceedings of 5th International Conference on Creating, Connecting and Collaborating through Computing (C5 2007)},
	Doi = {10.1109/C5.2007.12},
	Hal-Id = {inria-00531636},
	Inria = {hors},
	Isbn = {0-7695-2806-6},
	Keywords = {stefPub kzTeaching},
	Pages = {153--162},
	Publisher = {IEEE Computer Society},
	Selectif = {non},
	Title = {{Dr Geo II}: Adding Interactivity Planes in Interactive Dynamic Geometry},
	Url = {http://rmod.inria.fr/archives/papers/Fern07a-C5-DrIIInterfactiveMultimodal.pdf},
  Year = {2007}}

@inproceedings{Fern07b,
	Abstract = {Interactive geometry environments support creation and exploitation of geometric sketches. However, such environments are often driven in a rigid manner, following a well specified construction path. This rigidity is not always compatible with the internal cognitive representation of the learner about the geometric domain. This rigidity is therefore a source of internal tension for the learner and it can reduce the pedagogical added value of these environments. We think addi- tional interactive planes to manipulate a geometric sketch differently can help the learner. We have developed an interactive geometry framework that is able to receive additional interactive planes such as a free sketching and a command-based one. We have experimented it in a junior high school class and we report here our results.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Author = {Hilaire Fernandes and St\'ephane Ducasse and Thibault Carron},
	Booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2007)},
	Hal-Id = {inria-00531641},
	Inria = {hors},
	Keywords = {stefPub kzTeaching},
	Month = jun,
	Pages = {383--388},
	Publisher = {\textsc{atief}, \textsc{inrp}},
	Selectif = {non},
	Title = {De l'importance des plans d'interaction dans la g\'eom\'etrie interactive},
	Url = {http://rmod.inria.fr/archives/papers/Fern07b-EIAH-Multimodal.pdf},
  Year = {2007}}

@misc{Fern07y,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {vulgarisation},
	Author = {Hilaire Fernandes and Serge Stinckwich},
	Inria = {hors},
	Journal = {Linux Magazine},
	Keywords = {kzTeaching},
	Month = jan,
	Number = 90,
	Selectif = {non},
	Title = {Morphic, les interfaces utilisateurs selon Squeak},
	Volume = {1},
	Year = {2007}}

@inproceedings{Fern08a,
	Abstract = {In primary schools, mathematics teachers use support tools to introduce new concepts. The objective of these tools is to reinforce a mental representation of the newly introduced concept. Tools can be physical objects or paper- pen based. We call these tools artefacts. In computer assisted environments, such artefacts are not always clearly present, those environments focus on the nature of the exercises (drills, quiz). To realise environments in closer relation to classroom teaching, we propose to analyse and categorise such artefacts: we used pedagogical literature and we extracted artefacts used in teaching multiplication. We present our infrastructure and a list of artefacts in the multiplication realm.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
	Booktitle = {Proceedings of 6th International Conference on Creating, Connecting and Collaborating through Computing (C5 2008)},
	Hal-Id = {inria-00531649},
	Inria = {RMOD},
	Isbn = {0-7695-3115-6},
	Keywords = {stefPub kzTeaching},
	Pages = {65--72},
	Publisher = {IEEE Computer Society},
	Selectif = {non},
	Title = {iSTOA: Artefacts for mathematical interactive learning execises kzTeaching},
	Url = {http://rmod.inria.fr/archives/papers/Fern08a-C5-istoa-exercises.pdf},
  Year = {2008}}

@inproceedings{Fern09a,
	Abstract = {Les EIAH sont souvent sp\'ecialis\'es dans un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Face \`a la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ?
Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est g\'en\'erique mais param\'etr\'e par un r\'eseau notionnel afin d'\^etre transposable \`a diff\'erents domaines d'enseignement.
Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche dans iSTOA.net.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Author = {Hilaire Fernandes and Thibault Carron and St\'ephane Ducasse},
	Booktitle = {Environnements Informatiques pour l'Apprentissage Humain (EIAH 2009)},
	Hal-Id = {inria-00531658},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {stefPub pharo pharo-pub kzTeaching},
	Month = jun,
	Publisher = {\textsc{atief}, \textsc{inrp}},
	Selectif = {non},
	Title = {Guidage macroscopique de l'apprentissage},
	Url = {http://rmod.inria.fr/archives/papers/Fern09a-EIAH2009-Guidage.pdf},
  Year = {2009}}

@phdthesis{Fern10a,
	Aeres = {AP},
	Annote = {PhD},
	Asbtract = {Les EIAH sont souvent sp\'ecialis\'es \`a un domaine bien pr\'ecis. Cela leur permet d'offrir des mod\'elisations fines du domaine et de l'apprenant. L'analyse alors produite \`a partir des traces est didactiquement tr\`es fine et sp\'ecifique au domaine en question. Elle permet de guider l'apprenant en cas de difficult\'e et de lui proposer des activit\'es de soutien. Cependant cette analyse est \'etroitement li\'ee aux domaines didactiques, et diff\'erente d'un domaine \`a un autre. Dans la diversit\'e des domaines enseign\'es, comment proposer un mod\`ele tenant compte de cette multitude et permettant une analyse de l'activit\'e de l'\'el\`eve et son guidage ? Nous proposons une analyse de l'activit\'e de l'\'el\`eve hors du champ didactique pour un guidage que nous nommons macroscopique, par opposition \`a une analyse didactique fine. Le guidage propos\'e est param\'etr\'e selon le domaine afin d'\^etre transposable. Notre approche s'appuie sur les r\'eseaux notionnels, les \'etayages p\'edagogiques, les traces d'objets et l'inf\'erence sur celles-ci. Leur utilisation conjointe permet la description du domaine, la mod\'elisation de l'apprenant et son pilotage par l'EIAH. Nous pr\'esentons cette approche implant\'ee dans iSTOA 1.},
	Author = {Hilaire Fernandes},
	Hal-Id = {tel-00498599},
	Inria = {RMOD},
	Institution = {INRIA},
	Keywords = {pharo pharo-pub},
	School = {Universit\'e de Lille},
	Title = {iStoa, mod\`ele notionnel de guidage macroscopique de l'apprentissage},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2010-Fernandes.pdf},
	X-Language = {FR},
  Year = {2010}}

@article{Gael02a,
	Annote = {notrefereed},
	Author = {Markus Gaelli and Marcus Denker},
	Comment = {bpb: Bundeszentrale f{\"u}r politische Bildung Deutschland},
	Journal = {bpb Online-Publikation: Freie Software im Unterricht},
	Keywords = {Squeak gaelli fromscgbib marcusdenker},
	Misc = {gaelli},
	Month = oct,
	Publisher = {bpb: Bundeszentrale f{\"u}r politische Bildung Deutschland},
	Title = {Freie Software im Unterricht: Squeak},
	Url = {http://rmod.inria.fr/archives/popular/Gael02a-BPB-Squeak.pdf},
  Year = {2002}}

@article{Gael04b,
	Abstract = {Es muss keine staubtrockene Angelegenheit von
                  Informatikstudenten sein, dem Computer neue Dinge
                  beizubringen. Squeak will Kindern nicht nur den
                  Umgang mit dem Rechner naeher bringen, sondern ihnen
                  auch als Mittel zur Entdeckung der realen Welt
                  dienen. Und fuer Erwachsene stellt es eine
                  Smalltalk-Umgebung dar, die auch spielerisch
                  erschlossen werden kann.},
	Annote = {notrefereed},
	Author = {Markus Gaelli and Marcus Denker},
	Journal = {c't magazin f\"ur computer technik},
	Keywords = {squeak smalltalk snf-none gaelli fromscgbib marcusdenker},
	Misc = {gaelli},
	Month = may,
	Pages = {216--221},
	Publisher = {Heise Verlag},
	Title = {Von kleinen und grossen Erfindern --- Squeak: Lernumgebung und Smalltalk-System f{\"u}r Kinder und Erwachsene},
	Url = {http://rmod.inria.fr/archives/popular/Gael04b-Ct-VonKleinenUndGrossenErfindern.pdf},
  Year = {2004}}

@inproceedings{Gael04c,
	Abstract = {Although unit testing is essential for programming, current languages only barely support the developer in composing unit tests into new ones or in navigating between unit tests and their corresponding methods under test. We have taken several Smalltalk programs and analyzed the relationships between unit tests and methods under test, and the re- lationships amongst unit tests.  First results indicate that most unit tests can be seen or at least decomposed into commands which focus on single methods, and that large portions of unit tests overlap each other. But these relationships between unit tests and methods under test are not reflected in current languages. We therefore first conceptually extend the meta-model of Smalltalk with one-method commands so that unit tests become both com- posable and navigable. Then we introduce a first lightweight implementation of this meta model using method comments to differentiate between the several test phases of existing XUnit test case methods.},
	Annote = {internationalworkshop},
	Author = {Markus Gaelli and Oscar Nierstrasz and St{\'e}phane Ducasse},
	Booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
	Cvs = {EgRDL2004},
	Keywords = {snf05 scg-pub skip-doi gaelli kzChecking},
	Month = oct,
	Title = {One-Method Commands: Linking Methods and Their Tests},
	Url = {http://scg.unibe.ch/archive/papers/Gael04cLinkingMethodsAndTests.pdf},
  Year = {2004}}

@book{Gens02a,
	Abstract = {This Handbook presents the PECOS approach for developing field device software. It has been written for the developer who wants to apply the method in a realistic setting. By following this tutorial the reader will get a good understanding of PECOS and will learn how to use PECOS to develop software for embedded real-time systems.},
	Annote = {notrefereed handbook},
	Author = {Thomas Genssler and Alexander Christoph and Benedikt Schulz and Michael Winter and Chris M. Stich and Christian Zeidler and Peter M\"uller and Andreas Stelter and Oscar Nierstrasz and St\'ephane Ducasse and Gabriela Ar{\'e}valo and Roel Wuyts and Peng Liang and Bastiaan Sch\"onhage and Reinier van den Born},
	Keywords = {olit scg-pub skip-doi jb02 pecos arevalo stefPub kzModule kzLanguageDesign},
	Month = sep,
	Publisher = {The Pecos Consortium},
	Title = {PECOS in a Nutshell},
	Year = {2002}}

@inproceedings{Girb04b,
	Abstract = {Knowing where to start reverse engineering a large software system, when no information other than the system`s source code itself is available, is a daunting task. Having the history of the code (i.e., the versions) could be of help if this would not imply analyzing a huge amount of data. In this paper we present an approach for identifying candidate classes for reverse engineering and reengineering efforts. Our solution is based on summarizing the changes in the evolution of object-oriented software systems by defining history measurements. Our approach, named Yesterday`s Weather, is an analysis based on the retrospective empirical observation that classes which changed the most in the recent past also suffer important changes in the near future. We apply this approach on two case studies and show how we can obtain an overview of the evolution of a system and pinpoint its classes that might change in the next versions.},
	Acceptnum = {38},
	Accepttotal = {122},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tudor G\^irba and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM'04)},
	Doi = {10.1109/ICSM.2004.1357788},
	Keywords = {scg-pub evolution metrics hismo stefPub moose recast05 jb05 kzHistory},
	Location = {Illinois, USA},
	Misc = {acceptance rate: 38/122 = 31\%},
	Month = sep,
	Pages = {40--49},
	Publisher = {IEEE Computer Society},
	Title = {{Yesterday's} {Weather}: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes},
	Url = {http://scg.unibe.ch/archive/papers/Girb04bYesterdayWeather.pdf},
  Year = {2004}}

@inproceedings{Girb04d,
	Abstract = {Software system need to change over time to cope
                  with the new requirements. Furthermore, due to
                  design decisions, the new requirements happen to
                  crosscut the system's structure. Understanding how
                  changes appear in the system can reveal hidden
                  dependencies between different parts of the system.
                  We propose to group entities that change together
                  according to a logical expression that specifies the
                  change condition. Furthermore, we can group entities
                  at different levels of abstraction (i.e., method,
                  class, package). Our approach is based on an
                  explicit history meta model that centers around the
                  notion of history and which enables the definition
                  of historical measurements which summarize the
                  changes. We apply our approach on two large case
                  studies and show how we can identify groups of
                  related entities and detect bad smells.},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and St\'ephane Ducasse and Radu Marinescu and Daniel Ra\c{t}iu},
	Booktitle = {Ninth IEEE Workshop on Empirical Studies of Software Maintenance},
	Keywords = {scg-pub skip-doi evolution van metrics smell hismo stefPub recast05 girba jb05 moose kzHistory},
	Title = {Identifying Entities That Change Together},
	Url = {http://scg.unibe.ch/archive/papers/Girb04dEntitiesChangeTogether.pdf},
  Year = {2004}}

@inproceedings{Girb05a,
	Abstract = {Analyzing historical information can show how a
                  software system evolved into its current state,
                  which parts of the system are stable and which have
                  changed more. However, historical analysis implies
                  processing a vast amount of information making the
                  interpretation of the results difficult. To address
                  this issue, we introduce the notion of the history
                  of source code artifacts as a first class entity and
                  define measurements which summarize the evolution of
                  such entities. We use these measurements to define
                  rules by which to detect different characteristics
                  of the evolution of class hierarchies. Furthermore,
                  we discuss the results we obtained by visualizing
                  them using a polymetric view. We apply our approach
                  on two large open source case studies and classify
                  their class hierarchies based on their history.},
	Acceptnum = {33},
	Accepttotal = {81},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Tudor G\^irba and Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering},
	Doi = {10.1109/CSMR.2005.15},
	Inria = {hors},
	Keywords = {scg-pub evolution visualization metrics van recast05 girba stefPub moose kzVisualization kzHistory},
	Misc = {acceptance rate: 33/81 = 41 \%},
	Pages = {2--11},
	Publisher = {IEEE Computer Society},
	Rate = {41\%},
	Selectif = {non},
	Series = {CSMR'05},
	Title = {Characterizing the Evolution of Class Hierarchies},
	Url = {http://scg.unibe.ch/archive/papers/Girb05aHierarchiesEvolution.pdf},
  Year = {2005}}

@inproceedings{Girb05b,
	Abstract = {Understanding how software systems evolve is useful
                  from different perspectives: reverse engineering,
                  empirical studies etc.. For an effective
                  understanding we need an explicit meta-model. We
                  introduce Hismo, a meta-model which is centered
                  around the notion of history and we show how we can
                  obtain it from a snapshot meta-model. Based on our
                  experience in developing the Hismo reverse
                  engineering system, we show how we can transform a
                  snapshot meta-model in a history metamodel.},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and Jean-Marie Favre and St\'ephane Ducasse},
	Booktitle = {Proceedings of 2nd International Workshop on Meta-Models and Schemas for Reverse Engineering (ATEM 2004)},
	Doi = {10.1016/j.entcs.2005.07.005},
	Keywords = {scg-pub evolution meta-modeling hismo van moose recast05 jointERCIM girba stefPub jb05 kzMeta kzHistory},
	Pages = {57--64},
	Title = {Using Meta-Model Transformation to Model Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb05bMetaModelTransATEM2004.pdf},
  Year = {2004}}

@inproceedings{Girb05c,
	Abstract = {As systems evolve their structure change in ways not
                  expected upfront. As time goes by, the knowledge of
                  the developers becomes more and more critical for
                  the process of understanding the system. That is,
                  when we want to understand a certain issue of the
                  system we ask the knowledgeable developers. Yet, in
                  large systems, not every developer is knowledgeable
                  in all the details of the system. Thus, we would
                  want to know which developer is knowledgeable in the
                  issue at hand. In this paper we make use of the
                  mapping between the changes and the author
                  identifiers (e.g., user names) provided by
                  versioning repositories. We first define a
                  measurement for the notion of code ownership. We use
                  this measurement to define the Ownership Map
                  visualization to understand when and how different
                  developers interacted in which way and in which part
                  of the system. We report the results we obtained on
                  several large systems.},
	Acceptnum = {13},
	Accepttotal = {54},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and Adrian Kuhn and Mauricio Seeberger and St\'ephane Ducasse},
	Booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2005)},
	Cvs = {ChroniaIWPSE2005},
	Doi = {10.1109/IWPSE.2005.21},
	Inria = {hors},
	Keywords = {scg-pub evolution visualization authors stefPub recast06 moose chronia kzHistory kzVisualization},
	Location = {Lisbon, Portugal},
	Misc = {acceptance rate: 13/54 = 24\%},
	Pages = {113--122},
	Publisher = {IEEE Computer Society Press},
	Rate = {24\%},
	Selectif = {oui},
	Title = {How Developers Drive Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb05cOwnershipMap.pdf},
  Year = {2005}}

@article{Girb06a,
	Abstract = {The histories of software systems hold useful
                  information when reasoning about the systems at hand
                  or when reasoning about general laws of software
                  evolution. Over the past 30 years more and more
                  research has been spent on understanding software
                  evolution. However, the approaches developed so far
                  do not rely on an explicit meta-model, and thus,
                  they make it difficult to reuse or compare their
                  results. We argue that there is a need for an
                  explicit meta-model for software evolution analysis.
                  We present a survey of the evolution analyses and
                  deduce a set of requirements that an evolution
                  meta-model should have. We define, Hismo, a
                  meta-model in which history is modeled as an
                  explicit entity. Hismo adds a time layer on top of
                  structural information, and provides a common
                  infrastructure for expressing and combining
                  evolution analyses and structural analyses. We
                  validate the usefulness of our a meta-model by
                  presenting how different analyses are expressed on
                  it.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Tudor G\^irba and St\'ephane Ducasse},
	Impactfactor = {5 Year ISI impact factor (2010) 1.523},
	Inria = {hors},
	Journal = {Journal of Software Maintenance: Research and Practice (JSME)},
	Keywords = {hasler07 scg-pub skip-doi recast06 stefPub mooseCincom moose kzMeta kzHistory meta-modeling hismo evolution},
	Pages = {207--236},
	Publisher = {John Wiley and Sons, Ltd.},
	Selectif = {non},
	Title = {Modeling History to Analyze Software Evolution},
	Url = {http://scg.unibe.ch/archive/papers/Girb06aHismo.pdf},
	Volume = {18},
  Year = {2006}}

@inproceedings{Girb07a,
	Abstract = {Software systems need to change over time to cope
                  with new requirements, and due to design decisions,
                  the changes happen to crosscut the system's
                  structure. Understanding how changes appear in the
                  system can reveal hidden dependencies between
                  different entities of the system. We propose the
                  usage of concept analysis to identify groups of
                  entities that change in the same way and in the same
                  time. We apply our approach at different levels of
                  abstraction (i.e., method, class, package) and we
                  detect fine grained changes (i.e., statements were
                  added in a class, but no method was added there).
                  Concept analysis is a technique that identifies
                  entities that have the same properties, but it
                  requires manual inspection due to the large number
                  of candidates it detects. We propose a heuristic
                  that dramatically eliminate the false positives. We
                  apply our approach on two case studies and we show
                  how we can identify hidden dependencies and detect
                  bad smells.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Tudor G\^irba and St\'ephane Ducasse and {A}drian {K}uhn and Radu Marinescu and Daniel Ra\c{t}iu},
	Booktitle = {Proceedings of International Workshop on Principles of Software Evolution (IWPSE 2007)},
	Doi = {10.1145/1294948.1294970},
	Inria = {hors},
	Isbn = {978-1-59593-722-3},
	Keywords = {scg07 scg-pub evolution fca girba jb08 metrics moose norex07 stefPub kzHistory},
	Medium = {2},
	Pages = {83--89},
	Peerreview = {yes},
	Publisher = {ACM Press},
	Selectif = {non},
	Title = {Using Concept Analysis to Detect Co-Change Patterns},
	Url = {http://scg.unibe.ch/archive/papers/Girb07aCoChangePatterns.pdf},
  Year = {2007}}

@inproceedings{Godo14a,
	Abstract = {Merging a change often leads to the question of knowing what are the dependencies to other changes that should be merged too to obtain a working system. This question also arises with code history trackers -- Code history trackers are tools that react to what the developer do by creating first-class objects that represent the change made to the system. In this paper, we evaluate the capacity of different code history trackers to represent, also as first-class objects, the dependencies between those changes. We also present a representation for dependencies that works with the event model of \emph{Epicea}, a fine-grained and incremental code history tracker.},
	Annote = {internationalworkshop},
	Author = {Lucas Godoy and Damien Cassou and St\'ephane Ducasse},
	Booktitle = {IWST'14: Proceedings of the  International Workshop on Smalltalk Technologies 2014},
	Keywords = {lse-pub pharo stefPub kzInfrastructure},
	Title = {Tracking dependencies between code changes: An incremental approach},
	Year = {2014}}

@misc{Gonz04a,
	Abstract = {This report covers the activities of the 2nd
                  workshop on "Object-Oriented Language Engineering
                  for the Post-Java Era". We describe the motivation
                  that led to the organisation of a second edition of
                  the workshop. Relevant organisational aspects are
                  mentioned. The main part of the report consists of a
                  summary of Dave Thomas's invited talk, and a recount
                  of the presentations by the authors of position
                  papers. Comments given along the way by the
                  participants are included. Finally, some pointers to
                  related work and events are given.},
	Annote = {workshopproceedings},
	Author = {Sebastian Gonzales and Wolgang Demeuter and Pascal Costanza and St\'ephane Ducasse and Richard Gabriel and Theo D'hondt},
	Booktitle = {Object-Oriented Technology (ECOOP'04 Workshop Reader)},
	Keywords = {scg-pub skip-doi jb04 stefPub recast04 kzEditor},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'03 Workshop on Object-Oriented Language Engineering in Post-Java Era},
	Url = {http://rmod.inria.fr/archive/reports/Gonz04a-oolepje04-report.pdf},
  Year = {2004}}

@inproceedings{Gonz09a,
	Abstract = {The emerging field of context-oriented programming
                  gives a predominant role to the execution context of
                  applications, and advocates the use of dedicated
                  mechanisms to allow the elegant expression of
                  behavioural adaptations to such context. With
                  suitable reflective facilities, language semantics
                  can be adapted to context by reusing the same
                  context-oriented mechanisms that allow base-level
                  adaptability. This kind of meta-level adaptability,
                  in which the computation model itself becomes
                  adaptable to context, gives rise to context-oriented
                  computational reflection. To explore this idea, we
                  set out to implement a simple software transactional
                  memory system that exploits meta-level adaptability
                  by regarding transactions as contexts, and adapting
                  fundamental system behaviour to such transactional
                  contexts. The implementation is succinct and
                  non-intrusive, giving us an indication of the power
                  lying at the crossroads of context-oriented
                  programming and computational reflection.},
	Address = {New York, NY, USA},
	Author = {Gonz\'{a}lez, Sebasti\'{a}n and Denker, Marcus and Mens, Kim},
	Booktitle = {COP '09: International Workshop on Context-Oriented Programming},
	Doi = {10.1145/1562112.1562115},
	Isbn = {978-1-60558-538-3},
	Keywords = {cop-lit gonzales ambience fromscgbib},
	Location = {Genova, Italy},
	Pages = {1--6},
	Publisher = {ACM},
	Title = {Transactional contexts: harnessing the power of context-oriented reflection},
	Url = {http://rmod.inria.fr/archives/workshops/Gonz09a-COP09-Context.pdf},
  Year = {2009}}

@inproceedings{Govi15a,
		TITLE = {{Reverse Engineering Tool Requirements for Real Time Embedded Systems}},
		AUTHOR = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St{\'e}phane},
		URL = {https://hal.inria.fr/hal-01187532},
		BOOKTITLE = {{SATToSE'15}},
		ADDRESS = {Mons, Belgium},
		ANNOTE = {internationalworkshop},
		aeresstatus= {aeres16},
		Note = {short paper},
		Aeres = {ACT},
		Inria = {RMOD},
		YEAR = {2015},
		MONTH = jul,
		KEYWORDS = {reverse engineering tool},
		PDF = {https://hal.inria.fr/hal-01187532/file/reverse-engineering-tool-requirements-for-real-time-embedded-systems.pdf},
		HAL-ID = {hal-01187532}
}

@inproceedings{Govi15b,
	TITLE = {{Measuring the progress of an Industrial Reverse Engineering Process}},
	AUTHOR = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St{\'e}phane},
	BOOKTITLE = {{BENEVOL'15}},
	ADDRESS = {Lille, France},
	ANNOTE = {internationalworkshop},
	aeresstatus= {aeres16},
	Aeres = {ACT},
	Inria = {RMOD},
	YEAR = {2015},
	MONTH = dec,
	KEYWORDS = {reverse engineering ; software process},
	HAL-ID = {hal-01353203}
}

@inproceedings{Govi16a,
	TITLE = {{Clustering Techniques for Conceptual Cluster}},
	AUTHOR = {Govin, Brice and Anquetil, Nicolas and Monegier Du Sorbier, Arnaud and Ducasse, St{\'e}phane},
	BOOKTITLE = {{IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	ANNOTE = {internationalworkshop},
	aeresstatus= {aeres16},
	Aeres = {ACT},
	Inria = {RMOD},
	YEAR = {2016},
	MONTH = aug,
	KEYWORDS = {pharo-pub ; lse-pub ; clustering ; conceptual clusters ; industrial project ; architecture migration ; pharo},
	HAL-ID = {hal-01353205}
}

@inproceedings{Govi16b,
 	TITLE = {{How Can We Help Software Rearchitecting Efforts ? Study of an Industrial Case}},
  	AUTHOR = {Govin, Brice and Anquetil, Nicolas and Etien, Anne and Monegier Du Sorbier, Arnaud and Ducasse, St{\'e}phane},
	BOOKTITLE = {{Proceedings of the International Conference on Software Maintenance and Evolution, (Industrial Track)}},
  	ADDRESS = {Raleigh, USA},
  	ANNOTE = {internationalconference},
  	Aeres = {ACT},
  	Inria = {RMOD},
  	YEAR = {2016},
  	MONTH = oct,
  	KEYWORDS = {lse-pub ; tool-supported process ; migration ; industrial case}
}

@inproceedings{Gree05a,
	Abstract = {Software developers are constantly required to
                  modify and adapt features of an application in
                  response to changing requirements. The problem is
                  that just by reading the source code, it is
                  difficult to determine how classes and methods
                  contribute to the runtime behavior of features.
                  Moreover, dependencies between system features are
                  not obvious, consequently software maintenance
                  operations often result in unintended side effects.
                  To tackle these problems, we propose a compact
                  feature-driven approach (\ie summarized trace
                  information) based on dynamic analysis to
                  characterize features and computational units of an
                  application. We extract execution traces to achieve
                  an explicit mapping between features and classes
                  using two complementary perspectives. We apply our
                  approach to two case studies and we report our
                  findings.},
	Acceptnum = {33},
	Accepttotal = {81},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and St\'ephane Ducasse},
	Booktitle = {Proceedings of 9th European Conference on Software Maintenance and Reengineering (CSMR'05)},
	Cvs = {TraceScraperRevEng},
	Doi = {10.1109/CSMR.2005.21},
	Inria = {hors},
	Keywords = {scg-pub kzDynamicInformation recast05 stefPub Feature Feature-Traces Dynamic Analysis Evolution moose},
	Location = {Manchester, United Kingdom},
	Misc = {acceptance rate: 33/81 = 41\%},
	Pages = {314--323},
	Publisher = {IEEE Computer Society},
	Rate = {41\%},
	Selectif = {non},
	Title = {Correlating Features and Code Using A Compact Two-Sided Trace Analysis Approach},
	Url = {http://scg.unibe.ch/archive/papers/Gree05aTraceScraperCSMR2005Features.pdf},
  Year = {2005}}

@inproceedings{Gree05b,
	Abstract = {Software developers are often faced with the task of
                  maintaining or extending large and complex
                  applications, with which they are unfamiliar.
                  Typically change requests and bug reports are
                  expressed in terms of system features. Much of the
                  maintenance effort is spent trying to identify which
                  classes and methods provide functionality to
                  individual features. To tackle this problem, we
                  propose an approach based on dynamic analysis that
                  exploits the relationship between features and
                  software entities. Our definition of a feature is a
                  unit of observable behavior of a software system. We
                  apply our approach to a large open source
                  application and identify key classes and methods
                  which provide functionality to individual features.},
	Annote = {internationalworkshop},
	Author = {Orla Greevy and St\'ephane Ducasse},
	Booktitle = {Proceedings of WOOR 2005 (6th International Workshop on Object-Oriented Reengineering)},
	Cvs = {TraceScraperWOOR2005},
	Keywords = {scg-pub skip-doi greevy jb06 MISSINGPAGENUMBERS stefPub Feature Feature-Traces Dynamic Analysis Evolution moose recast05 kzDynamicInformation},
	Month = jul,
	Title = {Characterizing the Functional Roles of Classes and Methods by Analyzing Feature Traces},
	Url = {http://scg.unibe.ch/archive/papers/Gree05bTraceScraperWOOR2005.pdf},
  Year = {2005}}

@inproceedings{Gree05c,
	Abstract = {Many of the approaches that analyze software
                  evolution consider a static perspective of a system.
                  Static analysis approaches focus on the evolution of
                  static software entities such as packages, classes
                  and methods. Without knowledge of the roles software
                  entities play in system features, it is difficult to
                  interpret the motivation behind changes and
                  extensions in the code. To tackle this problem, we
                  propose an approach to software evolution analysis
                  that exploits the relationships between features and
                  software entities. Our definition of a feature is a
                  unit of observable behavior of a software system. We
                  define history measurements that summarize the
                  evolution of software entities from a feature
                  perspective. We show how we use our feature
                  perspective of software evolution to interpret
                  modifications and extensions to the code. We apply
                  our approach on two case studies and discuss our
                  findings.},
	Acceptnum = {55},
	Accepttotal = {180},
	Address = {Los Alamitos},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of 21st IEEE International Conference on Software Maintenance (ICSM'05)},
	Cvs = {TraceScraperICSM2005Evolution},
	Doi = {10.1109/ICSM.2005.22},
	Inria = {hors},
	Keywords = {scg-pub stefPub Features Feature-Traces Dynamic-Analysis Evolution history moose recast06 listic kzDynamicInformation},
	Misc = {acceptance rate: 55/180 = 31\%},
	Month = sep,
	Pages = {347--356},
	Publisher = {IEEE Computer Society},
	Rate = {31\%},
	Selectif = {oui},
	Title = {Analyzing Feature Traces to Incorporate the Semantics of Change in Software Evolution Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Gree05cTraceScraperICSM2005.pdf},
  Year = {2005}}

@article{Gree06b,
	Abstract = {Features encapsulate the domain knowledge of a
                  software system and thus are valuable sources of
                  information for a reverse engineer. When analyzing
                  the evolution of a system, we need to know how and
                  which features were modified to recover both the
                  change intention and its extent, namely which source
                  artifacts are affected. Typically, the
                  implementation of a feature crosscuts a number of
                  source artifacts. To obtain a mapping between
                  features to the source artifacts, we exercise the
                  features and capture their execution traces. However
                  this results in large traces that are difficult to
                  interpret. To tackle this issue we compact the
                  traces into simple sets of source artifacts that
                  participate in a feature's runtime behavior. We
                  refer to these compacted traces as feature views.
                  Within a feature view, we partition the source
                  artifacts into disjoint sets of characterized
                  software entities. The characterization defines the
                  level of participation of a source entity in the
                  features. We then analyze the features over several
                  versions of a system and we plot their evolution to
                  reveal how and hich features were affected by
                  changes in the code. We show the usefulness of our
                  approach by applying it to a case study where we
                  address the problem of merging parallel development
                  tracks of the same system.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Orla Greevy and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1002/smr.340},
	Impactfactor = {5 Year ISI impact factor (2010) 1.523},
	Inria = {hors},
	Journal = {Journal of Software Maintenance and Evolution: Research and Practice (JSME)},
	Keywords = {scg-pub recast07 stefPub girba dynamic-analysis feature evolution moose kzDynamicInformation},
	Number = {6},
	Pages = {425--456},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Analyzing Software Evolution through Feature Views},
	Url = {http://scg.unibe.ch/archive/papers/Gree06bTraceScraperJSME-SCG.pdf},
	Volume = {18},
  Year = {2006}}

@inproceedings{Gree07a,
	Abstract = {Software systems are typically developed by teams of
                  developers, with responsibilities for different
                  parts of the code. Knowledge of how the developers
                  collaborate, and how their responsibilities are
                  distributed over the software artifacts is a
                  valuable source of information when reverse
                  engineering a system. Determining which developers
                  are responsible for which software artifacts (\eg
                  packages or classes) is just one perspective. In
                  this paper we complement the static perspective with
                  the dynamic perspective of a system in terms of its
                  features. We want to extract information about which
                  developers are responsible for which features. To
                  achieve these two perspectives, we correlate
                  developer responsibilities both with a structural
                  view of the system and with a feature view. We
                  identify which developers are responsible for which
                  features, and whether the responsibilities
                  correspond with structural source code artifacts or
                  with features. We apply our technique to two
                  software projects developed by two teams of students
                  as part of their course work, and to one large open
                  source project.},
	Acceptnum = {38},
	Accepttotal = {132},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Orla Greevy and Tudor G\^irba and St\'ephane Ducasse},
	Booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR 2007)},
	Cvs = {TraceScraperCSMR2007},
	Doi = {10.1109/CSMR.2007.27},
	Inria = {hors},
	Isbn = {0-7695-2802-3},
	Issn = {1534-5351},
	Keywords = {scg-pub greevy stefPub moose authors features evolution dynamic-analysis girba kzDynamicInformation},
	Medium = {2},
	Misc = {Acceptance rate: 38/132=29\%},
	Pages = {256--274},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {29\%},
	Selectif = {oui},
	Title = {How Developers Develop Features},
	Url = {http://scg.unibe.ch/archive/papers/Gree07aDevelopersDevelopFeatures.pdf},
  Year = {2007}}

@article{Gybe06a,
	Abstract = {Meta programming is the act of reasoning about a
                  computational system. For example, a program in
                  Prolog can reason about a program written in
                  Smalltalk. Reflection is a more powerful form of
                  meta programming where the same language is used to
                  reason about, and act upon, itself in a causally
                  connected way. Thus on the one hand we have meta
                  programming that allows different languages or
                  paradigms to be used, but without causal connection,
                  while on the other hand we have reflection that
                  offers causal connection but only for a single
                  language. This paper combines both and presents
                  inter-language reflection that allows one language
                  to reason about and change in a causally connected
                  way another language and vice versa. The fundamental
                  aspects of inter-language reflection and the
                  language symbiosis used therein, are discussed.
                  Moreover the implementation of two symbiotic
                  reflective languages is discussed: Agora/Java and
                  SOUL/Smalltalk.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Kris Gybels and Roel Wuyts and St\'{e}phane Ducasse and Maja D'Hondt},
	Doi = {10.1016/j.cl.2005.10.003},
	Impactfactor = {5 Year ISI impact factor (2009) 0.619},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {stefPub kzReflection},
	Month = jul,
	Number = {2-3},
	Pages = {109--124},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Inter-Language Reflection --- A Conceptual Model and Its Implementation},
	Url = {http://scg.unibe.ch/archive/papers/Gybe06aSymbioticReflectionESUGJournal.pdf},
	Volume = {32},
  Year = {2006}}

@inproceedings{Hald07b,
	Abstract = {Most languages fall into one of two camps: either
                  they adopt a unique, static type system, or they
                  abandon static type-checks for run-time checks.
                  Pluggable types blur this division by (i) making
                  static type systems optional, and (ii) supporting a
                  choice of type systems for reasoning about different
                  kinds of static properties. Dynamic languages can
                  then benefit from static-checking without
                  sacrificing dynamic features or committing to a
                  unique, static type system. But the overhead of
                  adopting pluggable types can be very high,
                  especially if all existing code must be decorated
                  with type annotations before any type-checking can
                  be performed. We propose a practical and pragmatic
                  approach to introduce pluggable type systems to
                  dynamic languages. First of all, only annotated code
                  is type-checked. Second, limited type inference is
                  performed on unannotated code to reduce the number
                  of reported errors. Finally, external annotations
                  can be used to type third-party code. We present
                  Typeplug, a Smalltalk implementation of our
                  framework, and report on experience applying the
                  framework to three different pluggable type
                  systems.},
	Annote = {internationalconference},
	Author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352690},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg-pub reflectivity marcusdenker fromscgbib kzLanguageDesign},
	Medium = {2},
	Pages = {183--204},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Practical, Pluggable Types},
	Url = {http://rmod.inria.fr/archives/papers/Hald07b-ICDL07-Typeplug.pdf},
  Year = {2007}}

@article{Hald09a,
	Abstract = {Most languages fall into one of two camps: either
                  they adopt a unique, static type system, or they
                  abandon static type-checks for run-time checks.
                  Pluggable types blur this division by (i) making
                  static type systems optional, and (ii) supporting a
                  choice of type systems for reasoning about different
                  kinds of static properties. Dynamic languages can
                  then benefit from static-checking without
                  sacrificing dynamic features or committing to a
                  unique, static type system. But the overhead of
                  adopting pluggable types can be very high,
                  especially if all existing code must be decorated
                  with type annotations before any type-checking can
                  be performed. We propose a practical and pragmatic
                  approach to introduce pluggable type systems to
                  dynamic languages. First of all, only annotated code
                  is type-checked. Second, limited type inference is
                  performed on unannotated code to reduce the number
                  of reported errors. Finally, external annotations
                  can be used to type third-party code. We present
                  Typeplug, a Smalltalk implementation of our
                  framework, and report on experience applying the
                  framework to three different pluggable type
                  systems.},
	Annote = {internationaljournal},
	Author = {Niklaus Haldimann and Marcus Denker and Oscar Nierstrasz},
	Doi = {10.1016/j.cl.2008.06.003},
	Impactfactor = {Impact factor (2010) 0.421},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg09 scg-pub jb08 snf08 reflectivity marcusdenker fromscgbib},
	Medium = {2},
	Month = apr,
	Number = {1},
	Pages = {48--64},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Practical, Pluggable Types for a Dynamic Language},
	Url = {http://rmod.inria.fr/archives/papers/Hald08a-COMLAN-Typeplug.pdf},
	Volume = {35},
  Year = {2009}}

@incollection{Hart13a,
	Annote = {articlebook},
	Author = {Norbert Hartl and Christian Denker and Marcus Denker},
	Booktitle = {Mobile Apps - Rechtsfragen und rechtliche Rahmenbedingungen},
	Editor = {Christian Solmecke and Juergen Taeger and Thorsten Feldmann},
	Hal-Id = {hal-00865116},
	Isbn = {978-3-11-030503-6},
	Keywords = {lse-pub},
	Month = {aug},
	Pages = {9-24},
	Publisher = {De Gruyter},
	Title = {Kapitel 2: Technische Aspekte},
	Year = {2013}}

@inproceedings{Haup07a,
	Abstract = {This position paper proposes the exploitation of
                  type feedback mechanisms, or more precisely,
                  polymorphic inline caches, for purely interpreting
                  implementations of object-oriented programming
                  languages. Using Squeak's virtual machine as an
                  example, polymorphic inline caches are discussed as
                  an alternative to global caching. An implementation
                  proposal for polymorphic inline caches in the Squeak
                  virtual machine is presented, and possible future
                  applications for online optimization are outlined.},
	Annote = {internationalworkshop},
	Author = {Michael Haupt and Robert Hirschfeld and Marcus Denker},
	Booktitle = {Proceedings of the Second Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS'2007), ECOOP Workshop},
	Issn = {1436-9915},
	Keywords = {scg07 scg-pub skip-doi jb08 snf07 fromscgbib marcusdenker},
	Medium = {2},
	Month = jul,
	Pages = {17--22},
	Peerreview = {yes},
	Publisher = {TU Berlin},
	Title = {Type feedback for bytecode interpreters},
	Url = {http://rmod.inria.fr/archives/workshops/Haup07a-ICOOLPS07-PIC.pdf},
  Year = {2007}}

@inproceedings{Haya15a,
	Acceptnum = {46},
	Accepttotal = {144},
	Address = {Montreal, Canada},
	Aeres = {ACT},
	Hal-id = {hal-01185795},
	Aeresstatus = {aeres15},
	Annote = {internationalconference},
	Author = {Hayatou Oumarou and Nicolas Anquetil and Anne Etien and St{\'e}phane Ducasse and Kolyang Dina Taiwe},
	Booktitle = {Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER'15)},
	Inria = {RMOD},
	Inriareport = {2015},
	Keywords = {moose lse-pub raweb2015 pharo},
	Abstract = {We study good programming practices expressed in rules and detected by static analysis checkers such as PMD or FindBugs. To understand how violations to these rules are corrected and whether this can be automated, we need to identify in the source code where they appear and how they were fixed. This presents some similarities with research on understanding software bugs, their causes, their fixes, and how they could be avoided. The traditional method to identify how a bug or a rule violation were fixed consists in finding the commit that contains this fix and identifying what was changed in this commit. If the commit is small, all the lines changed are ascribed to the fixing of the rule violation or the bug. However, commits are not always atomic, and several fixes and even enhancements can be mixed in a single one (a large commit). In this case, it is impossible to detect which modifications contribute to which fix. In this paper, we are proposing a method that identifies precisely the modifications that are related to the correction of a rule violation. The same method could be applied to bug fixes, providing there is a test illustrating this bug. We validate our solution on a real world system and actual rules.},
	Labo = {dans},
	Misc = {acceptance rate: 46/144 = 32\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {Identifying the Exact Fixing Actions of Static Rule Violation},
	Url = {http://rmod.inria.fr/archives/papers/Haya15a-Saner-FixingActionOfStaticRule.pdf},
	X-Country = {CM},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}

@inproceedings{Hofe06a,
	Abstract = {Traditional debugging and stepping execution trace
                  are well-accepted techniques to understand deep
                  internals about a program. However in many cases
                  navigating the stack trace is not enough to find
                  bugs, since the cause of a bug is often not in the
                  stack trace anymore and old state is lost, so out of
                  reach from the debugger. In this paper, we present
                  the design and implementation of a backward-in-time
                  debugger for a dynamic language, i.e, a debugger
                  that allows one to navigate back the history of the
                  application. We present the design and
                  implementation of a backward-in-time debugger called
                  Unstuck and show our solution to key implementation
                  challenges.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Christoph Hofer and Marcus Denker and St\'ephane Ducasse},
	Booktitle = {Proceedings of NODE'06},
	Inria = {hors},
	Keywords = {skip-doi scg-pub stefPub jb07 fb06 snf06 fromscgbib marcusdenker kzDynamicInformation kzTool},
	Medium = {2},
	Month = sep,
	Organization = {Gesellschaft f{\"u}r Informatik (GI)},
	Pages = {17--32},
	Peerreview = {yes},
	Selectif = {non},
	Series = {Lecture Notes in Informatics},
	Title = {Design and Implementation of a Backward-In-Time Debugger},
	Url = {http://rmod.inria.fr/archives/papers/Hofe06a-NODE06-Unstuck.pdf},
	Volume = {P-88},
  Year = {2006}}

@inproceedings{Hora12a,
	Abstract = {To harness the complexity of big legacy software, software engineering tools need more and more information on these systems. This information may come from analysis of the source code, study of execution traces, computing of metrics, etc. One source of information received less attention than source code: the bugs on the system. Little is known about the evolutionary behavior, lifetime, distribution, and stability of bugs. In this paper, we propose to consider bugs as first class entities and a useful source of information that can answer such topics. Such analysis is inherently complex, because bugs are intangible, invisible, and difficult to be traced. Therefore, our tool extracts information about bugs from bug tracking systems, link this information to other software artifacts, and explore interactive visualizations of bugs that we call bug maps.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {tooldemo},
	Author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Muhammad Bhatti and Cesar Couto and Marco T\'ulio Valente and Julio Martins},
	Booktitle = {Proceedings of the 16th European Conference on Software Maintenance and Reengineering (CSMR'12) - Tool Demonstration Track},
	Hal-Id = {hal-00668397},
	Inria = {RMOD},
	Inriareport = {2012},
	Keywords = {moose lse-pub raweb2012 kzVisualization},
	Labo = {dans},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {BugMaps: A Tool for the Visual Exploration and Analysis of Bugs},
	Url = {http://rmod.inria.fr/archives/papers/Hora12a-Official-CSMR2012Tools-BugMaps.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2012}}

@inproceedings{Hora12b,
	Abstract = {Tools to detect coding standard violations in source code are commonly used to improve code quality. One of their original goals is to prevent bugs, yet, a high number of false positives is generated by the rules of these tools, i.e., most warnings do not indicate real bugs. There are empirical evidences supporting the intuition that the rules enforced by such tools do not prevent the introduction of bugs in software. This may occur because the rules are too generic and do not focus on domain specific problems of the software under analysis. We underwent an investigation of rules created for a specific domain based on expert opinion to understand if such rules are worthwhile enforcing in the context of defect prevention. In this paper, we performed a systematic study to investigate the relation between generic and domain specific warnings and observed defects. From our experiment on a real case, long term evolution, software, we have found that domain specific rules provide better defect prevention than generic ones.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {topconference internationalconference},
	Author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Simon Allier},
	Booktitle = {Proceedings of the 28th IEEE International Conference on Software Maintenance (ICSM'12)},
	Hal-Id = {hal-00848830},
	Inria = {RMOD},
	Inriareport = {2012},
	Keywords = {moose lse-pub raweb2012 kzChecking},
	Labo = {dans},
	Misc = {acceptance rate: 46/181 = 25\%},
	Rate = {25\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {Domain Specific Warnings: Are They Any Better?},
	Url = {http://rmod.inria.fr/archives/papers/Hora12b-ICSM2012-DedicatedRules.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2012}}

@inproceedings{Hora13a,
	Abstract = {A significant percentage of warnings reported by tools to detect coding standard violations are false positives. Thus, there are some works dedicated to provide better rules by mining them from source code history, analyzing bug-fixes or changes between system releases. However, software evolves over time, and during development not only bugs are fixed, but also features are added, and code is refactored. In such cases, changes must be consistently applied in source code to avoid maintenance problems. In this paper, we propose to extract system specific rules by mining systematic changes over source code history, i.e., not just from bug-fixes or system releases, to ensure that changes are consistently applied over source code. We focus on structural changes done to support API modification or evolution with the goal of providing better rules to developers. Also, rules are mined from predefined rule patterns that ensure their quality. In order to assess the precision of such specific rules to detect real violations, we compare them with generic rules provided by tools to detect coding standard violations on four real world systems covering two programming languages. The results show that specific rules are more precise in identifying real violations in source code than generic ones, and thus can complement them.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Andre Hora and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering (WCRE'13)},
	Hal-Id = {hal-00854861},
	Keywords = {moose lse-pub cutter kzChecking},
	Misc = {Acceptance rate: 38/97 = 39\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {Mining System Specific Rules from Change Patterns},
	Url = {http://rmod.inria.fr/archives/papers/Hora13a-MinedRules-WCRE13.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2013}}

@inproceedings{Hora14a,
	Abstract = {During software evolution, source code is constantly refactored. In real-world migrations, many methods in the newer version are not present in the old version (e.g., 60\% of the methods in Eclipse 2.0 were not in version 1.0). This requires changes to be consistently applied to reflect the new API and avoid further maintenance problems. In this paper, we propose a tool to extract rules by monitoring API changes applied in source code during system evolution. In this process, changes are mined at revision level in code history. Our tool focuses on mining invocation changes to keep track of how they are evolving. We also provide three case studies in order to evaluate the tool.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Andre Hora and Anne Etien and Nicolas Anquetil and St\'ephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {Proceedings of the Software Evolution Week (CSMR-WCRE'14)},
	Hal-Id = {hal-00991722},
	Keywords = {moose lse-pub cutter kzChecking},
	Misc = {acceptance rate: 27/86 = 31\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {APIEvolutionMiner: Keeping API Evolution under Control},
	Url = {http://rmod.inria.fr/archives/papers/Hora14a-CSMR-WCRE-APIEvolutionMiner.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2014}}

@phdthesis{Hora14b,
	Abstract = {Software systems evolve by adding new features, fixing bugs or refactoring existing source code. During this process, some problems may occur (e.g., backward-incompatibility, missing or unclear method deprecation) causing evolving systems and their clients to be inconsistent or to fail, decreasing code quality. As nowadays software systems are frequently part of bigger ecosystems, such problems are even harder to handle because the impact may be large and unknown.One solution to deal with such maintainability problems is the usage of rules to ensure consistency. These rules may be created by experts or extracted from source code repositories, which are commonly evaluated in small-scale case studies. We argue that existing approaches lack of: (i) a deep understanding of the benefits provided by expert-based rules, (ii) a better use of source code repositories to extract history-based rules, and (iii) a large-scale analysis of the impact of source code evolution on the actual clients.In this thesis we propose to analyze and improve rules to better support developers keeping track of source code evolution. We cover three aspects. The benefits provided by expert-based rules: we report on an investigation of rules created based on expert opinion to understand whether they are worthwhile to be adopted given the cost to produce them. The improvement of history-based rules: we propose two solutions to extract better rules from source code history. The impact of source code evolution on a software ecosystem: we undergo an investigation, in a large-scale ecosystem, on the awareness of the client systems about source code evolution.We evaluated the proposed approaches qualitatively and quantitatively in real-world case studies, and, in many cases, with the help of experts on the system under analysis. The results we obtained demonstrate the usefulness of our approaches.},
	Author = {Andre Cavalcante Hora},
	Hal-Id = {tel-01087860},
	Month = {nov},
	School = {University Lille 1 - Sciences et Technologies - France},
	Title = {Assessing and Improving Rules to Support Software Evolution},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2014-Hora.pdf},
  Year = {2014}}

@inproceedings{Hora15a,
	Author = {Andr\'e Hora and Romain Robbes and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {Proceedings of the 31st IEEE International Conference on Software Maintenance},
	Hal-Id = {hal-01185736},
	inriareport = {2015},
	Keywords = {lse-pub},
	Misc = {acceptance rate: 32/148 = 22\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {How Do Developers React to API Evolution? The Pharo Ecosystem Case},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015},
	annote = {topconference},
	aeres = {ACT},
	labo = {dans},
	inria = {RMOD},
  Url = {http://rmod.inria.fr/archives/papers/Hora15a-icsme-api-evolution.pdf}
}

@article{Hora15b,
	author = {Andr\'e Hora and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
	title = {Automatic Detection of System-Specific Conventions Unknown to Developers},
	journal = {Journal of Systems and Software},
	Hal-Id = {hal-01185837},
	year = {2015},
	doi = {10.1016/j.jss.2015.08.007},
	Tagnicolasa =  {analysis},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	annote = {internationaljournal},
	aeres = {ACL},
	labo = {dans},
	inria = {RMOD},
  Url = {http://rmod.inria.fr/archives/papers/Hora15b-JSS-detection-specific-conventions.pdf}
}

@inproceedings{Kuhn05a,
	Abstract = {Understanding a software system by just analyzing the structure of the system reveals only half of the picture, since the structure tells us only how the code is working but not what the code is about. What the code is about can be found in the semantics of the source code: names of identifiers, comments etc. In this paper, we analyze how these terms are spread over the source artifacts using Latent Semantic Indexing, an information retrieval technique. We use the assumption that parts of the system that use similar terms are related. We cluster artifacts that use similar terms, and we reveal the most relevant terms for the computed clusters. Our approach works at the level of the source code which makes it language independent. Nevertheless, we correlated the semantics with structural information and we applied it at different levels of abstraction (e.g. classes, methods). We applied our approach on three large case studies and we report the results we obtained.},
	Acceptnum = {21},
	Accepttotal = {58},
	Address = {Los Alamitos CA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of 12th Working Conference on Reverse Engineering (WCRE'05)},
	Doi = {10.1109/WCRE.2005.16},
	Inria = {hors},
	Keywords = {scg-pub semantic clustering lsi stefPub girba recast06 hapax moose kzVisualization kzRemodularisation},
	Location = {Pittsburgh, PA},
	Misc = {acceptance rate: 21/58 = 36 \%},
	Month = nov,
	Pages = {113--122},
	Publisher = {IEEE Computer Society Press},
	Rate = {36\%},
	Selectif = {non},
	Title = {Enriching Reverse Engineering with Semantic Clustering},
	Url = {http://scg.unibe.ch/archive/papers/Kuhn05aSemanticClustering.pdf},
  Year = {2005}}

@article{Kuhn07a,
	Abstract = {Many of the existing approaches in Software
                  Comprehension focus on program program structure or
                  external documentation. However, by analyzing formal
                  information the informal semantics contained in the
                  vocabulary of source code are overlooked. To
                  understand software as a whole, we need to enrich
                  software analysis with the developer knowledge
                  hidden in the code naming. This paper proposes the
                  use of information retrieval to exploit linguistic
                  information found in source code, such as identifier
                  names and comments. We introduce Semantic
                  Clustering, a technique based on Latent Semantic
                  Indexing and clustering to group source artifacts
                  that use similar vocabulary. We call these groups
                  semantic clusters and we interpret them as
                  linguistic topics that reveal the intention of the
                  code. We compare the topics to each other, identify
                  links between them, provide automatically retrieved
                  labels, and use a visualization to illustrate how
                  they are distributed over the system. Our approach
                  is language independent as it works at the level of
                  identifier names. To validate our approach we
                  applied it on several case studies, two of which we
                  present in this paper.},
	Address = {Newton, MA, USA},
	Aeres = {ACL},
	Aereststatus = {2008},
	Annote = {internationaljournal},
	Author = {Adrian Kuhn and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1016/j.infsof.2006.10.017},
	Impactfactor = {ISI impact factor (2010) 1.821},
	Inria = {hors},
	Issn = {0950-5849},
	Journal = {Information and Software Technology},
	Keywords = {moose scg-pub recast07 girba stefPub kzRemodularisation},
	Month = mar,
	Number = {3},
	Pages = {230--243},
	Peerreview = {yes},
	Publisher = {Butterworth-Heinemann},
	Title = {Semantic Clustering: Identifying Topics in Source Code},
	Url = {http://scg.unibe.ch/archive/drafts/Kuhn06bSemanticClustering.pdf},
	Volume = {49},
  Year = {2007}}

@techreport{Kuhn10m,
	Abstract = {Often, when modelling a system there are properties and operations that
	 are related to a group of objects rather than to a single object. In this paper we extend
	 Java with Swarm Behavior, a new composition operator that associates behavior with
	 a collection of instances. The lookup resolution of swarm behavior is based on the element
	 type of a collection and is thus orthogonal to the collection hierarchy.},
	Aeres = {AP},
	Aeresstatus = {aeres12},
	Annote = {technicalReport notrefereed},
	Author = {Adrian Kuhn and David Erni and Marcus Denker},
	Inria = {RMOD},
	Institution = {Arxiv},
	Keywords = {lse-pub marcusdenker},
	Month = jul,
	Number = {arXiv:1007.0159},
	Title = {Empowering Collections with Swarm Behavior},
	Url = {http://rmod.inria.fr/archives/reports/Kuhn10a-ArXiv-SwarmBehavior.pdf},
	X-Country = {CH},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {no},
  Year = {2010}}

@inproceedings{Lanz01a,
	Abstract = {One of the main problems which arises in the field
                  of software evolution is the sheer amount of
                  information to be dealt with. Compared to reverse
                  engineering where the main goal is the main
                  understanding of one single system. In the field of
                  software evolution this information is multiplied by
                  the number of versions of the system one wants to
                  understand. To counter this problem we have come up
                  with a flexible query engine which can perform
                  queries on the different versions of a system. In
                  this paper we give an outlook on our current work in
                  the field of software evolution and focus
                  particularly on the concepts behind the query engine
                  we have built.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse and Lukas Steiger},
	Booktitle = {Proceedings of the Workshop on Formal Foundations of Software Evolution},
	Keywords = {scg-pub skip-doi stefPub moose kzVisualization kzHistory},
	Title = {Understanding Software Evolution using a Flexible Query Engine},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01aQueryEngine.pdf},
  Year = {2001}}

@inproceedings{Lanz01b,
	Abstract = {The reengineering and reverse engineering of
                  software systems is gaining importance in software
                  industry, because the accelerated turnover in
                  software companies creates legacy systems in a
                  shorter period of time. Especially understanding
                  classes is a key activity in object-oriented
                  programming, since classes represent the primary
                  abstractions from which applications are built. The
                  main problem of this task is to quickly grasp the
                  purpose of a class and its inner structure. To help
                  the reverse engineers in their first contact with a
                  foreign system, we propose a categorization of
                  classes based on the visualization of their internal
                  structure. The contributions of this paper are a
                  novel categorization of classes and a visualization
                  of the classes which we call the class blueprint. We
                  have validated the categorization on several case
                  studies, two of which we present here.},
	Acceptnum = {27},
	Accepttotal = {145},
	Annote = {internationalconference topconference},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of 16th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '01)},
	Doi = {10.1145/504282.504304},
	Keywords = {scg-pub stefPub moose kzVisualization},
	Misc = {acceptance rate: 27/145 = 18\%},
	Pages = {300--311},
	Publisher = {ACM Press},
	Title = {A {Categorization} of {Classes} based on the {Visualization} of their {Internal} {Structure}: the {Class} {Blueprint}},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01bClassBlueprint.pdf},
  Year = {2001}}

@inproceedings{Lanz01d,
	Abstract = {Understanding classes is a key activity in
                  object-oriented programming, since classes represent
                  the primary abstractions from which applications are
                  built. The main problem of this task is to quickly
                  grasp the purpose and inner structure of a class. In
                  this paper we discuss the class blueprint, a
                  visualization of the inner structure of classes.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Workshop Proceedings of OOPSLA 2001},
	Keywords = {scg-pub skip-doi stefPub moose kzVisualization},
	Title = {The Class Blueprint: A Visualization of the Internal Structure of Classes},
	Url = {http://scg.unibe.ch/archive/papers/Lanz01dClassBlueprint.pdf},
  Year = {2001}}

@inproceedings{Lanz02a,
	Abstract = {Coping with huge amounts of data is one of the major
                  problems in the context of software evolution.
                  Current approaches reduce this complexity by
                  filtering out irrelevant information. In this paper
                  we propose an approach based on a combination of
                  software visualization and software metrics, as
                  software visualization is apt for complexity
                  reduction and metrics introduce the possibility to
                  qualify evolution. We discuss a simple and effective
                  way to visualize the evolution of software systems
                  which helps to recover the evolution of object
                  oriented software systems. In addition we define a
                  vocabulary that qualifies some specific situations
                  that occurs when considering system evolution.},
	Address = {Paris},
	Annote = {nationalconference},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of Langages et Mod\`eles \`a Objets (LMO'02)},
	Keywords = {scg-pub skip-doi stefPub moose kzVisualization kzMetric kzHistory},
	Pages = {135--149},
	Publisher = {Lavoisier},
	Title = {Understanding Software Evolution Using a Combination of Software Visualization and Software Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Lanz02aEvolutionMatrix.pdf},
  Year = {2002}}

@inproceedings{Lanz02b,
	Abstract = {Software Metrics have become essential in software
                  engineering for several reasons, among which quality
                  assessment and reengineering. In the context of the
                  European Esprit Project FAMOOS, whose main goal was
                  to provide methodologies for the reengineering of
                  large industrial software systems, we have developed
                  the Moose Reengineering Environment, based on the
                  language independent FAMIX metamodel. Moose includes
                  a metrics engine which supports language independent
                  metrics, since coping with software written in
                  different implementation languages was one of the
                  project's main constraints. Our current research is
                  pushing us towards the development and
                  implementation of a metametamodel, which would
                  include our metamodel and allow for several
                  extension in different research directions, among
                  which concept analysis, knowledge management and
                  software evolution. In this article we want to
                  present our current and future work for the
                  transition from language independent to domain
                  independent metrics.},
	Annote = {internationalworkshop},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 6th International Workshop on Quantitative Approaches in Object-Oriented Software Engineering},
	Editor = {Fernando Brito e Abreu and Mario Piattini and Geert Poels and Houari A. Sahraoui},
	Isbn = {84-699-8696-1},
	Keywords = {scg-pub skip-doi stefPub moose kzMetric kzMeta},
	Pages = {77--84},
	Title = {Beyond Language Independent Object-Oriented Metrics: Model Independent Metrics},
	Url = {http://scg.unibe.ch/archive/papers/Lanz02bModelIndependentMetrics.pdf},
  Year = {2002}}

@article{Lanz03d,
	Abstract = {Reverse engineering software systems has become a
                  major concern in software industry because of their
                  sheer size and complexity. This problem needs to be
                  tackled, since the systems in question are of
                  considerable worth to their owners an d maintainers.
                  In this article we present the concept of a
                  polymetric view, a lightweight software
                  visualization technique enriched with software
                  metrics information. Polymetric views help to
                  understand the structure and detect problems of a
                  software system in the initial phases of a reverse
                  engineering process. We discuss the benefits and
                  limits of several predefined polymetric views we
                  have implemented in our tool CodeCrawler. Moreover,
                  based on clusters of different polymetric views we
                  have developed a methodology which supports and
                  guides a software engineer in the first phases of a
                  reverse engineering of a large software system. We
                  have refined this methodology by repeatedly applying
                  it on industrial systems, and illustrate it by
                  applying a selection of polymetric views to a case
                  study.},
	Annote = {internationaljournal},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Doi = {10.1109/TSE.2003.1232284},
	Impactfactor = {5-Year ISI impact factor (2010) 4.865},
	Journal = {Transactions on Software Engineering (TSE)},
	Keywords = {scg-pub recast04 stefPub moose kzVisualization},
	Month = sep,
	Number = {9},
	Pages = {782--795},
	Publisher = {IEEE Computer Society},
	Title = {Polymetric Views---A Lightweight Visual Approach to Reverse Engineering},
	Url = {http://scg.unibe.ch/archive/papers/Lanz03dTSEPolymetric.pdf},
	Volume = {29},
  Year = {2003}}

@inproceedings{Lanz05a,
	Annote = {tooldemo},
	Author = {Michele Lanza and St\'ephane Ducasse and Harald Gall and Martin Pinzger},
	Booktitle = {Proceedings of ICSE 2005 (27th IEEE International Conference on Software Engineering)},
	Keywords = {stefPub moose kzVisualization},
	Pages = {672--673},
	Publisher = {ACM Press},
	Title = {CodeCrawler --- An Information Visualization Tool for Program Comprehension},
	Year = {2005}}

@incollection{Lanz05b,
	Abstract = {CodeCrawler is an extensible and language
                  independent software visualization tool. It has been
                  validated in several industrial case studies over
                  the past years. CodeCrawler enables the fast
                  exploration of new visualization ideas. It
                  implements and visualizes polymetric views,
                  visualizations of software enriched with information
                  such as software metrics and other source code
                  semantics. It provides a rich set of views that can
                  be customized using a large set of metrics. While
                  CodeCrawler is mainly targeted at visualizing
                  object-oriented software, in its latest
                  implementation it has become a general information
                  visualization tool.},
	Address = {Milano},
	Aeres = {OS},
	Aeresstatus = {aeres08},
	Annote = {articlebook},
	Author = {Michele Lanza and St\'ephane Ducasse},
	Booktitle = {Tools for Software Maintenance and Reengineering},
	Inria = {hors},
	Isbn = {88-464-6396-X},
	Keywords = {scg-pub skip-doi stefPub recast05 moose kzVisualization kzTool},
	Pages = {74--94},
	Publisher = {Franco Angeli},
	Selectif = {non},
	Series = {RCOST / Software Technology Series},
	Title = {CodeCrawler --- An Extensible and Language Independent 2D and 3D Software Visualization Tool},
	Url = {http://scg.unibe.ch/archive/papers/Lanz05bCCBookChapter.pdf},
  Year = {2005}}

@inproceedings{Laut09a,
	Abstract = {Web development has moved from simple static pages to complex web applications, some of them
resembling desktop ones. In most of these applications the web browser acts as thin-client (or a view) of the
model that sits on the server. Despite the technological evolution of the web, there is still no standard
mechanism to send data or events from the server to the client without an explicit request from the later,
thus forcing the web browser to constantly poll the server for updates. To solve this problem a set of
techniques under the name of Comet were proposed, allowing to send information from the server to the web
browser without an explicit client request. In this paper we introduce Meteoroid, a Comet approach to make
live Seaside applications. Our framework exploits the Model-View-Controller (MVC) paradigm for building
 simple yet scalable web applications, requiring very little programming effort.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Juan Lautaro Fern\'andez and Santiago Robles and Andr\'es Fortier and St\'ephane Ducasse and Gustavo Rossi and Silvia Gordillo},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2009)},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {stefPub kzWeb},
	Location = {Brest, France},
	Peer = {yes},
	Publisher = {ACM Digital Library},
	Selectif = {non},
	Title = {Meteoroid Towards a real MVC for the Web},
	Url = {http://rmod.inria.fr/archives/workshops/Laut09a-IWST09-Meteroid.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {AR},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Lava08a,
	Annote = {internationalworkshop},
	Author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
	Booktitle = {FAMOOSr, 2nd Workshop on FAMIX and Moose in Reengineering},
	Hal-Id = {inria-00498482},
	Keywords = {moose lse-pub stefPub kzMetric},
	Title = {Assessing the Quality of your Software with MoQam},
	Url = {http://rmod.inria.fr/archives/workshops/Lava08a-Famoosr2008-MoQam.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {no},
  Year = {2008}}


@inproceedings{Lava09a,
	Abstract = {Les matrices de d\'ependance (DSM - Dependency Structure Matrix), d\'evelopp\'ees dans le cadre de l'optimisation de processus, ont fait leurs preuves pour identifier les d\'ependances logicielles entre des packages ou des sous-syst\`e\-mes. Il existe plusieurs algorithmes pour structurer une matrice de fa\c con \`a ce qu'elle refl\`ete l'architecture des \'el\'ements analys\'es et mette en \'evidence des cycles entre les sous-sys\-t\`e\-mes. Cependant, les impl\'ementations de matrices de d\'ependance existantes manquent d'informations importantes pour apporter une r\'eelle aide au travail de r\'eing\'enierie. Par exemple, le poids des relations qui posent probl\`eme ainsi que leur type ne sont pas clairement pr\'esent\'es. Ou encore, des cycles ind\'ependants sont fusionn\'es. Il est \'egalement difficile d'obtenir une visualisation centr\'ee sur un package.  Dans ce papier, nous am\'eliorons les matrices de d\'ependance en ajoutant des informations sur (i) le type de r\'ef\'erences, (ii) le nombre d'entit\'es r\'ef\'eren\c cantes, (iii) le nombre d'entit\'es r\'ef\'erenc\'ees. Nous  distinguons \'egalement les cycles ind\'ependants. Ce travail a \'et\'e impl\'ement\'e dans l'environnement de r\'eing\'enierie open-source \emph{Moose}. Il a \'et\'e appliqu\'e \`a des \'etudes de cas complexes comme le framework \emph{Morphic UI} contenu dans les environnements Smalltalk open-source \emph{Squeak} et  \emph{Pharo}. Les r\'esultats obtenus ont \'et\'e appliqu\'es dans l'environnement de programmation \emph{Pharo} et ont men\'e \`a des am\'eliorations.},
	Address = {Nancy, France},
	Annote = {nationalconference},
	Author = {Jannik Laval and Alexandre Bergel and St\'ephane Ducasse},
	Booktitle = {Proceedings of Languages et Mod\`eles \`a Objets (LMO 2009)},
	Hal-Id = {inria-00498463 /},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub pharo pharo-pub kzCycle kzRemodularisation},
	Title = {Matrice de d\'ependances enrichie},
	Url = {http://rmod.inria.fr/archives/papers/Lava09a-LMO2009-DSM.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {no},
	X-Language = {FR},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Lava09b,
	Abstract = {When reengineering large systems, software developers would like to assess and compare the impact of multiple change scenarios without actually performing these changes. A change can be effected by applying a tool to the source code, or by a manual refactoring. In addition, tools run over a model are costly to redevelop. It raises an interesting challenge for tools implementors: how to support modification of large source code models to enable comparison of multiple versions. One naive approach is to copy the entire model after each modification. However, such an approach is too expensive in memory and execution time. In this paper we explore different implementations that source code metamodels support multiple versions of a system. We propose a solution based on dynamic binding of entities between multiple versions, providing good access performance while minimizing memory consumption.},
	Address = {Brest, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Andy Kellens},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies},
	Hal-Id = {inria-00498492},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub pharo pharo-pub kzMeta},
	Labo = {dans},
	Pages = {1--7},
	Selectif = {oui},
	Series = {IWST'09},
	Title = {Supporting Incremental Changes in Large System Models},
	Url = {http://rmod.inria.fr/archives/workshops/Lava09b-IWST09-incrementalChange.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {BE},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Lava09c,
	Abstract = {Dependency Structure Matrix (DSM) has been successfully applied to identify software
 dependencies among packages and subsystems. A number of algorithms were proposed to compute the
 matrix so that it highlights patterns and problematic dependencies between subsystems. However,
 existing DSM implementations often miss important information to fully support reengineering
 effort. For example, they do not clearly qualify and quantify problematic relationships,
 information which is crucial to support remediation tasks.
In this paper we present enriched DSM (eDSM) where cells are enriched with contextual information
 about (i) the type of dependencies (inheritance, class reference . . . ), (ii) the proportion of
 referencing entities, (iii) the proportion of referenced entities. We distinguish independent
 cycles and stress potentially simple fixes for cycles using coloring information. This work is
 language independent and has been implemented on top of the Moose reengineering environment. It has
 been applied to non-trivial case studies among which ArgoUML, and Morphic the UI framework
 available in two open-source Smalltalks, Squeak and Pharo. Solution to problems identified by eDSM
 have been performed and retrofitted in Pharo main distribution.},
	Address = {Lille, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Alexandre Bergel},
	Booktitle = {WCRE '09: Proceedings of the 2009 16th Working Conference on Reverse Engineering},
	Hal-Id = {inria-00498446 /},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub pharo pharo-pub kzVisualization kzCycle},
	Labo = {dans},
	Misc = {Acceptance rate: 20/79 = 25\%},
	Rate = {25\%},
	Selectif = {oui},
	Title = {Identifying cycle causes with Enriched Dependency Structural Matrix},
	Url = {http://rmod.inria.fr/archives/papers/Lava09c-WCRE2009-eDSM.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Lava09d,
	Abstract = {No abstract},
	Address = {Brest, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
	Booktitle = {FAMOOSr 2009: 3rd Workshop on FAMIX and MOOSE in Software Reengineering},
	Hal-Id = {inria-00498495},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub pharo pharo-pub kzCycle},
	Labo = {dans},
	Selectif = {non},
	Title = {Identifying cycle causes with CycleTable},
	Url = {http://rmod.inria.fr/archives/workshops/Lava09d-Famoosr2009-CycleTable.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2009}}

@misc{Lava10a,
	Aeres = {OV},
	Aeresstatus = {aeres12},
	Annote = {vulgarisation},
	Author = {Jannik Laval and St\'ephane Ducasse},
	Hal-Id = {hal-00746241},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub kzVulgarisation},
	Month = jan,
	Number = 123,
	Selectif = {non},
	Title = {Optimisation d'applications en Pharo},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2010}}

@article{Lava10b,
	Abstract = {When reengineering software systems, maintainers should be able to assess and compare multiple change scenarios for a given goal, so as to choose the most pertinent one. Because they implicitly consider one single working copy, revision control systems do not scale up well to perform simultaneous analyses of multiple versions of systems. We designed Orion, an interactive prototyping tool for reengineering, to simulate changes and compare their impact on multiple versions of software source code models. Our approach offers an interactive simulation of changes, reuses existing assessment tools, and has the ability to hold multiple and branching versions simultaneously in memory. Specifically, we devise an infrastructure which optimizes memory usage of multiple versions for large models. This infrastructure uses an extension of the FAMIX source code meta-model but it is not limited to source code analysis tools since it can be applied to models in general. In this paper, we validate our approach by running benchmarks on memory usage and computation time of model queries on large models. Our benchmarks show that the Orion approach scales up well in terms of memory usage, while the current implementation could be optimized to lower its computation time. We also report on two large case studies on which we applied Orion.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Jannik Laval and Simon Denier and St\'ephane Ducasse and Jean-R\'emy Falleri},
	Doi = {10.1016/j.scico.2010.11.014},
	Hal-Id = {inria-00531500},
	Impactfactor = {5-year impact factor (2012) 0.903},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Journal of Science of Computer Programming (SCP)},
	Keywords = {lse-pub moose rawed2010 pharo pharo-pub kzMeta kzCycle kzRemodularisation},
	Labo = {dans},
	Month = may,
	Number = {12},
	Pages = {1177-1193},
	Selectif = {oui},
	Title = {Supporting Simultaneous Versions for Software Evolution Assessment},
	Url = {http://rmod.inria.fr/archives/papers/Lava10a-Official-SCP-Orion.pdf},
	Volume = {76},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	X-Scientific-Popularization = {yes},
  Year = {2011}}

@misc{Lava10c,
	Aeres = {OV},
	Aeresstatus = {aeres12},
	Annote = {vulgarisation},
	Author = {Jannik Laval and St\'ephane Ducasse},
	Hal-Id = {hal-00746242},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
	Month = sep,
	Number = 130,
	Selectif = {non},
	Title = {Pharo: un nouveau Smalltalk open source},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2010}}

@misc{Lava10d,
	Aeres = {OV},
	Aeresstatus = {aeres12},
	Annote = {vulgarisation},
	Author = {Jannik Laval and St\'ephane Ducasse},
	Hal-Id = {hal-00746243},
	Inria = {RMOD},
	Inriareport = {2010},
	Journal = {Linux Magazine},
	Keywords = {pharo-pub lse-pub raweb2010 kzVulgarisation},
	Month = nov,
	Number = 132,
	Selectif = {non},
	Title = {Package et gestion de versions en Pharo},
	Volume = {1},
	X-Scientific-Popularization = {yes},
	Year = {2010}}

@inproceedings{Lava10e,
	Abstract = {Packages are complex entities and it can be difficult to understand them as they play different roles (e.g., core package, UI class container, tests package . . . ). In particular, package interdependencies make difficult their management (substitution, evolutions, deprecation). Understanding whether a package has high or low impact on the system is another valuable piece of information. In addition, package organization represents the backbone of large software system. It is is usually agreed that packages should form layered structures. However, identifying such layered structure is difficult since packages are often in cycles. Several approaches propose to recover software structure or to visualize classes or files organization. Only few approaches provide layered organization and in particular take cycle into account. In this paper, we propose an approach which provides (i) a strategy to highlight dependencies which break Acyclic Dependency Principle and (ii) an organization of package (even in presence of cycles) in multiple layers. While our approach can be run automatically, it also supports human inputs and constraints. We validate our approach with a preliminary study on the structure of the Moose software analysis platform: it shows promising results.},
	Address = {Lille, France},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Jannik Laval and Nicolas Anquetil and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 9th edition of the Workshop BElgian-NEtherlands software eVOLution seminar (BENEVOL'10)},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {moose lse-pub raweb2010 pharo pharo-pub kzCycle kzRemodularisation},
	Labo = {dans},
	Selectif = {non},
	Tagnicolasa = {architecture},
	Title = {OZONE: Package Layered Structure Identification in presence of Cycles},
	Url = {http://rmod.inria.fr/archives/workshops/Lava10e-Benevol2010-Layers.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2010}}

@phdthesis{Lava11b,
	Abstract = {Software evolves over time with the modification, addition and removal of new classes, methods, functions, dependencies. A consequence is that behavior may not be placed in the right packages and the software modularization is broken. A good organization of classes into identifiable and collaborating packages eases the understanding, maintenance, test and evolution of software systems. We argue that maintainers lack tool support for understanding the concrete organization and for structuring packages within their context.
Our claim is that the maintenance of large software modularizations needs approaches that help (i) understanding the structure at package level and assessing its quality; (ii) identifying modularity problems; and (iii) take decisions and verify the impact of these decisions.
In this thesis, we propose ECOO, an approach to help reengineers identify and understand structural problems in software architectures and to support the remodularization activity. It concerns the three following research fields:
- Understanding package dependency problems. We propose visualizations to highlight cyclic dependencies problems at package level.
- Proposing dependencies to be changed for remodularization. The approach proposes dependencies to break to make the system more modular.
- Analyzing impact of change. The approach proposes a change impact analysis to try modifications before applying them on the real system.
The approaches presented in this thesis have been qualitatively and quantitatively validated and results have been taken into account in the reengineering of analyzed systems. The results we obtained demonstrate the usefulness of our approach.},
	Author = {Jannik Laval},
	Hal-Id = {tel-00601546},
	Inria = {RMOD},
	Inriareport = {2011},
	Institution = {INRIA},
	Keywords = {lse-pub raweb2011 pharo pharo-pub},
	School = {Universit\'e de Lille},
	Title = {Package Dependencies Analysis and Remediation in Object-Oriented Systems},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2011-Laval.pdf},
  Year = {2011}}

@article{Lava12b,
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Jannik Laval and Jean-R\'{e}my Falleri and Philippe Vismara and St\'{e}phane Ducasse},
	Doi = {10.5381/jot.2012.11.1.a4},
	Hal-Id = {hal-00692569},
	Inria = {RMOD},
	Inriareport = {2012},
	Issn = {1660-1769},
	Journal = {Journal of Object Technology},
	Keywords = {lse-pub moose kzRemodularization stefPub},
	Month = apr,
	Number = {1},
	Pages = {1-24},
	Title = {Efficient Retrieval and Ranking of Undesired Package Cycles in Large Software Systems},
	Url = {http://www.jot.fm/contents/issue\_2012\_04/article4.html},
	Volume = {11},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2012}}

@article{Lava13a,
	Annote = {internationaljournal},
	Author = {Jannik Laval and Nicolas Anquetil and Usman Bhatti and St{\'{e}}phane Ducasse},
	Doi = {10.1016/j.scico.2012.08.001},
	Hal-Id = {hal-00732655},
	Impactfactor = {Impact Factor (2013) 0.548},
	Journal = {Science of Computer Programming},
	Keywords = {lse-pub moose kzRemodularization stefPub},
	Number = {8},
	Pages = {1055--1072},
	Tagnicolasa = {architecture},
	Timestamp = {Sun, 28 Sep 2014 19:22:46 +0200},
	Title = {oZone: Layer identification in the presence of cyclic dependencies},
	Url = {http://rmod.inria.fr/archives/papers/Lava13a-Official-OzoneLayer-SCO.pdf},
	Volume = {78},
  Year = {2013}}

@incollection{Lava14a,
	Aeresstatus = {aeres12},
	Annote = {articlebook},
	Author = {Jannik Laval and Simon Denier and St\'ephane Ducasse},
	Booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
	Ean13 = {9782746245549},
	Keywords = {lse-pub cutter raweb2012 kzVisualization kzCycle},
	Publisher = {Herm\`es},
	Title = {Visualisations pour la remodularisation \`a large \'echelle des syst\`emes \`a objets},
	Url = {http://rmod.inria.fr/archives/papers/Lava14a-Chapitresvisu.pdf},
  Year = {2014}}

@article{Lava14b,
	Annote = {internationaljournal},
  Author = {Jannik Laval and St\'ephane Ducasse},
	Doi = {10.1002/spe.2164},
	Hal-Id = {hal-00748120},
	Journal = {Software: Practice and Experience},
	Keywords = {moose cutter kzCycle},
	Pages = {235-257},
	Title = {Resolving cyclic dependencies between packages with Enriched Dependency Structural Matrix},
	Url = {http://rmod.inria.fr/archives/papers/Lava14b-Official-SoftwarePracticeExperience-ResolvingCyclicDependencies.pdf},
	Volume = {44},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2014}}

@article{Ledo00a,
	Author = {Ledoux, Thomas and Bouraqadi-Saadani, Noury},
	Journal = {ECOOP 2000, Workshop on Reflection and Metalevel Architectures},
	Title = {Adaptability in mobile agent systems using reflection},
	Year = {2000}}

@inproceedings{Lent15a,
  Abstract     = {Code review is a difficult process because: (1)
                  developers often create tangled commits, (2) a
                  change may be scattered across many different parts
                  of a project, (3) many changes are shadowed, (4)
                  commit messages can be inaccurate or wrong. This
                  work aims to propose a solution to these problems by
                  exploiting the information provided by fine-grained
                  IDE events. To put this solution in practice, we
                  will develop a code review tool named Griotte in the
                  Pharo IDE.},
  Address      = {Lille, France},
  Annote       = {internationalworkshop},
  Author       = {Skip Lentz, Mart\'in Dias and Damien Cassou},
  Booktitle    = {BENEVOL'15: 14th BElgian-NEtherlands software
                  eVOLution seminar},
  Inria        = {RMOD},
  Keywords     = {code review fine-grained IDE events Epicea Griotte
                  Pharo},
  Title        = {Griotte: Improving Code Review with Fine-Grained IDE
                  Events},
  Url          = {http://rmod.lille.inria.fr/archives/workshops/Lent15a-BENEVOL15-Griotte\_code\_review.pdf},
  Year         = {2015}
}

@techreport{Leth97a,
	Author = {Timothy C. Lethbridge and Nicolas Anquetil},
	Institution = {University of Ottawa},
	Month = jul,
	Note = {Computer Science Technical Report of University of Ottawa},
	Tagnicolasa = {analysis},
	Title = {Architecture of a Source Code Exploration Tool: A Software Engineering Case Study},
	Year = {1997}}

@inproceedings{Lian02a,
	Abstract = {PECOS is a collaborative project between industrial
                  and research partners that seeks to enable
                  component-based technology for a class of embedded
                  systems known as "field devices". Results so far
                  include a component model for field devices and a
                  composition language for specifying connections
                  between software components. Here we investigate the
                  application of Rate Monotonic Analysis (RMA) to the
                  problem of generating real-time schedules for
                  compositions of field device components.},
	Annote = {internationalworkshop},
	Author = {Peng Liang and Gabriela Ar{\'e}valo and St\'ephane Ducasse and Michele Lanza and Nathanael Sch{\"a}rli and Roel Wuyts and Oscar Nierstrasz},
	Booktitle = {ECOOP 2002 Workshop Reader},
	Keywords = {scg-pub skip-doi pecos stefPub arevalo schaerli kzComponent},
	Title = {Applying RMA for Scheduling Field Device Components},
	Url = {http://scg.unibe.ch/archive/papers/Lian02aPecosRMA.pdf},
  Year = {2002}}

@inproceedings{Lien05a,
	Abstract = {Traits are basically mixins or interfaces but with
                  method bodies. In languages that support traits,
                  classes are composed out of traits. There are two
                  main advantages with traits. Firstly, decomposing
                  existing classes into traits from which they can be
                  recomposed improves the factoring of hierarchies.
                  Secondly it increases the library reuse potential by
                  providing more reusable traits. Identifying traits
                  and decomposing class hierarchies into traits is
                  therefore an important and challenging task to
                  facilitate maintainability and evolution. In this
                  paper we present how we use Formal Concept Analysis
                  to identify traits in inheritance hierarchies. Our
                  approach is two-staged: first we identify within a
                  hierarchy maximal groups of methods that have a set
                  of classes in common, second we cluster cohesive
                  groups of methods based on method invocations as
                  potential traits. We applied our approach on two
                  significant hierarchies and compare our results with
                  the manual refactorization of the same code which
                  was done by the authors of traits.},
	Acceptnum = {28},
	Accepttotal = {291},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference topconference},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
	Booktitle = {Proceedings of 20th Conference on Automated Software Engineering (ASE'05)},
	Cvs = {ConAnASE05Traits},
	Doi = {10.1145/1101908.1101921},
	Inria = {hors},
	Keywords = {scg-pub snf05 recast06 stefPub moose arevalo jb06 listic kzRemodularisation kzTrait},
	Medium = {2},
	Misc = {acceptance rate: 28/291 = 9\%},
	Month = nov,
	Pages = {66--75},
	Peerreview = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {9\%},
	Selectif = {oui},
	Title = {Identifying Traits with Formal Concept Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien05aIdentifyingTraits.pdf},
  Year = {2005}}

@inproceedings{Lien06a,
	Abstract = {Most of today's dynamic analysis approaches are
                  based on method traces. However, in the case of
                  object-orientation understanding program execution
                  by analyzing method traces is complicated because
                  the behavior of a program depends on the sharing and
                  the transfer of object references (aliasing). We
                  argue that trace-based dynamic analysis is at a too
                  low level of abstraction for object-oriented
                  systems. We propose a new approach that captures the
                  life cycle of objects by explicitly taking into
                  account object aliasing and how aliases propagate
                  during the execution of the program. In this paper,
                  we present in detail our new meta-model and discuss
                  future tracks opened by it.},
	Annote = {internationalworkshop},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings International Workshop on Program Comprehension through Dynamic Analysis (PCODA'06)},
	Keywords = {scg-pub skip-doi stefPub girba object-flow dynamic-analysis kzVisualization kzDynamicInformation},
	Medium = {2},
	Pages = {39--43},
	Peerreview = {yes},
	Title = {Capturing How Objects Flow At Runtime},
	Url = {http://scg.unibe.ch/archive/papers/Lien06aCapturingHowObjectsFlowPCODA06.pdf http://www.lore.ua.ac.be/Events/PCODA2006/pcoda2006proceedings.pdf},
  Year = {2006}}

@inproceedings{Lien07c,
	Abstract = {To extract abstract views of the behavior of an
                  object-oriented system for reverse engineering, a
                  body of research exists that analyzes a system's
                  runtime execution. Those approaches primarily
                  analyze the control flow by tracing method execution
                  events. However, they do not capture information
                  flows. We address this problem by proposing a novel
                  dynamic analysis technique named Object Flow
                  Analysis, which complements method execution tracing
                  with an accurate analysis of the runtime flow of
                  objects. To exemplify the usefulness of our analysis
                  we present a visual approach that allows a system
                  engineer to study classes and components in terms of
                  how they exchange objects at runtime. We illustrate
                  and validate our approach on two case studies.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL'07)},
	Doi = {10.1145/1352678.1352686},
	Inria = {hors},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg-pub girba moose object-flow dynamic-analysis kzReference kzDynamicInformation},
	Location = {Lugano, Switzerland},
	Medium = {2},
	Pages = {121--140},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Selectif = {non},
	Title = {Object Flow Analysis --- Taking an Object-Centric View on Dynamic Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien07c-ObjectFlowAnalysis.pdf},
  Year = {2007}}

@article{Lien08c,
	Abstract = {A large body of research analyzes the runtime
                  execution of a system to extract abstract behavioral
                  views. Those approaches primarily analyze control
                  flow by tracing method execution events or they
                  analyze object graphs of heap snapshots. However,
                  they do not capture how objects are passed through
                  the system at runtime. We refer to the exchange of
                  objects as the object flow, and we claim that object
                  flow is necessary to analyze if we are to understand
                  the runtime of an object-oriented application. We
                  propose and detail Object Flow Analysis, a novel
                  dynamic analysis technique that takes this new
                  information into account. To evaluate its
                  usefulness, we present a visual approach that allows
                  a developer to study classes and components in terms
                  of how they exchange objects at runtime. We
                  illustrate our approach on three case studies.},
	Aeres = {ACL},
	Aeresstatus = {aeres10},
	Annote = {internationaljournal},
	Author = {Adrian Lienhard and St\'ephane Ducasse and Tudor G\^irba},
	Doi = {10.1016/j.cl.2008.05.006},
	Impactfactor = {Impact factor (2008) 0.421},
	Inria = {hors},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg-pub girba moose object-flow dynamic-analysis remoose kzReference kzVisualization},
	Number = {1},
	Pages = {63--79},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Taking an Object-Centric View on Dynamic Information with Object Flow Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Lien08cObjectFlowAnalysis.pdf},
	Volume = {35},
  Year = {2009}}

@inproceedings{Loew07a,
	Abstract = {While many software systems today have to be aware
                  of the context in which they are executing, there is
                  still little support for structuring a program with
                  respect to context. A first step towards better
                  context-orientation was the introduction of method
                  layers. This paper proposes two additional language
                  concepts, namely the implicit activation of method
                  layers, and the introduction of dynamic variables},
	Annote = {internationalconference},
	Author = {Martin von L\"owis and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 2007 International Conference on Dynamic Languages (ICDL 2007)},
	Doi = {10.1145/1352678.1352688},
	Isbn = {978-1-60558-084-5},
	Keywords = {scg07 scg-pub jb08 snf08 fromscgbib marcusdenker},
	Medium = {2},
	Pages = {143--156},
	Peerreview = {yes},
	Publisher = {ACM Digital Library},
	Title = {Context-Oriented Programming: Beyond Layers},
	Url = {http://rmod.inria.fr/archives/papers/Loew07a-ICDL07-PyContext.pdf},
  Year = {2007}}

@inproceedings{Maff13a,
	Abstract = {Software systems usually follow many programming rules prescribed in an architectural model. However, developers frequently violate these rules, introducing architectural drifts in the source code. In this paper, we present a data mining approach for architecture conformance based on a combination of static and historical software analysis. For this purpose, the proposed approach relies on data mining techniques to extract structural and historical architectural patterns. In addition, we propose a methodology that uses the extracted patterns to detect both absences and divergences in source-code based architectures. We applied the proposed approach in an industrial strength system. As a result we detected 137 architectural violations, with an overall precision of 41.02%.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Cristiano Maffort and Marco T\'ulio Valente and Mariza Bigonha and Andre Hora and Nicolas Anquetil and Jonata Menezes},
	Booktitle = {Proceedings of the 25th International Conference on Software Engineering and Knowledge Engineering (SEKE'13)},
	Hal-Id = {hal-00854851},
	Inria = {RMOD},
	Inriareport = {2013},
	Keywords = {lse-pub},
	Labo = {dans},
	Misc = {Acceptance rate: 72/259 = 28\%},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Mining Architectural Patterns Using Association Rules},
	Url = {http://rmod.inria.fr/archives/papers/Maff13a-ArchitecturalPatterns-SEKE13.pdf},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2013}}

@inproceedings{Maff13b,
	Abstract = {Software architecture conformance is a key software quality control activity that aims to reveal the progressive gap normally observed between concrete and planned software architectures. In this paper, we present ArchLint, a lightweight approach for architecture conformance based on a combination of static and historical source code analysis. For this purpose, ArchLint relies on four heuristics for detecting both absences and divergences in source code based architectures. We applied ArchLint in an industrial-strength system and as a result we detected 119 architectural violations, with an overall precision of 46.7\% and a recall of 96.2\%, for divergences. We also evaluated ArchLint with four open-source systems, used in an independent study on reflexion models. In this second study, ArchLint achieved precision results ranging from 57.1\% to 89.4\%.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Cristiano Maffort and Marco T\'ulio Valente and Nicolas Anquetil and Andre Hora and Mariza Bigonha},
	Booktitle = {Proceedings of the 20th Working Conference on Reverse Engineering (WCRE'13)},
	Hal-Id = {hal-00854871},
	Inria = {RMOD},
	Inriareport = {2013},
	Keywords = {lse-pub},
	Labo = {dans},
	Misc = {Acceptance rate: 38/97 = 39\%},
	Selectif = {oui},
	Tagnicolasa = {architecture},
	Title = {Heuristics for Discovering Architectural Violations},
	Url = {http://rmod.inria.fr/archives/papers/Maff13b-HeuristicsArchitecturalViolations-WCRE13.pdf},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2013}}

@article{Maff15a,
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Cristiano Maffort and Marco T\'ulio Valente and Ricardo Terra and Mariza Bigonha and Nicolas Anquetil and Andre Hora},
	Editor = {Springer},
	Hal-Id = {hal-01075642},
	Impactfactor = {Impact Factor (2013) 1.640},
	Inria = {RMOD},
	Issn = {1382-3256},
    doi = {10.1007/s10664-014-9348-2},
	Journal = {Empirical Software Engineering},
	Keywords = {lse-pub},
	Tagnicolasa = {architecture},
	Title = {Mining Architectural Violations from Version History},
	Url = {http://rmod.inria.fr/archives/papers/Maff14a-ArchitecturalViolations-EMSE.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	Year = {2015},
  Month = {jan}}

@inproceedings{Manj02a,
	Annote = {internationalconference},
	Author = {Manjarr\'es, Angeles and Suny\'e, Gerson and Pollet, Damien and Pickin, Simon and J\'ez\'equel, Jean-Marc},
	Booktitle = {International Conference on Software Engineering and Knowledge Engineering (SEKE)},
	Editor = {ACM},
	Month = {jul},
	Pages = {237--238},
	Title = {AI Analysis Patterns as UML Meta-model Constructs},
	Url = {http://www.irisa.fr/triskell/publis/2002/Manjarres02a.pdf},
  Year = {2002}}

@inproceedings{Manj02b,
	Annote = {internationalconference},
	Author = {Manjarr\'es, Angeles and Pickin, Simon and Suny\'e, Gerson and Pollet, Damien and J\'ez\'equel, Jean-Marc},
	Booktitle = {SGAI International Conference on Knowledge Based Systems and Applied Artificial Intelligence: Research and Development in Intelligent Systems XIX (ES2002)},
	Month = {dec},
	Publisher = {Springer Verlag},
	Series = {BCS Conference Series},
	Title = {OO Analysis Patterns as UML Metalevel Collaborations},
	Year = {2002}}

@article{Marr14a,
	Abstract = {Research on language implementation techniques has regained importance with the rise of domain-specific languages (DSLs). Although DSLs can help manage a domain's complexity, building highly optimizing compilers or virtual machines is rarely affordable. So, performance remains an issue. Ideally, you would implement a simple interpreter and still be able to achieve acceptable performance. RPython and Truffle are implementation techniques based on simple interpreters; they promise to perform at the same order of magnitude as highly optimizing virtual machines. This case study compares the two techniques to identify their similarities, weaknesses, and areas for further research.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Marr, Stefan and Pape, Tobias and De Meuter, Wolfgang},
	Day = {15},
	Doi = {10.1109/MS.2014.98},
	Hal-Id = {hal-01066793},
	Impactfactor = {Impact factor (2013) 1.230},
	Inria = {RMOD},
	Issn = {0740-7459},
	Journal = {IEEE Software},
	Keywords = {lse-pub},
	Month = {sep},
	Number = {5},
	Numpages = {8},
	Pages = {60--67},
	Timestamp = {2014-07-16T16:25:23.000+0200},
	Title = {Are We There Yet? Simple Language Implementation Techniques for the 21st Century},
	Url = {http://rmod.inria.fr/archives/papers/Marr14a-IEEESoft-Are-We-There-Yet.pdf},
	Volume = {31},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
  Year = {2014}}



@inproceedings{Marr15a,
  abstract = {Runtime metaprogramming enables many useful applications and is often a convenient solution to solve problems in a generic way, which makes it widely used in frameworks, middleware, and domain-specific languages. However, powerful metaobject protocols are rarely supported and even common concepts such as reflective method invocation or dynamic proxies are not optimized. Solutions proposed in literature either restrict the metaprogramming capabilities or require application or library developers to apply performance improving techniques. For overhead-free runtime metaprogramming, we demonstrate that dispatch chains, a generalized form of polymorphic inline caches common to self-optimizing interpreters, are a simple optimization at the language-implementation level. Our evaluation with self-optimizing interpreters shows that unrestricted metaobject protocols can be realized for the first time without runtime overhead, and that this optimization is applicable for just-in-time compilation of interpreters based on meta-tracing as well as partial evaluation. In this context, we also demonstrate that optimizing common reflective operations can lead to significant performance improvements for existing applications.},
  author = {Marr, Stefan and Seaton, Chris and Ducasse, St\'ephane},
  booktitle = {PLDI - Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  numpages = {10},
  pdf = {http://stefan-marr.de/downloads/pldi15-marr-et-al-zero-overhead-metaprogramming.pdf},
  publisher = {ACM},
  series = {PLDI '15},
  title = {Zero-Overhead Metaprogramming: Reflection and Metaobject Protocols Fast and without Compromises},
  year = {2015},
  Aeres = {ACT},
  Annote = {topconference},
  Keywords = {lse-pub kzLanguageDesign kzClutter stefPub},
  Hal-Id = {hal-01141135},
  Inria = {RMOD},
  doi = {10.1145/2737924.2737963},
  Inriareport = {2015},
  Keywords = {lse-pub stefanmarr},
  Month = {jun},
  Peer = {yes},
  Url = {http://rmod.inria.fr/archives/papers/Marr15a-PLDI15-ZeroOverheadMetaprogramming.pdf},
  X-Editorial-Board = {yes},
  X-International-Audience = {yes},
  X-Proceedings = {yes}
}

@inproceedings{Marr15b,
  abstract = {Tracing and partial evaluation have been proposed as meta-compilation techniques for interpreters to make just-in-time compilation language-independent. They promise that programs executing on simple interpreters can reach performance of the same order of magnitude as if they would be executed on state-of-the-art virtual machines with highly optimizing just-in-time compilers built for a specific language. Tracing and partial evaluation approach this meta-compilation from two ends of a spectrum, resulting in different sets of tradeoffs.
This study investigates both approaches in the context of self-optimizing interpreters, a technique for building fast abstract-syntax-tree interpreters. Based on RPython for tracing and Truffle for partial evaluation, we assess the two approaches by comparing the impact of various optimizations on the performance of an interpreter for SOM, an object- oriented dynamically-typed language. The goal is to determine whether either approach yields clear performance or engineering benefits. We find that tracing and partial evaluation both reach roughly the same level of performance. SOM based on meta-tracing is on average 3x slower than Java, while SOM based on partial evaluation is on average 2.3x slower than Java. With respect to the engineering, tracing has however significant benefits, because it requires language implementers to apply fewer optimizations to reach the same level of performance.},
  author = {Marr, Stefan and Ducasse, St\'ephane},
  booktitle = {OOPSLA'2015},
  note = {(to appear)},
  numpages = {10},
  pdf = {http://rmod.inria.fr/archives/papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  publisher = {ACM},
  series = {OOPSLA'15},
  title = {Tracing vs. Partial Evaluation: Comparing Meta-Compilation Approaches for Self-Optimizing Interpreters},
  year = {2015},
  Aeres = {ACT},
  Annote = {topconference},
  Keywords = {lse-pub kzLanguageDesign stefPub},
  Hal-Id = {hal-01205345},
  Inria = {RMOD},
  Inriareport = {2015},
  Keywords = {lse-pub stefanmarr},
  Month = {jun},
  Peer = {yes},
  Url = {http://rmod.inria.fr/archives/papers/Marr15b-Official-Oopsla15-TracingVSPartial.pdf},
  X-Editorial-Board = {yes},
  X-International-Audience = {yes},
  X-Proceedings = {yes}
}

@inproceedings{Mart10a,
	Abstract = {Most of the current garbage collector implementations work by reachability. This means they only take care of the objects that nobody else points to. As a consequence, there are objects which are not really used but are not garbage collected because they are still referenced. Such unused but reachable objects create memory leaks. This is a problem because applications use much more memory than what is actually needed. In addition, they may get slower and crash. It is important to understand which parts of the system are instantiated but also which are used or unused. There is a plethora of work on runtime information or class instantiation visualizations but none of them show whether instances are actually used. Such information is important to identify memory leaks.
In this paper, we present some visualizations that show used/unused objects in object-oriented applications. For this, we use Distribution Map which is a visualization showing spread and focus of properties across systems. We extend Distribution Maps to represent the way classes are used or not, since we distinguish between a class that just has instances from one that has used instances. To identify unused objects, we modified the Pharo Virtual Machine.},
	Address = {Concepci\'on del Uruguay, Argentina},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
	Booktitle = {Smalltalks 2010},
	Hal-Id = {inria-00531510},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {moose stefPub lse-pub marcusdenker pharo pharo-pub kzVisualization kzClutter},
	Title = {Visualizing Objects and Memory Usage},
	Url = {http://rmod.inria.fr/archives/workshops/Mart10a-Smalltalks2010-VisualizingUnusedObjects.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Mart10b,
	Abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running. Graph exporting and swapping are two important object graph operations. Exporting refers to copying the graph to some other memory so that it can be loaded by another system. Swapping refers to moving the graph to a secondary memory (e.g., a hard disk) to temporary release part of the primary memory.
While exporting and swapping are achieved in different ways, each of them faces a common and central problem which is the speed of the approach in presence of large object graphs. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with extremely common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph. This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present most of the general problems of object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk. However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
	Address = {Concepci\'on del Uruguay, Argentina},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
	Booktitle = {Smalltalks 2010},
	Hal-Id = {inria-00531565},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {stefPub lse-pub marcusdenker pharo pharo-pub kzClutter},
	Title = {Experiments with a Fast Object Swapper},
	Url = {http://rmod.inria.fr/archives/workshops/Mart10b-Smalltalks2010-Swapper-ImageSegments.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Mart11a,
	Abstract = {A proxy object is a surrogate or placeholder that controls access to another target object.  Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-languages communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but they are unable to create proxies for classes or methods. Proxies can be complex to install, have a significant overhead, be limited to certain type of classes, etc. Moreover, most proxy implementations are not stratified at all and there is no separation between proxies and handlers. In this paper, we present Ghost, a uniform, light-weight and stratified general purpose proxy model and its Smalltalk implementation.Ghost supports proxies for classes or methods. When a proxy takes the place of a class it intercepts both, messages received by the class and lookup of methods for messages received by instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too.},
	Address = {Edinburgh, Scotland},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST'11)},
	Doi = {10.1145/2166929.2166937},
	Hal-Id = {inria-00614720},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzLanguageDesign kzClutter},
	Labo = {dans},
	Selectif = {non},
	Title = {Efficient Proxies in {Smalltalk}},
	Url = {http://rmod.inria.fr/archives/workshops/Mart11a-IWST11-Ghost.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}



@inproceedings{Mart11b,
	Abstract = {Large object-oriented applications  may occupy hundreds of megabytes or even gigabytes of memory. During program execution, a large graph of objects is created and constantly changed.
Most object runtimes support some kind of automatic memory  management based on garbage collectors (GC) whose idea is the automatic destruction of unreferenced objects. However, there are referenced objects which are not used for a long period of time or that are used just once. These are not garbage-collected because they are still reachable and might be used in the future. Due to these unused objects, applications use much more resources than they actually need.
In this paper we present the challenges and possible approaches towards an unused object manager for Pharo. The goal is to use less memory by swapping out the unused objects to secondary memory and only leaving in primary memory only those objects which are needed and used. When one of the unused objects is needed, it is brought back into primary memory.},
	Address = {Bernal, Buenos Aires, Argentina},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Martinez Peck, Mariano and Noury Bouraqadi and Marcus Denker and St\'ephane Ducasse and Luc Fabresse},
	Booktitle = {Proceedings of Smalltalks 2011 International Workshop},
	Hal-Id = {inria-00635793},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter},
	Labo = {dans},
	Selectif = {non},
	Title = {Problems and Challenges when Building a Manager for Unused Objects},
	Url = {http://rmod.inria.fr/archives/workshops/Mart11b-Smalltalks2011-UOM.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@article{Mart11c,
	Abstract = {In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running.
Graph exporting and swapping are two important object graph operations.
Exporting refers to copying the graph to some other memory so that it can be loaded by another system.
Swapping refers to moving the graph to a secondary memory (for example, a hard disk) to  temporary release part of the primary memory (for example, RAM).
Exporting and swapping are achieved in different ways and the speed in presence of large object graphs is critical. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with  common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph.  This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc.
In this paper, we present all general problems to our knowledge about object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Dan Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk.
However, ImageSegment is not a panacea since it still has other problems that hampers its general use.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Martinez Peck, Mariano and Noury Bouraqadi and St\'ephane Ducasse and Luc Fabresse},
	Doi = {10.1016/j.cl.2011.10.001},
	Hal-Id = {hal-00646897},
	Impactfactor = {Impact factor (2010) 0.541},
	Inria = {RMOD},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzClutter},
	Labo = {dans},
	Month = {nov},
	Number = {1},
	Pages = {1--15},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Selectif = {non},
	Title = {Object Swapping Challenges: an Evaluation of {ImageSegment}},
	Url = {http://rmod.inria.fr/archives/papers/Mart11c-COMLAN-ObjectSwapping.pdf},
	Volume = {38},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
  Year = {2011}}

@phdthesis{Mart12d,
	Abstract = {During the execution of object-oriented applications, several millions of objects are created, used and then collected if they are not referenced. Problems appear when objects are unused but cannot be garbage-collected because they are still referenced from other objects. This is an issue because those objects waste primary memory and applications use more primary memory than what they actually need. We claim that relying on operating systems (OS) virtual memory is not always enough since it is completely transparent to applications. The OS cannot take into account the domain and structure of applications. At the same time, applications have no easy way to control nor influence memory management.
In this dissertation, we present Marea, an efficient application-level virtual memory for object-oriented programming languages. Its main goal is to offer the programmer a novel solution to handle application- level memory. Developers can instruct our system to release primary memory by swapping out unused yet referenced objects to secondary memory.
Marea is designed to: 1) save as much memory as possible i.e., the memory used by its infrastructure is minimal compared to the amount of memory released by swapping out unused objects, 2) minimize the runtime overhead i.e., the swapping process is fast enough to avoid slowing down primary computations of applications, and 3) allow the programmer to control or influence the objects to swap.
Besides describing the model and the algorithms behind Marea, we also present our implementation in the Pharo programming language. Our approach has been qualitatively and quantitatively validated. Our experiments and benchmarks on real-world applications show that Marea can reduce the memory footprint between 25\% and 40\%.},
	Annote = {PhD},
	Author = {Martinez Peck, Mariano},
	Hal-Id = {tel-00764991},
	Inria = {RMOD},
	Institution = {INRIA},
	Keywords = {lse-pub pharo pharo-pub},
	Month = oct,
	School = {Ecole des Mines de Douai - France \& Universit\'{e} Lille 1 - France},
	Title = {Application-Level Virtual Memory for Object-Oriented Systems},
	Url = {http://tel.archives-ouvertes.fr/docs/00/76/49/91/PDF/PhD\_-\_Mariano\_Martinez\_Peck.pdf},
	UrlArchived = {http://rmod.inria.fr/archives/phd/PhD-2012-Martinez-Peck.pdf},
	X-Language = {EN},
	Year = {2012}}

@article{Mart13a,
	Abstract = {Abstract During the execution of object-oriented
                  applications, several millions of objects are
                  created, used and then collected if they are not
                  referenced. Problems appear when objects are unused
                  but cannot be garbage-collected because they are
                  still referenced from other objects. This is an
                  issue because those objects waste primary memory and
                  applications use more primary memory than they
                  actually need. We claim that relying on the
                  operating system's (OS) virtual memory is not always
                  enough since it cannot take into account the domain
                  and structure of applications. At the same time,
                  applications have no easy way to parametrize nor
                  cooperate with memory management. In this paper, we
                  present Marea, an efficient application-level object
                  graph swapper for object-oriented programming
                  languages. Its main goal is to offer the programmer
                  a novel solution to handle application-level memory.
                  Developers can instruct our system to release
                  primary memory by swapping out unused yet referenced
                  objects to secondary memory. Our approach has been
                  qualitatively and quantitatively validated. Our
                  experiments and benchmarks on real-world
                  applications show that Marea can reduce the memory
                  footprint between 23\% and 36\%.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Mariano Martinez Peck and Noury Bouraqadi and Marcus Denker and St\'{e}phane Ducasse and Luc Fabresse},
	Doi = {10.5381/jot.2013.12.1.a2},
	Hal-Id = {hal-00781129},
	Journal = {Journal of Object Technology},
	Keywords = {pharo-pub lse-pub kzClutter pharo},
	Labo = {dans},
	Month = {jan},
	Number = {1},
	Pages = {2:1-30},
	Peerreview = {yes},
	Selectif = {oui},
	Title = {Marea: An Efficient Application-Level Object Graph Swapper},
	Url = {http://rmod.inria.fr/archives/papers/Mart12c-JOT-Marea.pdf},
	Volume = {12},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
  Year = {2013}}

@article{Mart14z,
	Abstract = {A proxy object is a surrogate or placeholder that controls access to another target object. Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-languages communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but are unable to create proxies for objects with an important role in the runtime infrastructure such as classes or methods. Proxies can be complex to install, they can have a significant overhead, they can be limited to certain kind of classes, etc. Moreover, proxy implementations are often not stratified and they do not have a clear separation between proxies (the objects intercepting messages) and handlers (the objects handling interceptions). In this paper, we present Ghost: a uniform and general-purpose proxy implementation for the Pharo programming language. Ghost provides low memory consuming proxies for regular objects as well as for classes and methods.
When a proxy takes the place of a class, it intercepts both the messages received by the class and the lookup of methods for messages received by its instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Mariano Martinez Peck and Noury Bouraqadi and Luc Fabresse and Marcus Denker and Camille Teruel},
	Hal-Id = {hal-01081236},
	Journal = {Journal of Object Technology},
	Pages = {339-359},
	Volume = {98},
	Issue = {3},
	Doi = {10.1016/j.scico.2014.05.015},
	Keywords = {pharo-pub lse-pub kzDesign pharo},
	Peerreview = {yes},
	Selectif = {oui},
	Title = {Ghost: A Uniform and General-Purpose Proxy Implementation},
	Url = {http://rmod.inria.fr/archives/papers/Mart14z-Ghost-Final.pdf},
	X-Language = {EN},
  Year = {2015}}


@inproceedings{Mend13,
	Annote = {internationalworkshop},
	Author = {David Mendez Acuna and Rubby Casallas and Anne Etien},
	Booktitle = {Proceedings of the International Workshop on Domain Specific Modeling},
	Inria = {RMOD},
	Institution = {INRIA},
	Title = {On the customization of model management systems for file-centric IDEs},
	Year = {2013}}

@inproceedings{Mens05a,
	Acceptnum = {13},
	Accepttotal = {54},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalworkshop},
	Author = {Tom Mens and Michel Wermelinger and St\'ephane Ducasse and Serge Demeyer and Robert Hirschfeld and Mehdi Jazayeri},
	Booktitle = {Proceedings of the International Workshop on Principles of Software Evolution (IWPSE 2005)},
	Inria = {hors},
	Keywords = {stefPub scgPub kzPattern},
	Misc = {acceptance rate: 13/54 = 24\%},
	Pages = {123--131},
	Publisher = {IEEE Computer Society},
	Rate = {24\%},
	Selectif = {oui},
	Title = {Challenges in Software Evolution},
	Year = {2005}}

@inproceedings{Minj05a,
	Abstract = {The trait model is complementary to class
                  inheritance and allows collections of methods to be
                  reused by several classes. The classbox model allows
                  a collection of classes to be locally extended with
                  variables and/or methods addition. This paper
                  describes a symbiosis of these two models: classes
                  can be locally extended by using a trait. It is
                  illustrated by an efficient implementation of the
                  collaboration model where a collaboration is
                  represented by a classbox and a role by a trait.},
	Address = {Bern, Switzerland},
	Aeres = {ACL},
	Annote = {nationalconference},
	Author = {Florian Minjat and Alexandre Bergel and Pierre Cointe and St\'ephane Ducasse},
	Booktitle = {Actes de Langages et Mod\`eles \`a Objets (LMO'05)},
	Inria = {hors},
	Keywords = {traits classbox scg-pub skip-doi scg stefPub alexPub noWorkshop kzTrait kzClassbox},
	Pages = {33--46},
	Selectif = {non},
	Title = {Mise en symbiose des traits et des classboxes : Application \`a l'expression des collaborations},
	Url = {http://scg.unibe.ch/archive/papers/Minj05a-TraitClassbox.pdf},
	Volume = {11},
  Year = {2005}}

@inproceedings{Mord09a,
	Abstract = {ISO 9126 promotes a three-level model of quality (factors, criteria, and metrics) which allows one to assess quality at the top level of factors and criteria. However, it is difficult to use this model as a tool to increase software quality. In the Squale model, we add practices as an intermediate level between metrics and criteria. Practices abstract away from raw information (metrics, tool reports, audits) and provide technical guidelines to respect. Moreover, practice marks are adjusted using formulae to suit company development habits or exigences: for example bad marks are stressed to point to places which need more attention. The Squale model has been developed and validated over the last couple of years in an industrial setting with Air France-KLM and PSA Peugeot-Citroen.},
	Address = {Edmonton, Canada},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Karine Mordal-Manet and Fran\c{c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
	Booktitle = {Proceedings of the 25th IEEE International Conference on Software Maintenance (ICSM'09)},
	Hal = {inria-00637364},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose kzMetric},
	Labo = {dans},
	Misc = {(short paper) acceptance rate: 35(+29)/162: 21(40)\% for short papers},
	Pages = {94--103},
	Rate = {40\%},
	Selectif = {oui},
	Title = {The Squale Model -- A Practice-based Industrial Quality Model},
	Url = {http://rmod.inria.fr/archives/papers/Mord09a-ICSM2009-SqualeModel.pdf},
	Year = {2009}}

@techreport{Mord09b,
	Abstract = {ISO 9126 promotes a three-level model of quality (factors, criteria, and metrics) which allows one to assess quality at the top level of factors and criteria. However, it is dif- ficult to use this model as a tool to increase software quality. In the Squale model, we propose the adjunction of practices as an intermediate level between metrics and criteria. Practices abstract from raw information at the source (metrics, tool reports, audits) to provide the developer with technical guidelines to respect. Moreover, practice marks can be adjusted using formulae to suit company development habits or exigences: for example bad marks can be stressed to point to places which need the most attention. Dashboards allow one to spot faulty practices and find the source elements responsible for the bad marks. The Squale model has been developed and validated over the last couple of years in an industrial setting with Air France-KML and PSA Peugeot-Citroen. Over 100 projects with a total of more than seven millions lines of code have been assessed and steered using Squale.},
	Annote = {technicalReport stefPub},
	Author = {Karine Mordal-Manet and Fran\c{c}oise Balmas and Simon Denier and St\'ephane Ducasse and Harald Wertz and Jannik Laval and Fabrice Bellingard and Philippe Vaillergues},
	Hal = {inria-00637363},
	Inria = {RMOD},
	Inriareport = {2009},
	Institution = {INRIA Lille Nord Europe},
	Keywords = {squale-pub lse-pub kzMetric},
	Title = {The Squale Model -- A \emph{Practice-}based Industrial Quality Model},
	Url = {http://rmod.inria.fr/archives/reports/Mord09b-TechReport-Squale.pdf},
	Year = {2009}}

@inproceedings{Mord11a,
	Abstract = {It is now understood that software metrics alone are not enough to characterize software quality. To cope with this problem, most of advanced and/or industrially validated quality models aggregate software metrics: for example, cyclomatic complexity is combined with test coverage to stress the fact that it is more important to cover complex methods than accessors. Yet, aggregating and weighting metrics to produce quality indexes is a difficult task. Indeed certain weighting approaches may lead to abnormal situations where a developer increasing the quality of a software component sees the overall quality degrade. Finally, mapping combinations of metric values to quality indexes may be a problem when using thresholds. In this paper, we present the problems we faced when designing the Squale quality model, then we present an empirical solution based on weighted aggregations and on continuous functions. The solution has been termed the Squale quality model and validated over 4 years with two large multinational companies: Air France-KLM and PSA Peugeot-Citroen.},
	Address = {Oldenburg, Germany},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Karine Mordal-Manet and Jannik Laval and St\'ephane Ducasse and Nicolas Anquetil and Fran\c{c}oise Balmas and Fabrice Bellingard and Laurent Bouhier and Philippe Vaillergues and Thomas J. McCabe},
	Booktitle = {Proceedings of the 15th European Conference on Software Maintenance and Reengineering (CSMR'11)},
	Hal = {inria-00637367},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {moose lse-pub squale raweb2011 kzMetric},
	Labo = {dans},
	Misc = {acceptance rate: 29/82 = 35\%},
	Pages = {141--150},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Title = {An empirical model for continuous and weighted metric aggregation},
	Url = {http://rmod.inria.fr/archives/papers/Mord11a-CSMR2011-Squale.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {US},
	X-Proceedings = {yes},
  Year = {2011}}

@article{Mord13a,
	Aeres = {ACL},
	Aeresstatus = {aeres13},
	Annote = {internationaljournal},
	Author = {Karine Mordal{-}Manet and Nicolas Anquetil and Jannik Laval and Alexander Serebrenik and Bogdan Vasilescu and St{\'{e}}phane Ducasse},
	Doi = {10.1002/smr.1558},
	Impactfactor = {Impact Factor (2013) 0.442},
	Journal = {Journal of Software: Evolution and Process},
	Labo = {dans},
	Number = {10},
	Pages = {1117--1135},
	Tagnicolasa = {metric},
	Title = {Software quality metrics aggregation in industry},
	Url = {http://rmod.inria.fr/archives/papers/Mord12b-Official-JSoft-MetricAggregation.pdf},
	Volume = {25},
  Year = {2013}}

@incollection{Mord14a,
	Aeres = {ACL},
	Aeresstatus = {aeres14},
	Annote = {articlebook},
	Author = {Karine Mordal and Jannik Laval and St\'ephane Ducasse},
	Booktitle = {Evolution et R\'enovation des Syst\`emes Logiciels},
	Ean13 = {9782746245549},
	Inriareport = {2014},
	Keywords = {moose lse-pub kzMetric},
	Labo = {dans},
	Peerreview = {yes},
	Publisher = {Herm\`es},
	Selectif = {oui},
	Title = {Mod\`eles de mesure de la qualit\'e des logiciels},
	Url = {http://rmod.inria.fr/archive/papers/Mord14a-Chapitrequalite.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {EN},
  Year = {2014}}

@inproceedings{Moug03a,
	Abstract = {Array programming shines in its ability to express
                  computations at a high-level of abstraction,
                  allowing one to manipulate and query whole sets of
                  data at once. This paper presents the OPA model that
                  enhances object-oriented programming with array
                  programming features. The goal of OPA is to
                  determine a minimum set of modifications that must
                  be made to the traditional object model in order to
                  take advantage of the possibilities of array
                  programming. It is based on a minimal extension of
                  method invocation and the definition of a kernel of
                  methods implementing fundamental array programming
                  operations. The OPA model presents a generalization
                  of traditional message passing in the sense that a
                  message can be send to an entire set of objects. The
                  model is validated in FS, a new scripting language.},
	Acceptnum = {26},
	Accepttotal = {142},
	Annote = {internationalconference topconference},
	Author = {Philippe Mougin and St\'ephane Ducasse},
	Booktitle = {Proceedings of 17th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'03)},
	Doi = {10.1145/949305.949312},
	Keywords = {snf04 scg-pub jb04 stefPub kzMessaging kzLanguageDesign},
	Misc = {acceptance rate: 26/142 = 18\%},
	Month = oct,
	Pages = {65--77},
	Title = {{OOPAL}: Integrating Array Programming in Object-Oriented Programming},
	Url = {http://scg.unibe.ch/archive/papers/Moug03aOOPALOOPSLA.pdf},
  Year = {2003}}

@misc{Mull05c,
	Address = {Montego Bay, Jamaica},
	Annote = {internationalworkshop},
	Author = {Muller, Pierre-Alain and Fleurey, Franck and Vojtisek, Didier and Drey, Zo\'e and Pollet, Damien and Fondement, Fr\'ed\'eric and Studer, Philippe and J\'ez\'equel, Jean-Marc},
	Howpublished = {Model Transformations In Practice Workshop},
	Month = {oct},
	Title = {On Executable Meta-Languages applied to Model Transformations},
	Year = {2005}}

@inproceedings{Nier02a,
	Abstract = {Component-based software development is becoming
                  mainstream for conventional applications. However,
                  components can be difficult to deploy in embedded
                  systems because of non-functional requirements.
                  Pecos is a collaborative project between industrial
                  and research partners that seeks to enable
                  component-based technology for a class of embedded
                  systems known as field devices. In this paper we
                  introduce a component model for field devices that
                  captures a range of non-functional properties and
                  constraints. We report on the current status of
                  Pecos, including the Pecos composition language,
                  language mappings to {Java} and C\+\+, and industrial
                  case studies.},
	Address = {Berlin, Germany},
	Annote = {internationalconference},
	Author = {Oscar Nierstrasz and Gabriela Ar{\'e}valo and St{\'e}phane Ducasse and Roel Wuyts and Andrew Black and Peter M{\"u}ller and Christian Zeidler and Thomas Genssler and Reinier van den Born},
	Booktitle = {Proceedings First International IFIP/ACM Working Conference on Component Deployment},
	Keywords = {scg-pub skip-doi jb02 pecos stefPub arevalo kzComponent},
	Month = jun,
	Pages = {200--209},
	Publisher = {ACM},
	Title = {A Component Model for Field Devices},
	Url = {http://scg.unibe.ch/archive/papers/Nier02aPecosModel.pdf},
  Year = {2002}}

@article{Nier04c,
	Abstract = {Aging software systems are difficult and expensive
                  to maintain. Moose is a language-independent
                  environment that supports a wide range of tools to
                  visualise, analyse and manipulate complex software
                  systems.},
	Annote = {notrefereed},
  Author = {Oscar Nierstrasz and St\'ephane Ducasse},
	Journal = {European Research Consortium for Informatics and Mathematics (ERCIM) News},
	Keywords = {scg-pub skip-doi jb04 stefPub recast04 moose kzMoose KzTool},
	Month = jul,
	Pages = {24--25},
	Title = {Moose--a Language-Independent Reengineering Environment},
	Url = {http://www.ercim.org/publication/Ercim\_News/enw58/nierstrasz.html},
	Volume = {58},
  Year = {2004}}

@inproceedings{Nier04d,
	Abstract = {In this paper we briefly review various kinds of
                  software changes and the issues that arise from
                  them. As a consequence, we propose research into
                  programming languages with explicit support for
                  representing first-class changes, and for
                  manipulating and merging multiple viewpoints of
                  evolving software systems.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Marcus Denker},
	Booktitle = {OOPSLA Workshop on Revival of Dynamic Languages},
	Cvs = {RDLchange},
	Keywords = {snf05 scg-pub skip-doi fromscgbib marcusdenker},
	Month = oct,
	Title = {Supporting Software Change in the Programming Language},
	Url = {http://rmod.inria.fr/archives/workshops/Nier04d-RDL04-Change.pdf},
  Year = {2004}}

@inproceedings{Nier05b,
	Abstract = {The programming languages of today are stuck in a
                  deep rut that has developed over the past 50 years.
                  Although we are faced with new challenges posed by
                  enormous advances in hardware and internet
                  technology, we continue to struggle with
                  old-fashioned languages based on rigid, static,
                  closed-world file-based views of programming. We
                  argue the need for a new class of dynamic languages
                  that support a view of programming as constant
                  evolution of living and open software models. Such
                  languages would require features such as dynamic
                  first-class namespaces, explicit meta-models,
                  optional, pluggable type systems, and incremental
                  compilation of running software systems.},
	Aeres = {INV},
	Annote = {invited},
  Author = {Oscar Nierstrasz and Alexandre Bergel and Marcus Denker and St\'ephane Ducasse and Markus Gaelli and Roel Wuyts},
	Booktitle = {Proceedings of Software Composition 2005},
	Cvs = {SC05Revival},
	Doi = {10.1007/11550679\_1},
	Editor = {Thomas Gschwind and Uwe A{\ss}mann},
	Inria = {hors},
	Isbn = {3-540-28748-5},
	Keywords = {scg-pub kzLanguageDesign},
	Misc = {gaelli},
	Note = {Invited paper},
	Pages = {1--13},
	Publisher = {LNCS 3628},
	Title = {On the Revival of Dynamic Languages},
	Url = {http://rmod.inria.fr/archives/papers/Nier05b-SC05-Revival.pdf},
	Volume = {3628},
  Year = {2005}}

@inproceedings{Nier05c,
	Abstract = {Moose is a language-independent environment for
                  reverse- and re-engineering complex software
                  systems. Moose provides a set of services including
                  a common meta-model, metrics evaluation and
                  visualization, a model repository, and generic GUI
                  support for querying, browsing and grouping. The
                  development effort invested in Moose has paid off in
                  precisely those research activities that benefit
                  from applying a combination of complementary
                  techniques. We describe how Moose has evolved over
                  the years, we draw a number of lessons learned from
                  our experience, and we outline the present and
                  future of Moose.},
	Address = {New York NY},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Tudor G\^irba},
	Booktitle = {Proceedings of the European Software Engineering Conference},
	Cvs = {MOOSE-ESEC05},
	Doi = {10.1145/1095430.1081707},
	Editor = {Michel Wermelinger and Harald Gall},
	Inria = {hors},
	Isbn = {1-59593-014-0},
	Keywords = {girba stefPub recast06 scg-pub moose kzMoose kzTool},
	Note = {Invited paper},
	Pages = {1--10},
	Publisher = {ACM Press},
	Series = {ESEC/FSE'05},
	Title = {The Story of {Moose}: an Agile Reengineering Environment},
	Url = {http://scg.unibe.ch/archive/papers/Nier05cStoryOfMoose.pdf},
  Year = {2005}}

@inproceedings{Nier05d,
	Abstract = {Successful software systems must be prepared to
                  evolve or they will die. Although object-oriented
                  software systems are built to last, over time they
                  degrade as much as any legacy software system. As a
                  consequence, one must invest in reengineering
                  efforts to keep further development costs down. Even
                  though software systems and their business contexts
                  may differ in countless ways, the techniques one
                  uses to understand, analyze and transform these
                  systems tend to be very similar. As a consequence,
                  one may identify various reengineering patterns that
                  capture best practice in reverse- and re-engineering
                  object-oriented legacy systems. We present a brief
                  outline of a large collection of these patterns that
                  have been mined over several years of experience
                  with object-oriented legacy systems, and we indicate
                  how some of these patterns can be supported by
                  appropriate tools.},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
  Author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings of Generative Programming and Component Engineering (GPCE 2005)},
	Cvs = {GPCE05ReengPatterns},
	Doi = {10.1007/11561347\_1},
	Editor = {Robert Gl\"uck, Michael Lowry},
	Inria = {hors},
	Isbn = {3-540-29138-5},
	Keywords = {stefPub recast06 scg-pub jb06 kzPattern},
	Note = {Invited paper},
	Pages = {1--9},
	Publisher = {LNCS 3676},
	Title = {Object-oriented Reengineering Patterns --- an Overview},
	Url = {http://scg.unibe.ch/archive/papers/Nier05dReengineeringPatterns.pdf},
  Year = {2005}}

@techreport{Nier05e,
	Abstract = {Traits are fine-grained components that can be used
                  to compose classes, while avoiding many of the
                  problems of multiple inheritance and mixin-based
                  approaches. Since most implementations of traits
                  have focused on dynamically-typed languages, the
                  question naturally arises, how can one best
                  introduce traits to statically-typed languages, like
                  {Java} and C#? In this paper we argue that the
                  flattening property of traits should be used as a
                  guiding principle for any attempt to add traits to
                  statically-typed languages. This property
                  essentially states that, semantically, traits can be
                  compiled away. We demonstrate how this principle
                  applies to FTJ, a conservative extension to
                  Featherweight {Java}.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
	Cvs = {TraitFlatteningTR},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub skip-doi scg-rotor traits jb06 snf05 jot stefPub kzTrait},
	Month = apr,
	Number = {IAM-05-005},
	Title = {Flattening {Traits}},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier05eFlatteningTraitsTR.pdf},
  Year = {2005}}

@article{Nier05f,
	Abstract = {Erfolgreiche Softwaresysteme m\"ussen so konzipiert
                  sein, dass sie sich weiterentwickeln k\"onnen ---
                  ansonsten gehen sie ein. Obwohl objektorientierte
                  Softwaresysteme auf eine lange Lebensda\"ur
                  ausgerichtet sind, veralten sie \"uber die Jahre
                  genauso wie jedes andere Legacy-Softwaresystem. Um
                  die weiteren Entwicklungskosten niedrig zu halten,
                  m\"ussen daher Investitionen im Bereich \
                  Re-Engineering get\"atigt werden. Softwaresysteme
                  und der Gesch\"aftskontext, in dem sie eingesetzt
                  werden, unterscheiden sich in vielen Punkten ---
                  dennoch \"ahneln sich Techniken, sie zu verstehen,
                  zu analysieren und zu transformieren. Folglich
                  lassen sich verschiedene Re-Engineering-Muster
                  identifizieren, die bew\"ahrte Vorgehensweisen beim
                  Reverse- und Re-Engineering objektorientierter
                  Legacy-Systeme beinhalten. Dieser Artikel stellt
                  einen kleinen Ausschnitt aus einer gr\"on Sammlung
                  dieser Muster vor, die auf der mehrj\"ahrigen
                  Erfahrung mit objektorientierten Legacy-Systemen
                  basieren. Dar\"uber hinaus werden Hinweise gegeben,
                  wie einige dieser Muster durch geeignete Werkzeuge
                  unterst\"utzt werden k\"onnen.},
	Aeres = {INV},
	Aeresstatus = {aeres08},
	Annote = {invited},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Serge Demeyer},
	Inria = {hors},
	Journal = {ObjektSpektrum},
	Keywords = {stefPub recast06 scg-pub skip-doi kzPattern},
	Note = {German translation of ``Object-oriented Reengineering Patterns --- an Overview'' (GPCE 05)},
	Number = {6},
	Pages = {46--51},
	Title = {Objektorientierte Re-Engineering-Muster: ein \"{U}berblick},
	Url = {http://scg.unibe.ch/archive/papers/Nier05fOORM.pdf},
	Volume = {2005},
  Year = {2005}}

@techreport{Nier05g,
	Abstract = {Traits offer a fine-grained mechanism for composing
                  classes in object-oriented languages from reusable
                  components, while avoiding the fragility problems
                  introduced by multiple inheritance and mixins.
                  Although traits were developed in the context of
                  dynamically typed languages, they would also offer
                  clear benefits for statically typed languages like
                  Java and C\#. This report summarizes the issues
                  raised when integrating traits into such languages.
                  We examine traits in the context of the statically
                  typed languages FeatherweightJava, C\# and C\+\+.},
	Address = {Universit\"at Bern, Switzerland},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Stefan Reichhart and Nathanael Sch\"arli},
	Cvs = {TraitsCSharp},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub skip-doi scg-rotor traits stefPub kzTrait},
	Month = dec,
	Number = {IAM-05-006},
	Title = {Adding {Traits} to (Statically Typed) Languages},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Nier05gTraitsCSharp.pdf},
  Year = {2005}}

@article{Nier06a,
	Abstract = {Traits are fine-grained components that can be used
                  to compose classes, while avoiding many of the
                  problems of multiple inheritance and mixin-based
                  approaches. Since most implementations of traits
                  have focused on dynamically-typed languages, the
                  question naturally arises, how can one best
                  introduce traits to statically-typed languages, like
                  {Java} and C#? In this paper we argue that the
                  flattening property of traits should be used as a
                  guiding principle for any attempt to add traits to
                  statically-typed languages. This property
                  essentially states that, semantically, traits can be
                  compiled away. We demonstrate how this principle
                  applies to FTJ, a conservative extension to
                  Featherweight {Java}.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Oscar Nierstrasz and St\'ephane Ducasse and Nathanael Sch\"arli},
	Cached = {http://scg.unibe.ch/archive/papers/Nier06aFlatteningTraits.pdf},
	Cvs = {TraitFlatteningJOT},
	Inria = {hors},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub skip-doi scg-rotor traits jot stefPub kzTrait},
	Medium = {2},
	Misc = {May-June},
	Month = may,
	Number = {4},
	Pages = {129--148},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Flattening {Traits}},
	Url = {http://rmod.inria.fr/archives/papers/Nier06aFlatteningTraits.pdf},
	Volume = {5},
  Year = {2006}}

@inproceedings{Nier06b,
	Abstract = {Software systems need to continuously change to
                  remain useful. Change appears in several forms and
                  needs to be accommodated at different levels. We
                  propose ChangeBoxes as a mechanism to encapsulate,
                  manage, analyze and exploit changes to software
                  systems. Our thesis is that only by making change
                  explicit and manipulable can we enable the software
                  developer to manage software change more effectively
                  than is currently possible. Furthermore we argue
                  that we need new insights into assessing the impact
                  of changes and we need to provide new tools and
                  techniques to manage them. We report on the results
                  of some initial prototyping efforts, and we outline
                  a series of research activities that we have started
                  to explore the potential of ChangeBoxes.},
	Annote = {internationalworkshop},
	Author = {Oscar Nierstrasz and Marcus Denker and Tudor G{\^\i}rba and Adrian Lienhard},
	Booktitle = {Proceedings of the Workshop on Revival of Dynamic Languages (co-located with ECOOP'06)},
	Cvs = {RDL06ACTSC},
	Keywords = {girba snf06 scg-pub skip-doi jb06 fb06 fromscgbib marcusdenker},
	Medium = {2},
	Month = jul,
	Peerreview = {yes},
	Title = {Analyzing, Capturing and Taming Software Change},
	Url = {http://rmod.inria.fr/archives//workshops/Nier06b-RDL06-ACTSC.pdf},
  Year = {2006}}

@techreport{Nier08a,
	Abstract = {Few real software systems are built completely from
                  scratch nowadays. Instead, systems are built
                  iteratively and incrementally, while integrating and
                  interacting with components from many other systems.
                  These systems also last longer than their developers
                  might imagine --- they are, in effect, eternal.
                  Nevertheless the platforms, tools and environments
                  we use to develop software are still largely based
                  on an outmoded model that presupposes that software
                  systems are closed and will not significantly evolve
                  after deployment. We claim that in order to enable
                  effective and graceful evolution of eternal systems,
                  we must make them self-aware. A self-aware eternal
                  system supports evolution by: (i) providing
                  explicit, first-class models of software artifacts,
                  change and history at the level of the platform,
                  (ii) continuously analysing static and dynamic
                  evolution to track emergent properties, and (iii)
                  closing the gap between the domain model and the
                  developers' view of the evolving system. We outline
                  our vision of self-aware eternal systems and
                  identify the research challenges to realizing this
                  vision.},
	Annote = {report notrefereed},
	Author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Kuhn and Adrian Lienhard and David R{\"o}thlisberger},
	Institution = {University of Bern, Institute of Applied Mathematics and Computer Sciences},
	Keywords = {scg-pub jb08 snf08 skip-doi girba roethlisberger fromscgbib marcusdenker},
	Number = {IAM-08-001},
	Title = {Self-aware, Evolving Eternal Systems},
	Type = {Technical Report},
	Url = {http://rmod.inria.fr/archives/reports/Nier08a-TechReport-SelfAwareEternal.pdf},
  Year = {2008}}

@incollection{Nier08b,
	Abstract = {Few real software systems are built completely from
                  scratch nowadays. Instead, systems are built
                  iteratively and incrementally, while integrating and
                  interacting with components from many other systems.
                  Adaptation, reconfiguration and evolution are
                  normal, ongoing processes throughout the lifecycle
                  of a software system. Nevertheless the platforms,
                  tools and environments we use to develop software
                  are still largely based on an outmoded model that
                  presupposes that software systems are closed and
                  will not significantly evolve after deployment. We
                  claim that in order to enable effective and graceful
                  evolution of modern software systems, we must make
                  these systems more amenable to change by (i)
                  providing explicit, first-class models of software
                  artifacts, change, and history at the level of the
                  platform, (ii) continuously analysing static and
                  dynamic evolution to track emergent properties, and
                  (iii) closing the gap between the domain model and
                  the developers' view of the evolving system. We
                  outline our vision of dynamic, evolving software
                  systems and identify the research challenges to
                  realizing this vision.},
  Author = {Oscar Nierstrasz and Marcus Denker and Tudor G\^irba and Adrian Lienhard and David R\"othlisberger},
	Booktitle = {Challenges for Software-Intensive Systems and New Computing Paradigms},
	Doi = {10.1007/978-3-540-89437-7\_3},
	Editor = {Martin Wirsing and Jean-Pierre Ban\^atre and Matthias H\"olzl},
	Isbn = {978-3-540-89436-0},
	Keywords = {scg08 scg-pub snf09 jb09 hasler09 girba cop-lit roethlisberger marcusdenker fromscgbib},
	Medium = {2},
	Pages = {64-79},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Change-Enabled Software Systems},
	Url = {http://rmod.inria.fr/archives/papers/Nier08b-bookchapter-ChangeEnabledSoftware.pdf},
	Volume = {5380},
  Year = {2008}}

@incollection{Nier09a,
	Abstract = {Software must be constantly adapted to changing
                  requirements. The time scale, abstraction level and
                  granularity of adaptations may vary from short-term,
                  fine-grained adaptation to long-term, coarse-grained
                  evolution. Fine-grained, dynamic and
                  context-dependent adaptations can be particularly
                  difficult to realize in long-lived, large-scale
                  software systems. We argue that, in order to
                  effectively and efficiently deploy such changes,
                  adaptive applications must be built on an
                  infrastructure that is not just model-driven, but is
                  both model-centric and context-aware. Specifically,
                  this means that high-level, causally-connected
                  models of the application and the software
                  infrastructure itself should be available at
                  run-time, and that changes may need to be scoped to
                  the run-time execution context. We first review the
                  dimensions of software adaptation and evolution, and
                  then we show how model-centric design can address
                  the adaptation needs of a variety of applications
                  that span these dimensions. We demonstrate through
                  concrete examples how model-centric and
                  context-aware designs work at the level of
                  application interface, programming language and
                  runtime. We then propose a research agenda for a
                  model-centric development environment that supports
                  dynamic software adaptation and evolution.},
  Author = {Oscar Nierstrasz and Marcus Denker and Lukas Renggli},
	Booktitle = {Software Engineering for Self-Adaptive Systems},
	Doi = {10.1007/978-3-642-02161-9\_7},
	Editor = {Betty H.C. Cheng and Rogerio de Lemos and Holger Giese and Paola Inverardi and Jeff Magee},
	Keywords = {scg09 scg-pub diesel helvetia reflectivity snf09 jb09 fromscgbib marcusdenker},
	Medium = {2},
	Pages = {128-145},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Model-Centric, Context-Aware Software Adaptation},
	Url = {http://rmod.inria.fr/archives/papers/Nier09a-bookchapter-ModelCentric.pdf},
	Volume = {5525},
  Year = {2009}}

@article{Oliv08a,
	Annote = {internationalconference},
	Author = {de Oliveira, Tito Marcelo Almeida and de Miranda, Marcia Mazo Santos and Papa, Marcos Antonio and Figueiredo, Rejane and Santos, Rildo and Anquetil, Nicolas and Silva, Wander},
	Journal = {International Conference on Information Systems and Technology Management},
	Number = {2008},
	Tagnicolasa = {analysis},
	Title = {Perception on software maintenance: a case study with information technology managers},
	Volume = {5},
	Year = {2008}}

@phdthesis{Pap13a,
	Abstract = {{La construction de logiciels pour des appareils qui ne peuvent pas accueillir localement des outils de d{\'e}veloppement peut {\^e}tre difficile. Ces appareils soit ont une puissance de calcul trop limit{\'e}e pour ex{\'e}cuter un IDE (par exemple, smartphones), ou manquent d' interfaces d'entr{\'e}e / sortie appropri{\'e}es ({\'e}cran, clavier , souris) pour la programmation (par exemple, les robots mobiles) ou sont tout simplement inaccessibles pour des d{\'e}veloppements locaux (par exemple cloud - serveurs). Dans ces situations, les d{\'e}veloppeurs ont besoin d'une infrastructure appropri{\'e}e pour d{\'e}velopper et d{\'e}boguer des applications distantes. Des solutions de d{\'e}bogage {\`a} distance sont parfois d{\'e}licates {\`a} utiliser en raison de leur nature distribu{\'e}e. Les {\'e}tudes empiriques nous montrent que, en moyenne 10,5 minutes par heure de codage (plus de cinq semaines de travail de 40 heures par an) sont pass{\'e}es pour le re-d{\'e}ploiement d'applications pour corriger les bugs ou am{\'e}liorer leur fonctionnalit{\'e} [ZeroTurnAround 2011]. En plus, les solutions courantes manquent des am{\'e}nagements qui seraient autrement disponibles dans un contexte local, car c'est difficile de les reproduire {\`a} distance (par exemple d{\'e}bogage objet-centr{\'e} [Ressia 2012b]). Cet {\'e}tat influe sur la quantit{\'e} d' exp{\'e}rimentation au cours d'une session de d{\'e}bogage {\`a} distance - par rapport {\`a} un contexte local. Dans cette th{\`e}se, afin de surmonter ces probl{\`e}mes, nous identifions d'abord quatre propri{\'e}t{\'e}s d{\'e}sirables qu'une solution id{\'e}ale pour le d{\'e}bogage {\`a} distance doit pr{\'e}senter : l'interactivit{\'e}, l'instrumentation, la distribution et la s{\'e}curit{\'e}. L'interactivit{\'e} est la capacit{\'e} d'une solution de d{\'e}bogage {\`a} distance de mise {\`a} jour incr{\'e}mentale de toutes les parties d'une application sans perdre le contexte de d'ex{\'e}cution (sans arr{\^e}ter l'application). L'instrumentation est l'aptitude d'une solution de modifier la s{\'e}mantique d'un processus en cours en vue d'aider le d{\'e}bogage. La distribution est la capacit{\'e} d'une solution de d{\'e}bogage {\`a} adapter son cadre alors que le d{\'e}bogage d'une cible {\`a} distance. Enfin la s{\'e}curit{\'e} fait r{\'e}f{\'e}rence {\`a} la disponibilit{\'e} de conditions pr{\'e}alables pour l'authentification et la restriction d'acc{\`e}s. Compte tenu de ces propri{\'e}t{\'e}s, nous proposons Mercury, un mod{\`e}le de d{\'e}bogage {\`a} distance et une architecture pour des langues r{\'e}flexifs {\`a} objets. Mercury ouvre (1) l'interactivit{\'e} gr{\^a}ce {\`a} un m{\'e}ta-niveau {\`a} distance miroir bas{\'e} sur un lien de causalit{\'e} avec sa cible, (2) l'instrumentation {\`a} travers une intercession r{\'e}flective bas{\'e}e sur la r{\'e}ification de l'environnement d'ex{\'e}cution sous-jacent, (3) la distribution gr{\^a}ce {\`a} un middleware adaptable et (4) la s{\'e}curit{\'e} par la d{\'e}composition et l'authentification de l'acc{\`e}s aux aspects r{\'e}flexifs. Nous validons notre proposition {\`a} travers un prototype dans le langage de programmation Pharo {\`a} l'aide d'un cadre exp{\'e}rimental diversifi{\'e} de multiples dispositifs contraints. Nous illustrons des techniques de d{\'e}bogage {\`a} distance support{\'e}es par les propri{\'e}t{\'e}s de Mercury, tels que le d{\'e}bogage agile distant et l'instrumentation objet {\`a} distance et montrons comment ils peuvent r{\'e}soudre dans la pratique, les probl{\`e}mes que nous avons identifi{\'e}s.}},
	Affiliation = {RMOD - INRIA Lille - Nord Europe , Unit{\'e} de Recherche Informatique et Automatique - URIA},
	Author = {Papoulias, Nikolaos},
	Hal-Id = {tel-00932796},
	Keywords = {D{\'e}bogage {\`a} distance; Reflexion; Miroirs; Interactivit{\'e}; Instrumentation; Distribution; S{\'e}curit{\'e}; D{\'e}veloppement Agile},
	Language = {Anglais},
	Month = dec,
	Pdf = {http://tel.archives-ouvertes.fr/tel-00932796/PDF/Nikolaos\_Papoulias\_Remote\_Debugging\_and\_Reflection\_in\_Resource\_Constrained\_Devices.pdf},
	School = {Universit{\'e} des Sciences et Technologie de Lille - Lille I},
	Title = {{Le D{\'e}bogage {\`a} Distance et la R{\'e}flexion dans les Dispositifs {\`a} Ressources Limit{\'e}es}},
	Type = {THESE},
	Url = {http://tel.archives-ouvertes.fr/tel-00932796},
  Year = {2013}}

@incollection{Papo10a,
	Author = {Papoulias, Nick},
	Booktitle = {Open Source Software: New Horizons},
	Doi = {10.1007/978-3-642-13244-5_34},
	Editor = {Agerfalk, Par and Boldyreff, Cornelia and Gonzalez-Barahona, JesusM. and Madey, GregoryR. and Noll, John},
	Isbn = {978-3-642-13243-8},
	Pages = {373-379},
	Publisher = {Springer Berlin Heidelberg},
	Series = {IFIP Advances in Information and Communication Technology},
	Title = {High-Level Debugging Facilities and Interfaces: Design and Developement of a Debug-Oriented I.D.E.},
	Url = {http://dx.doi.org/10.1007/978-3-642-13244-5\_34},
	Volume = {319},
  Year = {2010}}

@inproceedings{Papo11a,
	Abstract = {{Mirrors are meta-level entities introduced to decouple reflection from the base-level system. Current mirror-based systems focus on functional decomposition of reflection. In this paper we advocate that mirrors should also address structural decomposition. Mirrors should not only be the entry points of reflective behavior but also be the storage entities of meta-information. This decomposition can help resolve issues in terms of resource constraints (e.g. embedded systems and robotics) or security. Indeed, structural decomposition en- ables discarding meta-information.}},
	Address = {Edingburgh, United Kingdom},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Papoulias, Nikolaos and Bouraqadi, Noury and Denker, Marcus and Ducasse, St{\'e}phane and Fabresse, Luc},
	Booktitle = {{Proceedings of International Workshop on Smalltalk Technologies (IWST'11)}},
	Hal-Id = {inria-00629175},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 pharo kzReflection},
	Labo = {dans},
	Pdf = {http://hal.inria.fr/inria-00629175/PDF/iwst2011Proceedings-Mirrors.pdf},
	Selectif = {non},
	Title = {Towards Structural Decomposition of Reflection with Mirrors},
	Url = {http://hal.inria.fr/inria-00629175/en/},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
  Year = {2011}}

@inproceedings{Papo15a,
	Address = {Salamanca, Spain},
	Author = {Papoulias, Nick and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
	Booktitle = {{30th ACM/SIGAPP Symposium On Applied Computing}},
	Doi = {10.1145/2695664.2695883},
	Hal-Id = {hal-01098596},
	Annote = {internationalconference},
	Keywords = {Reflectogram ; Explicit Control ; Reflection ; Intercession kzReflection stefpub},
	Month = {apr},
	abstract = {Reflective facilities in OO languages are used both for implementing language extensions (such as AOP frameworks) and for support- ing new programming tools and methodologies (such as object- centric debugging and message-based profiling). Yet controlling the run-time behavior of these reflective facilities introduces several challenges, such as computational overhead, the possibility of meta- recursion and an unclean separation of concerns between base and meta-level. In this paper we present five dimensions of meta-level control from related literature that try to remedy these problems. These dimensions are namely: temporal and spatial control, place- ment control, level control and identity control. We argue that the reification of the descriptive notion of the reflectogram, can unify the control of meta-level execution in all these five dimensions. We present a model for the reification of the reflectogram and validate our approach through a prototype implementation in the Pharo pro- gramming environment. Finally we detail a case-study on run-time tracing illustrating our approach.},
	Title = {Reifying the Reflectogram},
  Url = {http://rmod.inria.fr/archives/papers/Papo15a-ACM-SAC-Reflectogram.pdf},
  Year = {2015}}

@article{Papo15b,
	Author = {Papoulias, Nick and Bouraqadi, N. and Denker, Marcus and Ducasse, St\'ephane and Fabresse, Luc},
	journal = {Journal of Object Technology},
	Hal-Id = {hal-01185730},
	Annote = {internationaljournal},
	Abstract ={Remote debugging facilities are a technical necessity for devices that lack appropriate input/output interfaces (display, keyboard, mouse) for program- ming (e.g., smartphones, mobile robots) or are simply unreachable for local development (e.g., cloud-servers). Yet remote debugging solutions can prove awkward to use due to re-deployments. Empirical studies show us that on aver- age 10.5 minutes per coding hour (over five 40-hour work weeks per year) are spent for re-deploying applications (including re-deployments during debugging). Moreover current solutions lack facilities that would otherwise be available in a local setting because it is difficult to reproduce them remotely. Our work identifies three desirable properties that a remote debugging solution should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a remote debugging model based on reflection. Mercury supports run-time evolution through a causally connected remote meta-level, semantic instrumentation through the reification of the underlying execution environment and adaptable distribution through a modular architecture of the debugging middleware.},
	Keywords = {kzReflection stefpub},
	Title = {Mercury: Properties and Design of a Remote Debugging Solution using Reflection},
	Url = {https://hal.inria.fr/hal-01185730},
	Url = {http://rmod.inria.fr/archives/papers/Papo15b-Mercury-JOT.pdf},
	Year = {2015}}

@inproceedings{Patel13a,
	Abstract = {{The sensor networking field is evolving into the
                  Internet of Things\~(IoT), owing in large part to
                  the increased availability of consumer sensing
                  devices, including modern smart phones. However,
                  application development in the IoT still remains
                  challenging, since it involves dealing with several
                  related issues, such as lack of proper
                  identification of roles of various stakeholders, as
                  well as lack of suitable (high-level) abstractions
                  to address the large scale and heterogeneity in IoT
                  systems. Although the software engineering community
                  has proposed several approaches to address the above
                  in the general case, existing approaches for IoT
                  application development only cover limited subsets
                  of above mentioned challenges. In this paper, we
                  propose a multi-stage model-driven approach for IoT
                  application development based on a precise
                  definition of the role to be played by each
                  stakeholder involved in the process -- domain
                  expert, application designer, application developer,
                  device developer, and network manager. The
                  abstractions provided to each stakeholder are
                  further customized using the inputs provided in the
                  earlier stages by other stakeholders. We have also
                  implemented code-generation and task-mapping
                  techniques to support our approach. Our initial
                  evaluation based on two realistic scenarios shows
                  that the use of our techniques/framework succeeds in
                  improving productivity in the IoT application
                  development process.}},
	Address = {Lucca, Italie},
	Affiliation = {ARLES - INRIA Rocquencourt , RMOD - INRIA Lille - Nord Europe},
	Audience = {internationale},
	Author = {Patel, Pankesh and Pathak, Animesh and Cassou, Damien and Issarny, Val{\'e}rie},
	Booktitle = {{4th International Conference on Sensor Systems and Software}},
	annote = {internationalconference},
	Hal-Id = {hal-00809438},
	Keywords = {Internet of Things, Sensor networks, High-level programming, Application development},
	Language = {Anglais},
	Month = apr,
	Pdf = {http://hal.inria.fr/hal-00809438/PDF/main.pdf},
	Selectif = {non},
	Title = {Enabling High-Level Application Development in the {Internet of Things}},
	Url = {http://hal.inria.fr/hal-00809438},
  Year = {2013}}

@article{Patel15a,
  Annote       = {internationaljournal},
  Author       = {Patel, Pankesh and Cassou, Damien},
  Doi          = {10.1016/j.jss.2015.01.027},
  Impactfactor = {Impact Factor (2013) 1.245},
  Journal      = {JSS: Journal of Systems and Software},
  pages        = {62--84},
  Peerreview   = {yes},
  Selectif     = {oui},
  Title        = {Enabling High-level Application Development for the
                  Internet of Things},
  Url          =
                  {http://rmod.inria.fr/archives/papers/Patel15a-JSS-InternetOfThings.pdf},
  Year         = {2015}
}

@mastersthesis{Peirs08a,
	Abstract = {Dependency Structure Matrix (DSM) is an approach taken from
                  process optimization and it exists a variety of algorithms
                  to help organizing the matrix in a form that reflects the
                  architecture and highlights patterns and problematic
                  dependencies. However, the existing DSM implementations have
                  a lack of information in their visualization. That is why, we
                  enhanced DSM by adding written and colored information in the
                  visualization to improve the architecture understanding of a
                  software system and the support of its remodularization. This
                  visualization has been implemented on top of Moose which is a
                  collaborative research platform for Software Analysis and
                  Information Visualization. This report presents my
                  internship done at the research centre INRIA Lille - Nord
                  Europe with the RMoD Team led by S. Ducasse.},
	Annote = {master cook},
	Author = {Romain Peirs},
	School = {Enseita},
	Title = {Enhanced Dependency Structure Matrix},
	Year = {2008}}

@inproceedings{Pers12a,
	Abstract = {Writing unit tests for a software system enhances
                  the confidence that a system works as expected.
                  Since time pressure often prevents a complete
                  testing of all application details developers need
                  to know which new tests the system requires.
                  Developers also need to know which existing tests
                  take the most time and slow down the whole
                  development process. Missing feedback about less
                  tested functionality and reasons for long running
                  test cases make it, however, harder to create a test
                  suite that covers all important parts of a software
                  system in a minimum of time. As a result a software
                  system may be inadequately tested and developers may
                  test less frequently. provides test quality feedback
                  to guide developers in identifying missing tests and
                  correcting low-quality tests. developers with a tool
                  that analyzes test suites with respect to their
                  effectivity (e.g., missing tests) and efficiency
                  (e.g., time and memory consumption). implement our
                  approach, named PathMap, as an extended test runner
                  within the Squeak Smalltalk IDE and demonstrate its
                  benefits by improving the test quality of
                  representative software systems.},
	Address = {Playa Vista, CA, USA},
	Annote = {internationalconference},
	Author = {Perscheid, Michael and Cassou, Damien and Hirschfeld, Robert},
	Booktitle = {C5'12: Proceedings of the 10th International Conference on Creating, Connecting and Collaborating through Computing},
	Month = jan,
	Publisher = {IEEE},
	Selectif = {non},
	Title = {Test Quality Feedback: Improving Effectivity and Efficiency of Unit Testing},
	Year = {2012}}

@inproceedings{Poli13a,
	Abstract = {Reflective architectures are a powerful solution for code browsing, debugging or in-language process handling. However, these reflective architectures show some limitations in edge cases of self-modification and self-monitoring. Modifying the modifier process or monitoring the monitor process in a reflective system alters the system itself, leading to the impossibility to perform some of those tasks properly. In this paper we analyze the problems of reflective architectures in the context of image based object-oriented languages and solve them by providing a first-class representation of an image: a virtualized image.
We present Oz, our virtual image solution. In Oz, a virtual image is represented by an object space. Through an object space, an image can manipulate the internal structure and control the execution of other images. An Oz object space allows one to introspect and modify execution information such as processes, contexts, existing classes and objects. We show how Oz solves the edge cases of reflective architectures by adding a third participant, and thus, removing the self modification and self-observation constraints.},
	Annote = {internationalworkshop},
	Audience = {international},
	Author = {Polito, Guillermo and Ducasse, St{\'e}phane and Fabresse, Luc and Bouraqadi, Noury},
	Booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 21th International Smalltalk Conference - 2013},
	Hal-Id = {hal-00924932},
	Inria = {RMOD},
	Keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection stefpub},
	Title = {Virtual Smalltalk Images: Model and Applications},
	Url = {http://rmod.inria.fr/archives/papers/Poli13a-IWST13-ObjectSpacesVirtualization.pdf},
	X-Language = {EN},
  Year = {2013}}

@techreport{Poli14a,
	Abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts. As such, an application often occupies more memory than actually needed. To solve this problem we propose Tornado, a technique to dynamically tailor applications to only embed code (classes and methods) they use. Tornado uses a run-fail-grow approach to prepare an application for deployment. It launches minimal version of an application and installs a minimal set of statements that will start the user's application. This application is run and these statements are executed. When the application fails because there are classes or methods missing, the necessary code is installed. The application is executed until it reaches a stable point, allowing possibly human interaction for applications with UIs. Thus, Tornado creates minimal memory footprint versions of applications by tailoring the whole application's code, including run-time and third party libraries. We used Tornado to tailor two different applications. We succeeded to tailor a hello world application to occupy 1% of its original size. We also experimented with a Seaside web application tailoring in one case only the application's and framework's code and the whole application's code in the other case. In this latter example, we reached memory savings of about 97%. In this report we present an overview on Tornado, and we give details of the results we obtained.},
	Annote = {technicalreport},
	Author = {Polito, Guillermo and Ducasse, St{\'e}phane and Bouraqadi, Noury and Fabresse, Luc},
	Inria = {RMOD},
	Institution = {RMod -- INRIA Lille-Nord Europe},
	Keywords = {KzReflection kzRemodularisation},
	Labo = {dans},
	Title = {{Extended results of Tornado: A Run-Fail-Grow approach for Dynamic Application Tayloring}},
	Url = {http://rmod.inria.fr/archives/reports/Poli14-TechReport-Tornado-INRIA.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
	Year = {2011}
	}

@inproceedings{Poli14b,
	Abstract = {Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application\'s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around code resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo\'s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories.},
	Annote = {internationalworkshop},
	Audience = {international},
	Author = {Polito, Guillermo and Bouraqadi, Noury and Ducasse, St{\'e}phane and Fabresse, Luc},
	Booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 22th International Smalltalk Conference - 2014},
	Hal-Id = {hal-01070964},
	Inria = {RMOD},
	Keywords = {lse-pub globalstate stefpub},
	Title = {Understanding Pharo\'s global state to move programs through time and space},
	Url = {http://rmod.inria.fr/archives/papers/Poli14b-IWST-GlobalStateClassification.pdf},
	X-Language = {EN},
  Year = {2014}}

@article{Poli14c,
	Abstract = {Bootstrapping is a technique commonly known by its usage in language definition by the introduction of a compiler written in the same language it compiles.
		This process is important to understand and modify the definition of a given language using the same language, taking benefit of the abstractions and expression power it provides.
		A bootstrap, then, supports the evolution of a language.
		However, the infrastructure of reflective systems like Smalltalk includes, in addition to a compiler, an environment with several self-references.
		A reflective system bootstrap should consider all its infrastructural components.
		In this paper, we propose a definition of bootstrap for object-oriented reflective systems, we describe the architecture and components it should contain and we analyze the challenges it has to overcome.
		Finally, we present a reference bootstrap process for a reflective system and Hazelnut, its implementation for bootstrapping the Pharo Smalltalk-inspired system.},
	Annote = {internationaljournal},
	Audience = {international},
	Author = {Polito, Guillermo and Ducasse, St{\'e}phane and Fabresse, Luc and Bouraqadi, Noury and van Ryseghem, Benjamin},
	Hal-Id = {hal-00903724},
	Inria = {RMOD},
	Journal = {Science of Computer Programming},
	Keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection stefpub},
	Publisher = {Elsevier},
	Title = {Bootstrapping Reflective Systems: The Case of Pharo},
	Url = {http://rmod.inria.fr/archives/papers/Poli14c-BootstrappingASmalltalk-ScienceOfComputerProgramming.pdf},
	X-Language = {EN},
  Year = {2014}}

@inproceedings{Poli15a,
	Abstract = {Bootstrapping is well known in the context of compilers, where a bootstrapped compiler can compile its own source code. Bootstrapping is a beneficial engineering practice because it raises the level of abstraction of a program making it easier to understand, optimize, evolve, etc. Bootstrapping a reflective object-oriented language is however more challenging, as we need also to initialize the runtime of the language with its initial objects and classes besides writing its compiler.
In this paper, we present a novel bootstrapping infrastructure for Pharo-like languages that allows us to easily extend and modify such languages. Our bootstrapping process relies on a first-class runtime. A first-class runtime is a meta-object that represents a program's runtime and provides a MOP to easily load code into it and manipulate its objects. It decouples the virtual machine (VM) and language concerns by introducing a clear VM-language interface. Using this process, we show how we succeeded to bootstrap a Smalltalk-based language named Candle and then extend it with traits in less than 250 lines of high-level Smalltalk code. We also show how we can bootstrap with minimal effort two other languages (Pharo and MetaTalk) with similar execution semantics but different object models.},
	Annote = {internationalconference},
	Audience = {international},
	Hal-Id = {hal-01185812},
	Author = {Polito, Guillermo and Ducasse, St{\'e}phane and Fabresse, Luc and Bouraqadi, Noury},
	Booktitle = {Onward! 2015},
	Inria = {RMOD},
	Keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
	Title = {A Bootstrapping Infrastructure to Build and Extend Pharo-Like Languages},
	Url = {http://rmod.inria.fr/archives/papers/Poli15a-Onward-Bootstrapping.pdf},
	PDF = {http://rmod.inria.fr/archives/papers/Poli15a-Onward-Bootstrapping.pdf},
	X-Language = {EN},
	Year = {2015}}

@inproceedings{Poli15b,
	Abstract = {Dynamically updating language runtime and core libraries such as collections and threading is challenging since the update mechanism uses such libraries at the same time that it modifies them. To tackle this challenge, we present Dy- namic Core Library Update (DCU) as an extension of Dy- namic Software Update (DSU) and our approach based on a virtualization architecture. Our solution supports the up- date of core libraries as any other normal library, avoiding the circular dependencies between the updater and the core libraries. Our benchmarks show that there is no evident per- formance overhead in comparison with a default execution. Finally, we show that our approach can be applied to real life scenario by introducing a critical update inside a web application with 20 simulated concurrent users.},
	Annote = {internationalconference},
	Audience = {international},
	Hal-Id = {hal-01185819},
	Author = {Polito, Guillermo and Ducasse, St{\'e}phane and Fabresse, Luc and Bouraqadi, Noury and Mattone, Max},
	Booktitle = {Onward! 2015},
	Inria = {RMOD},
	Keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
	Title = {Virtualization Support for Dynamic Core Library Update},
	Url = {http://rmod.inria.fr/archives/papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf},
	PDF = {http://rmod.inria.fr/archives/papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf},
	X-Language = {EN},
	Year = {2015}}

@phdthesis{Poli15d,
 	Author = {Guillermo Polito},
 	Hal-Id = {tel-01251173v1},
 	Title = {Virtualization Support for Application Runtime Specialization and Extension},
 	School = {University Lille 1 - Sciences et Technologies - France},
 	abstract = {An application runtime is the set of software elements that represent an application during its execution. Application runtimes should be adaptable to different contexts. Advances in computing technology both in hardware and software indeed demand it. For example, on one hand we can think about extending a programming language to enhance the developers' productivity. On the other hand we can also think about transparently reducing the memory footprint of applications to make them fit in constrained resource scenarios e.g., low networks or limited memory availability. We propose Espell, a virtualization infrastructure for object-oriented high-level language runtimes. Espell provides a general purpose infrastructure to control and manipulate object-oriented runtimes in different situations. A first-class representation of an object-oriented runtime provides a high-level API for the manipulation of such runtime. A hypervisor uses this first-class object and manipulates it either directly or by executing arbitrary expressions into it. We show with our prototype that this infrastructure supports language bootstrapping and application runtime tailoring. Using bootstrapping we describe an object-oriented high-level language initialization in terms of itself. A bootstrapped language takes advantage of its own abstractions and is easier to extend. With application runtime tailoring we generate specialized applications by extracting the elements of a program that are used during execution. A tailored application encompasses only the classes and methods it needs and avoids the code bloat that appears from the usage of third-party libraries and frameworks.},
 	Month = {apr},
 	Year = {2015},
   Url = {http://rmod.inria.fr/archives/phd/PhD-2015-Polito.pdf}}

@misc{Poll02a,
	Address = {Malaga},
	Annote = {internationalworkshop},
	Author = {Pollet, Damien and Vojtisek, Didier and J\'ez\'equel, Jean-Marc},
	Howpublished = {Workshop on Integration and Transformation of UML models (WITUML~2002)},
	Month = jun,
	Title = {OCL as a Core UML Transformation Language},
	Url = {http://ctp.di.fct.unl.pt/~ja/wituml02.htm},
  Year = {2002}}

@phdthesis{Poll05a,
	Annote = {phdthesis},
	Author = {Pollet, Damien},
	Month = jun,
	School = {Universit\'e de Rennes 1},
	Title = {Une architecture pour les transformations de mod\`eles et la restructuration de mod\`eles UML},
	Url = {http://www.irisa.fr/bibli/publi/theses/2005/pollet/pollet.html},
  Year = {2005}}

@inproceedings{Poll07a,
	Abstract = {To maintain and understand large applications, it is
                  crucial to know their architecture. The first
                  problem is that unlike classes and packages,
                  architecture is not explicitly represented in the
                  code. The second problem is that successful
                  applications evolve over time, so their architecture
                  inevitably drifts. Reconstructing the architecture
                  and checking whether it is still valid is therefore
                  an important aid. While there is a plethora of
                  approaches and techniques supporting architecture
                  reconstruction, there is no comprehensive state of
                  the art and it is often difficult to compare the
                  approaches. This article presents a state of the art
                  on software architecture reconstruction approaches.},
	Acceptnum = {38},
	Accepttotal = {132},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Pollet, Damien and Ducasse, St\'ephane and Poyet, Lo\"{\i}c and Alloui, Ilham and C\^impan, Sorana and Verjus, Herv\'e},
	Booktitle = {Proceedings of 11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
	Editor = {Krikhaar, Ren\'e and Verhoef, Chris and Di Lucca, Giuseppe},
	Hal-Id = {hal-00849009},
	Inria = {hors},
	Keywords = {recast kzArchi},
	Location = {Amsterdam, the Netherlands},
	Misc = {Acceptance rate: 38/132=29\%},
	Month = mar,
	Note = {Best Paper Award},
	Publisher = {IEEE Computer Society},
	Rate = {29\%},
	Selectif = {oui},
	Title = {Towards A Process-Oriented Software Architecture Reconstruction Taxonomy},
	Url = {http://scg.unibe.ch/archive/papers/Poll07a-CSMRSARTaxonomy.pdf},
  Year = {2007}}


@inproceedings{Poll15a,
	Abstract = {Most programming languages natively provide an abstraction of character strings. However, it is difficult to assess the design or the API of a string library.
There is no comprehensive analysis of the needed operations and their different variations. There are no real guidelines about the different forces in presence and how they structure the design space of string manipulation. In this article, we harvest and structure a set of criteria to describe a string API. We propose an analysis of the Pharo~4 String library as a first experience on the topic.},
	Annote = {internationalworkshop},
	Author = {Damien Pollet and St{\'e}phane Ducasse},
	Booktitle = {International Workshop on Smalltalk Technologies 2015},
	Keywords = {pharo lse-pub kzLanguageDesign},
	Note = {Best Paper Award},
	Title = {A First Analysis of String APIs: the Case of Pharo},
	Url = {http://rmod.inria.fr/archives/workshops/Poll15a-IWST2015-StringsAPI.pdf},
  Year = {2015},
  Hal-Id = {hal-01244486}}

@misc{PowerfullIdeas,
	Aeres = {OV},
	Annote = {notrefereed},
	Author = {St\'ephane Ducasse and Alexandre Bergel and Fran\c{c}ois Schnell and Noury Bouraqadi and Serge Stinckwich},
	Inria = {hors},
	Keywords = {squeak etoy book stefPub kzTeaching},
	Note = {French translation of Powerful Ideas in the Classroom by B.J. Allen-Conn and Kim Rose},
	Selectif = {non},
	Title = {Des idees puissantes dans la classe --- Utilisation de Squeak pour l'amelioration de l'apprentissage des mathematiques et des sciences (traduction de Powerful Ideas in the Classroom)}}

@incollection{Prad09a,
	Annote = {internationalworkshop},
	Author = {do Prado, H{\'e}rcules Antonio and Ferneda, Edilson and Anquetil, Nicolas and Teixeira, Elizabeth d'Arrochella},
	Booktitle = {Knowledge-Based and Intelligent Information and Engineering Systems},
	Pages = {364--371},
	Publisher = {Springer Berlin Heidelberg},
	Tagnicolasa = {metric},
	Title = {Counselor, a Data Mining Based Time Estimation for Software Maintenance},
	Year = {2009}}

@inproceedings{Rama02a,
	Abstract = {As part of a long term project aiming at empowering software maintainers with knowledge based tools, we conducted an empirical study on the knowledge they use when doing maintenance. The study was intended as a preliminary work to get initial data on the type on knowledge used and the importance of each type of knowledge. For example, it is commonly assumed that application domain knowledge is important when doing maintenance. However nobody can tell exactly how much more important it is than Computer Science knowledge. We monitored six software engineers in two different organizations and analyzed the knowledge they used in their maintenance activity. In this paper we present and discuss some results and propose research directions from these. Our results include: the fact that software engineers rarely "search for" some new knowledge and rather work from what they already know; or the acknowledgment of a variation of the knowledge used depending on the organization one is working in. The most disturbing result is that, contrary to what is commonly assumed, the software engineers we studied seemed to make little use of application domain knowledge.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {M. Fenoll Ramal and Ricardo de Moura Meneses and Nicolas Anquetil},
	Booktitle = {9th Working Conference on Reverse Engineering (WCRE 2002)},
	Doi = {10.1109/WCRE.2002.1173085},
	Isbn = {0-7695-1799-4},
	Labo = {non},
	Pages = {277-},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {A Disturbing Result on the Knowledge Used during Software Maintenance},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2002}}


@inproceedings{Ramo04a,
	Abstract = {Outsourcing has become common practice in the software industry. Organizations routinely subcontract the maintenance of their software assets to specialized companies. A great challenge for these companies, is to rapidly evaluate the quality of the systems they will have to maintain so as to accurately estimate the amount of work they will require. To answer these concerns, we developed a framework of metrics to evaluate the complexity of a legacy software system and help an outsourcing maintainer define its contracts. This framework was defined using a well known approach in software quality, called "goal-question-metric". We present the goal-question-metric approach, its results, and the initial experimentation of the metrics on five real life systems in Cobol.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Cristiane S. Ramos and K{\'a}thia Mar\c{c}al de Oliveira and Nicolas Anquetil},
	Booktitle = {8th European Conference on Software Maintenance and Reengineering (CSMR 2004)},
	Doi = {10.1109/CSMR.2004.1281405},
	Isbn = {0-7695-2107-X},
	Labo = {non},
	Pages = {48-57},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Tagnicolasa = {metric},
	Title = {Legacy Software Evaluation Model for Outsourced Maintainer},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2004}}

@misc{Rapi98a,
	Abstract = {Type information is a crucial information to support
                  object-oriented reengineering. In a dynamically
                  typed language like Smalltalk standard static type
                  inference is a complex and heavily computational
                  task. In this paper, we report how we use message
                  passing control and compiler extension to support
                  dynamic inference type in Smalltalk.},
	Annote = {internationalworkshop},
	Author = {Pascal Rapicault and Mireille Blay-Fornarino and St\'ephane Ducasse and Anne-Marie Dery},
	Keywords = {scg-pub skip-doi famoosstefPub kzEvolution},
	Note = {Proceedings of the ECOOP '98 International Workshop Experiences in Object-Oriented Reengineering, abstract in Object-Oriented Technology (ECOOP '98 Workshop Reader forthcoming LNCS)},
	Pages = {76--77},
	Title = {Dynamic Type Inference to Support Object-Oriented Reengineering in Smalltalk},
	Url = {http://scg.unibe.ch/archive/famoos/Rapi98a/type.pdf},
  Year = {1998}}

@inproceedings{Rati04a,
	Abstract = {As systems evolve and their structure decays,
                  maintainers need accurate and automatic
                  identification of the design problems. Current
                  approaches for automatic detection of design
                  problems are not accurate enough because they
                  analyze only a single version of a system and
                  consequently they miss essential information as
                  design problems appear and evolve over time. Our
                  approach is to use the historical information of the
                  suspected flawed structure to increase the accuracy
                  of the automatic problem detection. Our means is to
                  define measurements which summarize how persistent
                  the problem was and how much maintenance effort was
                  spent on the suspected structure. We apply our
                  approach on a large scale case study and show how it
                  improves the accuracy of the detection of God
                  Classes and Data Classes, and additionally how it
                  adds valuable semantical information about the
                  evolution of flawed design structures.},
	Acceptnum = {33},
	Accepttotal = {62},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Daniel Ra{\c t}iu and St\'ephane Ducasse and Tudor G{\^\i}rba and Radu Marinescu},
	Booktitle = {Proceedings of 8th European Conference on Software Maintenance and Reengineering (CSMR'04)},
	Keywords = {recast04 scg-pub skip-doi stefPub jb04 moose girba ratiu evolution kzChecking kzMetric},
	Misc = {acceptance rate: 33/62 = 52\%},
	Pages = {223--232},
	Publisher = {IEEE Computer Society},
	Title = {Using History Information to Improve Design Flaws Detection},
	Url = {http://scg.unibe.ch/archive/papers/Rati04aHistoryImproveFlawsDetection.pdf},
  Year = {2004}}

@inproceedings{Raza09a,
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 2009 Joint Working IEEE/IFIP Conference on Software Architecture \& European Conference on Software Architectures},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub kzArchi},
	Labo = {dans},
	Pages = {329--332},
	Title = {Multiple Viewpoints Architecture Extraction},
	Url = {http://rmod.inria.fr/archives/papers/Raza09a-WASECSA-MultipleViewPoints.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Raza09b,
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Azadeh Razavizadeh and Sorana C\^impan and Herv\'e Verjus and St\'ephane Ducasse},
	Booktitle = {8th International Workshop on System/Software Architectures},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {moose lse-pub kzArchi},
	Labo = {hors},
	Title = {Software System Understanding via Architectural Views Extraction According to Multiple Viewpoints},
	Url = {http://rmod.inria.fr/archives/workshops/Raza09b-iwssa-.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Reic07a,
	Abstract = {With the success of agile methodologies more and
                  more projects develop large test suites to ensure
                  that the system is behaving as expected. Not only do
                  tests ensure correctness, but they also offer a live
                  documentation for the code. However, as the system
                  evolves, the tests need to evolve as well to keep up
                  with the system, and as the test suite grows larger,
                  the effort invested into maintaining tests is a
                  significant activity. In this context, the quality
                  of tests becomes an important issue, as developers
                  need to assess and understand the tests they have to
                  maintain. In this paper we present TestLint, an
                  approach together with an experimental tool for
                  qualifying tests. We define a set of criteria to
                  determine test quality, and we evaluate our approach
                  on a large sample of unit tests found in open-source
                  projects.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Stefan Reichhart and Tudor G\^irba and St\'ephane Ducasse},
	Booktitle = {Journal of Object Technology, Special Issue. Proceedings of TOOLS Europe 2007},
	Inria = {hors},
	Issn = {1660-1769},
	Keywords = {scg07 scg-pub jb08 snf07 skip-doi testlint test smell refactoring girba kzChecking kzTool},
	Medium = {2},
	Month = oct,
	Note = {Special Issue. Proceedings of TOOLS Europe 2007},
	Pages = {231--251},
	Peerreview = {yes},
	Selectif = {non},
	Title = {Rule-based Assessment of Test Quality},
	Url = {http://scg.unibe.ch/archive/papers/Reic07aTestQualityAssessment.pdf},
	Volume = {6/9},
  Year = {2007}}

@inproceedings{Reng07a,
	Abstract = {Model-driven engineering is a powerful approach to
                  build large-scale applications. However, an
                  application's metamodel often remains static after
                  the development phase and cannot be changed unless a
                  new development effort occurs. Yet, end users often
                  need to rapidly adapt their applications to new
                  business needs. In many cases, the end users would
                  know how to make the required adaptations, if only,
                  the application would let them do so. In this paper
                  we present how we built a runtime-dynamic
                  meta-environment by integrating Magritte, a
                  self-described metamodel, into Smalltalk's
                  reflective language model. Our solution offers the
                  best of both worlds: developers can develop their
                  applications using the same tools they were used to,
                  but at the same time they gain the power of
                  meta-programming. We show in particular that our
                  approach is adapted to support end user
                  customization of applications: the adaptive model of
                  Magritte enables to not only describe existing
                  classes, but also lets end users build their own
                  metamodels on the fly.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
  Author = {Lukas Renggli and St\'ephane Ducasse and Adrian Kuhn},
	Booktitle = {Model Driven Engineering Languages and Systems},
	Doi = {10.1007/978-3-540-75209-7\_8},
	Editor = {Gregor Engels and Bill Opdyke and Douglas C. Schmidt and Frank Weil},
	Inria = {hors},
	Isbn = {978-3-540-75208-0},
	Keywords = {scg-pub fame kzMeta},
	Medium = {2},
	Month = sep,
	Pages = {106--120},
	Peerreview = {yes},
	Publisher = {Springer},
	Rate = {32\%},
	Series = {LNCS},
	Title = {Magritte --- A Meta-Driven Approach to Empower Developers and End Users},
	Url = {http://scg.unibe.ch/archive/papers/Reng07aMagritte.pdf},
	Volume = {4735},
  Year = {2007}}

@inproceedings{Reng09c,
	Abstract = {As domain-specific modeling begins to attract
                  widespread acceptance, pressure is increasing for
                  the development of new domain-specific languages.
                  Unfortunately these DSLs typically conflict with the
                  grammar of the host language, making it difficult to
                  compose hybrid code except at the level of strings;
                  few mechanisms (if any) exist to control the scope
                  of usage of multiple DSLs; and, most seriously,
                  existing host language tools are typically unaware
                  of the DSL extensions, thus hampering the
                  development process. Language boxes address these
                  issues by offering a simple, modular mechanism to
                  encapsulate (i) compositional changes to the host
                  language, (ii) transformations to address various
                  concerns such as compilation and highlighting, and
                  (iii) scoping rules to control visibility of
                  language extensions. We describe the design and
                  implementation of language boxes, and show with the
                  help of several examples how modular extensions can
                  be introduced to a host language and environment.},
	Annote = {internationalconference},
  Author = {Lukas Renggli and Marcus Denker and Oscar Nierstrasz},
	Booktitle = {Proceedings of the International Conference on Software Language Engineering (SLE'09)},
	Doi = {10.1007/978-3-642-12107-4\_20},
	Inria = {RMOD},
	Inriareport = {2010},
	Isbn = {978-3-642-12106-7},
	Keywords = {scg09 scg-pub snf10 jb10 helvetia fromscgbib marcusdenker remoose lse-pub pharo pharo-pub},
	Medium = {2},
	Pages = {274--293},
	Peerreview = {yes},
	Publisher = {Springer},
	Ratex = {29\%},
	Series = {LNCS},
	Title = {Language Boxes: Bending the Host Language with Modular Language Changes},
	Url = {http://rmod.inria.fr/archives/papers/Reng09c-SLE09-LanguageBoxes.pdf},
	Volume = {5969},
  Year = {2009}}

@inproceedings{Reng10b,
	Abstract = {Lint-like program checkers are popular tools that
                  ensure code quality by verifying compliance with
                  best practices for a particular programming
                  language. The proliferation of internal
                  domain-specific languages and models, however, poses
                  new challenges for such tools. Traditional program
                  checkers produce many false positives and fail to
                  accurately check constraints, best practices, common
                  errors, possible optimizations and portability
                  issues particular to domain-specific languages. We
                  advocate the use of dedicated rules to check
                  domain-specific practices. We demonstrate the
                  implementation of domain-specific rules, the
                  automatic fixing of violations, and their
                  application to two case-studies: (1) Seaside defines
                  several internal DSLs through a creative use of the
                  syntax of the host language; and (2) Magritte adds
                  meta-descriptions to existing code by means of
                  special methods. Our empirical validation
                  demonstrates that domain-specific program checking
                  significantly improves code quality when compared
                  with general purpose program checking.},
	Annote = {internationalconference},
	Author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {Proceedings of the 48th International Conference on Objects, Models, Components and Patterns (TOOLS'10)},
	Doi = {10.1007/978-3-642-13953-6\_12},
	Editor = {Jan Vitek},
	Hal-Id = {inria-00531509},
	Inria = {RMOD},
	Inriareport = {2010},
	Isnb = {978-3-642-13952-9},
	Keywords = {scg-pub helvetia girba snf10 jb10 remoose lse-pub pharo pharo-pub kzTool kzChecking},
	Pages = {213--232},
	Peerreview = {yes},
	Publisher = {Springer-Verlag},
	Ratex = {29\%},
	Series = {LNCS},
	Title = {Domain-Specific Program Checking},
	Url = {http://rmod.inria.fr/archives/papers/Reng10b-DomainSpecificProgramChecking.pdf},
	Volume = {6141},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Reng10c,
	Abstract = {Grammars for programming languages are traditionally
                  specified statically. They are hard to compose and
                  reuse due to ambiguities that inevitably arise.
                  PetitParser combines ideas from scannerless parsing,
                  parser combinators, parsing expression grammars and
                  packrat parsers to model grammars and parsers as
                  objects that can be reconfigured dynamically.
                  Through examples and benchmarks we demonstrate that
                  dynamic grammars are not only flexible but highly
                  practical.},
	Address = {Malaga, Spain},
	Annote = {internationalworkshop},
	Author = {Lukas Renggli and St\'ephane Ducasse and Tudor G\^irba and Oscar Nierstrasz},
	Booktitle = {4th Workshop on Dynamic Languages and Applications (DYLA 2010)},
	Hal-Id = {hal-00746253},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {scg-pub moose lse-pub pharo pharo-pub kzLanguageDesign},
	Month = jun,
	Peerreview = {yes},
	Title = {Practical Dynamic Grammars for Dynamic Languages},
	Url = {http://scg.unibe.ch/archive/papers/Reng10cDynamicGrammars.pdf},
	X-International-Audience = {yes},
	X-Proceedings = {no},
  Year = {2010}}

@inproceedings{Rich02a,
	Abstract = {Modeling object-oriented applications using
                  collaborations and roles is now well accepted.
                  Collaboration-based or role-based designs decompose
                  an application into tasks performed by a subset of
                  the applications' classes. Collaborations prov ide a
                  larger unit of understanding and reuse than classes,
                  and are an important aid in the maintenance and
                  evolution of the software. This kind of design
                  information is lost, however, at the implementation
                  level, making it hard to maintain and evolve an e
                  xisting software application. The extraction of
                  collaborations from code is therefore an important
                  issue in design recovery. In this paper we propose
                  an iterative approach which uses dynamic information
                  to support the recovery and understanding of collabo
                  rations. We describe a tool we have developed to
                  support our approach and demonstrate its use on a
                  case study.},
	Acceptnum = {61},
	Accepttotal = {127},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tamar Richner and St\'ephane Ducasse},
	Booktitle = {Proceedings of 18th IEEE International Conference on Software Maintenance (ICSM'02)},
	Doi = {10.1109/ICSM.2002.1167745},
	Keywords = {scg-pub stefPub kzDynamicInformation},
	Misc = {acceptance rate: 61/127 = 48\%},
	Month = oct,
	Pages = {34},
	Publisher = {IEEE Computer Society},
	Title = {Using Dynamic Information for the Iterative Recovery of Collaborations and Roles},
	Url = {http://scg.unibe.ch/archive/papers/Rich02aRolesExtractionICSM2002.pdf},
  Year = {2002}}

@inproceedings{Rich98b,
	Abstract = {Understanding how components in an application
                  interact to ensure a certain functionality is an
                  essential aspect of understanding a software
                  application. To obtain this kind of information an
                  analysis of the dynamic behavior of an application
                  is more appropriate than a static analysis of the
                  code. Understanding dynamic behavior through event
                  analysis is a challenge because of the large amount
                  of data gathered through program executions. In this
                  paper, we show how we define declarative queries
                  that allow us to filter the event data collected and
                  to define new abstractions which aid in program
                  understanding.},
	Annote = {internationalworkshop},
	Author = {Tamar Richner and St\'ephane Ducasse and Roel Wuyts},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {scg-pub skip-doi stefPub kzDynamicInformation},
	Month = jul,
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Understanding Object-Oriented Programs with Declarative Event Analysis},
	Url = {http://scg.unibe.ch/archive/papers/Rich98bEvents.pdf},
	Volume = {1543},
  Year = {1998}}

@inproceedings{Rich99a,
	Abstract = {Recovering architectural documentation from code is
                  crucial to maintaining and reengineering software
                  systems. Reverse engineering and program
                  understanding approaches are often limited by the
                  fact that (1) they propose a fixed set of predefined
                  views and (2) they consider either purely static or
                  purely dynamic views of the application. In this
                  paper we present an environment supporting the
                  generation of tailorable views of object-oriented
                  systems from both static and dynamic information.
                  Our approach is based on the combination of
                  user-defined queries which allow an engineer to
                  create high-level abstractions and to produce views
                  using these abstractions.},
	Acceptnum = {49},
	Accepttotal = {100},
	Address = {Los Alamitos CA},
	Annote = {internationalconference},
	Author = {Tamar Richner and St\'ephane Ducasse},
	Booktitle = {Proceedings of 15th IEEE International Conference on Software Maintenance (ICSM'99)},
	Doi = {10.1109/ICSM.1999.792487},
	Editor = {Hongji Yang and Lee White},
	Keywords = {scg-pub oorp stefPub kzDynamicInformation kzArchi},
	Misc = {acceptance rate: 49/100 = 49\%},
	Month = sep,
	Pages = {13--22},
	Publisher = {IEEE Computer Society Press},
	Title = {Recovering High-Level Views of Object-Oriented Applications from Static and Dynamic Information},
	Url = {http://scg.unibe.ch/archive/papers/Rich99aRecoveringViews.pdf},
  Year = {1999}}

@inproceedings{Rieg04b,
	Abstract = {Duplication of code is a common phenomenon in the
                  development and maintenance of large software
                  systems. The detection and removal of duplicated
                  code has become a standard activity during the
                  refactoring phases of a software life-cycle.
                  However, code duplication identification ends to
                  produce large amounts of data making the
                  understanding of the duplication situation as a
                  whole difficult. Reengineers can easily lose sight
                  of the forest for the trees. There is a need to
                  support a qualitative analysis of the duplicated
                  code. In this paper we propose a number of
                  visualzations of duplicated source elements that
                  support reengineers in answering questions, e.g.,
                  which parts of the sysem are connected by copied
                  code or which parts of the sysem are copied the
                  most.},
	Acceptnum = {28},
	Accepttotal = {78},
	Annote = {internationalconference},
	Author = {Matthias Rieger and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 11th Working Conference on Reverse Engineering (WCRE'04)},
	Cvs = {DuplocVizPaper},
	Doi = {10.1109/WCRE.2004.25},
	Keywords = {scg-pub stefPub clones kzDuplication},
	Location = {Delft, The Netherlands},
	Misc = {acceptance rate: 28/78 = 36\%},
	Month = nov,
	Pages = {100--109},
	Publisher = {IEEE Computer Society Press},
	Title = {Insights into System-Wide Code Duplication},
	Url = {http://scg.unibe.ch/archive/papers/Rieg04bWCRE2004ClonesVisualization.pdf},
  Year = {2004}}

@inproceedings{Rieg98a,
	Abstract = {Code duplication is considered as bad practice that
                  complicates the maintenance and evolution of
                  software. Detecting duplicated code is a difficult
                  task because of the large amount of data to be
                  checked and the fact that a priori it is unknown
                  which code part has been duplicated. In this paper,
                  we present a tool called DUPLOC that supports code
                  duplication detection in a visual and exploratory or
                  an automatic way.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse},
	Booktitle = {Proceedings ECOOP Workshop on Experiences in Object-Oriented Re-Engineering},
	Editor = {St\'ephane Ducasse and Joachim Weisbrod},
	Keywords = {scg-pub skip-doi kzDuplication},
	Number = {6/7/98},
	Publisher = {Forschungszentrum Informatik Karlsruhe},
	Series = {FZI Report},
	Title = {Visual Detection of Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
  Year = {1998}}

@inproceedings{Rieg98b,
	Abstract = {Code duplication is considered as bad practice that
                  complicates the maintenance and evolution of
                  software. Detecting duplicated code is a difficult
                  task because of the large amount of data to be
                  checked and the fact that a priori it is unknown
                  which code part has been duplicated. In this paper,
                  we present a tool called DUPLOC that supports code
                  duplication detection in a visual and exploratory or
                  an automatic way.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology (ECOOP '98 Workshop Reader)},
	Editor = {Serge Demeyer and Jan Bosch},
	Keywords = {scg-pub skip-doi stefPub kzVisualization kzDuplication},
	Month = jul,
	Pages = {75--76},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Visual Detection of Duplicated Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg98aEcoopWorkshop.pdf},
	Volume = {1543},
  Year = {1998}}

@inproceedings{Rieg99a,
	Abstract = {Code duplication is an important problem in
                  application maintenance. Tools exist that support
                  code duplication detection. However, few of them
                  propose a solution for the problem, i.e.
                  refactorings. We propose an approach that uses the
                  information given by code duplication detection to
                  guide the refactorings of OO applications.},
	Annote = {internationalworkshop},
	Author = {Matthias Rieger and St\'ephane Ducasse and Georges Golomingi},
	Booktitle = {Object-Oriented Technology (ECOOP '99 Workshop Reader)},
	Keywords = {olit scg-pub skip-doi jb-none kzVisualization kzDuplication},
	Number = {1743},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Tool Support for Refactoring Duplicated OO Code},
	Url = {http://scg.unibe.ch/archive/papers/Rieg99aToolSuppRefacOOCode.pdf},
  Year = {1999}}

@inproceedings{Rizu15a,
	Annote = {internationalworkshop},
	author = {Rizun, Markiyan and Bach, Jean-Christophe and Ducasse, St\'ephane},
	title = {Code Transformation by Direct Transformation of ASTs},
	booktitle = {International Workshop on Smalltalk Technologies},
	 year = {2015},
	 Hal = {http://hal.inria.fr/inria-01319677},
	Hal-Id = {hal-01319677},
	Url = {http://rmod.inria.fr/archives/papers/Rizu15a-CodeTransformation.pdf}
}

@inproceedings{Rizu16a,
	TITLE = {{Phorms: Pattern Combinator Library for Pharo}},
	Abstract = {Pattern matching is a common mechanism to provide analysis and transformation of data structures. Such an approach basically checks whether the containing elements of a data structure are constituents of a pattern, described by the developer. This paper is a step towards having seamless object-oriented pattern matching, which would be applicable to any object in Pharo. We present a pattern matching library, called \phorms, which enables users to compose patterns using the syntax of the Pharo programming language. In this library, patterns are objects and therefore can be inspected and debugged using existing Pharo tools. Our solution is extensible unlike \emph{The Rewrite Engine} -- Pharo's current pattern matching facilities. Moreover, by treating patterns as first class objects, our library provides more flexibility in the pattern matching process.},
	AUTHOR = {Markiyan Rizun and Gustavo Santos and St\{'e}phane Ducasse and Camille Teruel},
	URL = {http://rmod.inria.fr/archives/papers/Rizu16a-IWST16-Matcher.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01353883},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@inproceedings{Robb05b,
	Abstract = {Understanding classes and methods is a key activity
                  in object-oriented programming, since classes
                  represent the primary abstractions from which
                  applications are built, while methods contain the
                  actual program logic. The main problem of this task
                  is to quickly grasp the purpose and inner structure
                  of a class. To achieve this goal, one must be able
                  to overview multiple methods at once. In this paper,
                  we present microprints, pixel-based representations
                  of methods enriched with semantical information. We
                  present three specialized microprints each dealing
                  with a specific aspect we want to understand of
                  methods: (1) state access, (2) control flow, and (3)
                  invocation relationship. We present the microprints
                  in conjunction with the class blueprints of the CODE
                  CRAWLER visualization tool [12] and also integrated
                  into the default code browser of the Smalltalk
                  VisualWorks development environment.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Romain Robbes and St\'ephane Ducasse and Michele Lanza},
	Booktitle = {Proceedings of 13th International Smalltalk Conference},
	Inria = {hors},
	Keywords = {scg-pub skip-doi stefPub kzVisualization},
	Pages = {131--157},
	Selectif = {non},
	Series = {ISC'05},
	Title = {Microprints: A Pixel-based Semantically Rich Visualization of Methods},
	Url = {http://scg.unibe.ch/archive/papers/Robb05b-microprintsESUG.pdf},
  Year = {2005}}

@inproceedings{Robb10a,
	Abstract = {
    Change prediction helps developers by recommending program entities that will have to be changed alongside the entities currently
    being changed. To evaluate their accuracy, current change prediction approaches use data from versioning systems such as CVS or SVN.
    These data sources provide a coarse-grained view of the development history that flattens the sequence of changes in a single commit.
    They are thus not a valid basis for evaluation in the case of development style prediction, where the order of the predictions has to
    match the order of the changes a developer makes.
    We propose a benchmark for the evaluation of change prediction approaches based on fine-grained change data recorded from IDE usage.
    Moreover, the change prediction approaches themselves can use the more accurate data to fine-tune their prediction. We present an
    evaluation procedure and use it on several change prediction approaches, both novel and from the literature, and report on the
    results.},
	Aeres = {aeres12},
	Aeresstatus = {ACT},
	Annote = {internationalconference},
	Author = {Robbes, Romain and Pollet, Damien and Lanza, Michele},
	Booktitle = {Proceedings of the 7th IEEE Working Conference on Mining Software Repositories (MSR)},
	Doi = {10.1109/MSR.2010.5463278},
	Editor = {Whitehead, Jim and Zimmermann, Thomas},
	Hal = {inria-00531788},
	Inria = {RMOD},
	Inriareport = {2010},
	Isbn = {978-1-4244-6803-4},
	Keywords = {lse-pub pharo pharo-pub},
	Labo = {hors},
	Misc = {Acceptance rate: 16/51 = 31\%},
	Month = may,
	Pages = {161--170},
	Publisher = {IEEE Computer Society},
	Rate = {31\%},
	Selectif = {non},
	Title = {Replaying IDE Interactions to Evaluate and Improve Change Prediction Approaches},
	Url = {http://rmod.inria.fr/archives/papers/Robb10a-MSR10-ChangePrediction.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CL,CH},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Roet07b,
	Abstract = {Dynamic, unanticipated adaptation of running systems
                  is of interest in a variety of situations, ranging
                  from functional upgrades to on-the-fly debugging or
                  monitoring of critical applications. In this paper
                  we study a particular form of computational
                  reflection, called unanticipated partial behavioral
                  reflection, which is particularly well-suited for
                  unanticipated adaptation of real-world systems. Our
                  proposal combines the dynamicity of unanticipated
                  reflection, i.e., reflection that does not require
                  preparation of the code of any sort, and the
                  selectivity and efficiency of partial behavioral
                  reflection. First, we propose unanticipated partial
                  behavioral reflection which enables the developer to
                  precisely select the required reifications, to
                  flexibly engineer the metalevel and to introduce the
                  meta behavior dynamically. Second, we present a
                  system supporting unanticipated partial behavioral
                  reflection in Squeak Smalltalk, called Geppetto, and
                  illustrate its use with a concrete example of a
                  Seaside web application. Benchmarks validate the
                  applicability of our proposal as an extension to the
                  standard reflective abilities of Smalltalk.},
	Annote = {internationalconference},
  Author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
	Booktitle = {Advances in Smalltalk --- Proceedings of 14th International Smalltalk Conference (ISC 2006)},
	Doi = {10.1007/978-3-540-71836-9\_3},
	Isbn = {978-3-540-71835-2},
	Issn = {0302-9743},
	Keywords = {scg07 scg-pub jb07 snf06 roethlisberger reflectivity marcusdenker fromscgbib},
	Medium = {2},
	Pages = {47--65},
	Peerreview = {yes},
	Publisher = {Springer},
	Series = {LNCS},
	Title = {Unanticipated Partial Behavioral Reflection},
	Url = {http://rmod.inria.fr/archives/papers/Roet07b-ISC06-UPBReflection.pdf},
	Volume = {4406},
  Year = {2007}}

@article{Roet08a,
	Abstract = {Dynamic, unanticipated adaptation of running systems
                  is of interest in a variety of situations, ranging
                  from functional upgrades to on-the-fly debugging or
                  monitoring of critical applications. In this paper
                  we study a particular form of computational
                  reflection, called unanticipated partial behavioral
                  reflection, which is particularly well-suited for
                  unanticipated adaptation of real-world systems. Our
                  proposal combines the dynamicity of unanticipated
                  reflection, i.e. reflection that does not require
                  preparation of the code of any sort, and the
                  selectivity and efficiency of partial behavioral
                  reflection. First, we propose unanticipated partial
                  behavioral reflection which enables the developer to
                  precisely select the required reifications, to
                  flexibly engineer the metalevel and to introduce the
                  meta behavior dynamically. Second, we present a
                  system supporting unanticipated partial behavioral
                  reflection in Squeak Smalltalk, called Geppetto, and
                  illustrate its use with a concrete example of a web
                  application. Benchmarks validate the applicability
                  of our proposal as an extension to the standard
                  reflective abilities of Smalltalk.},
	Annote = {internationaljournal},
	Author = {David R{\"o}thlisberger and Marcus Denker and {\'E}ric Tanter},
	Doi = {10.1016/j.cl.2007.05.001},
	Impactfactor = {Impact factor (2008) 0.421},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {scg08 scg08 scg-pub jb08 snf08 roethlisberger reflectivity marcusdenker fromscgbib},
	Medium = {2},
	Month = jul,
	Number = {2-3},
	Pages = {46--65},
	Peerreview = {yes},
	Publisher = {Elsevier},
	Title = {Unanticipated Partial Behavioral Reflection: Adapting Applications at Runtime},
	Url = {http://rmod.inria.fr/archives/papers/Roet08a-COMLAN-UPBReflectionJournal.pdf},
	Volume = {34},
  Year = {2008}}

@inproceedings{Roet09a,
	Abstract = {Mainstream IDEs generally rely on the static structure of a
  		software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
	Address = {Los Alamitos, CA, USA},
	Annote = {internationalconference},
	Author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
	Booktitle = {Proceedings of the 17th International Conference on Program Comprehension (ICPC'09)},
	Doi = {10.1109/ICPC.2008.32},
	Hal-Id = {inria-00498454},
	Inria = {RMOD},
	Inriareport = {2009},
	Isbn = {978-0-7695-3176-2},
	Keywords = {scg-pub roethlisberger kzIDE},
	Labo = {dans},
	Pages = {253--257},
	Peer = {yes},
	Publisher = {IEEE Computer Society},
	Title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
	Url = {http://rmod.inria.fr/archives/papers/Roet09a-ICPC2009-HeatMaps.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CH},
	X-Proceedings = {yes},
  Year = {2009}}

@techreport{Roet09d,
	Abstract = {Mainstream IDEs generally rely on the static structure of a
  		software project to support browsing and navigation.
		We propose HeatMaps, a simple but highly configurable technique
		to enrich the way an IDE displays the static structure of a software
		system with additional kinds of information.
		A heatmap highlights software artifacts according to various metric values,
		such as bright red or pale blue, to indicate their potential degree of interest.
		We present a prototype system that implements heatmaps, and we describe
		an initial study that assesses the degree to which different heatmaps effectively
		guide developers in navigating software.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {technicalreport},
	Author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Damien Pollet and Romain Robbes},
	Classification = {D.2.2 Tools and Techniques; D.2.3 Coding; D.2.6 Programming Environments; D.2.9 Management},
	Institution = {Institut f\"ur Informatik},
	Keywords = {scg-pub snf09 jb09 roethlisberger pharo pharo-pub kzIDE},
	Month = jul,
	Number = {IAM-09-005},
	Title = {Supporting Task-oriented Navigation in {IDEs} with Configurable HeatMaps},
	Type = {Technical Report},
	Url = {http://rmod.inria.fr/archives/reports/Roet09d-TechReport-HeatMaps.pdf},
	X-Editorial-Board = {no},
	X-International-Audience = {yes},
	X-Pays = {CH},
	X-Proceedings = {no},
	Year = {2009}}

@inproceedings{Roet09e,
	Abstract = {The IDE used in most Smalltalk dialects such as Pharo, Squeak or Cincom Smalltalk did not evolve
significantly over the last years, if not to say decades. For other languages, for instance Java, the
available IDEs made tremendous progress as Eclipse or NetBeans illustrate. While the Smalltalk
IDE served as an exemplar for many years, other IDEs caught up or even overtook the erstwhile
leader in terms of feature-richness, usability, or code navigation facilities.
In this paper we first analyze the difficulty of software navigation in the Smalltalk IDE and second
illustrate with concrete examples the features we added to the Smalltalk IDE to fill the gap to
modern IDEs and to provide novel, improved means to navigate source space. We show that
thanks to the agility and dynamics of Smalltalk, we are able to extend and enhance with reasonable
effort the Smalltalk IDE to better support software navigation, program comprehension, and software
maintenance in general. One such support is the integration of dynamic information into the static
source views we are familiar with. Other means include easing the access to static information
(for instance by better arranging important packages) or helping developers re-locating artifacts
of interest (for example with a categorization system such as smart groups).},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse and Alexandre Bergel},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST'09)},
	Hal-Id = {hal-00746247},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {scg-sub jb10 roethlisberger remoose2-pub pharo pharo-pub kzIDE},
	Labo = {dans},
	Location = {Brest, France},
	Peer = {yes},
	Publisher = {ACM Digital Library},
	Selectif = {non},
	Title = {Tackling Software Navigation Issues of the Smalltalk IDE},
	Url = {http://rmod.inria.fr/archives/workshops/Roet09e-IWST2009-obEnhancements.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CH},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Roet09f,
	Abstract = {Navigating large software systems is difficult as the various artifacts are distributed in a huge space, while the relationships between different artifacts often remain hidden and obscure. As a consequence, developers using a modern interactive development environment (IDE) are forced to open views on numerous source artifacts to reveal these hidden relationships, leading to a crowded workspace with many opened windows or tabs. Developers often lose the overview in such a cluttered workspace as IDEs provide little support to get rid of unused windows. AutumnLeaves automatically selects windows unlikely for future use to be closed or grayed out while important ones are displayed more prominently. This reduces the number of windows opened at a time and adds structure to the developer's workspace. We validate AutumnLeaves with a benchmark evaluation using recorded navigation data of various developers to determine the prediction quality of the employed algorithms.},
	Address = {Los Alamitos, CA, USA},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {David R\"{o}thlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 16th Working Conference on Reverse Engineering (WCRE 2009)},
	Hal-Id = {hal-00746246},
	Inria = {RMOD},
	Inriareport = {2009},
	Keywords = {remoose2-pub pharo pharo-pub kzIDE},
	Labo = {dans},
	Location = {Lille, France},
	Misc = {Acceptance rate: 20/79 = 25\%},
	Peer = {yes},
	Publisher = {IEEE Computer Society},
	Rate = {25\%},
	Selectif = {non},
	Title = {Autumn Leaves: Curing the Window Plague in IDEs},
	Url = {http://rmod.inria.fr/archives/papers/Roet09f-WCRE2009-AutumnLeaves-ieee.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CH},
	X-Proceedings = {yes},
  Year = {2009}}

@inproceedings{Roth11a,
	Abstract = {Navigating large software systems, even when using a modern IDE is difficult, since conceptually related software artifacts are distributed in a huge software space.
For most software maintenance tasks, only a small fraction of the entire software space is actually relevant. The IDE, however, does not reveal the task relevancy of source artifacts, thus developers cannot easily focus on the artifacts required to accomplish their tasks.
Smart Groups help developers to perform software maintenance tasks by representing groups of source artifacts that are relevant for the current task. Relevancy is determined by analyzing historical navigation and modification activities, evolutionary information, and runtime information.
The prediction quality of Smart Groups is validated with a benchmark evaluation using recorded development activities and evolutionary information from versioning systems.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalconference},
	Author = {David Rothlisberger and Oscar Nierstrasz and St\'ephane Ducasse},
	Booktitle = {Proceedings of the 19th IEEE International Conference on Program Comprehension (ICPC'11)},
	Hal-Id = {inria-00614779},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {lse-pub raweb2011 pharo pharo-pub kzIDE},
	Labo = {dans},
	Misc = {Acceptance rate: 18/76 = 23\%},
	Publisher = {IEEE Computer Society Press},
	Rate = {23\%},
	Selectif = {oui},
	Title = {SmartGroups: Focusing on Task-Relevant Source Artifacts in IDEs},
	Url = {http://rmod.inria.fr/archives/papers/Roet11a-ICPC2011-smartGroups.pdf},
	X-Country = {CH},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,CH},
	X-Proceedings = {yes},
  Year = {2011}}

@misc{Ryse11a,
	Author = {van Ryseghem, Benjamin},
	Title = {Hazelnut: dynamically creating a kernel in a reflective language},
	Url = {http://rmod.inria.fr/archives/reports/Ryse11a-Hazelnuts.pdf},
  Year = {2011}}

@techreport{Ryse12a,
	Abstract = {A first tech report about Spec, a new UI framework for widgets generation and reuse},
	Annote = {technicalReport},
	Author = {van Ryseghem, Benjamin},
	Hal-Id = {inria-00708067},
	Inria = {RMOD},
	Inriareport = {2012},
	Institution = {INRIA Lille Nord Europe},
	Keywords = {lse-pub},
	Title = {Spec - Technical Report},
	Url = {http://rmod.inria.fr/archives/reports/Ryse12a-SpecTechReport.pdf},
  Year = {2012}}

@inproceedings{Ryse12b,
	Abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
	Address = {Gent, Belgium},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
	Booktitle = {Proceedings of ESUG International Workshop on Smalltalk Technologies (IWST 2012)},
	Doi = {10.1145/2448963.2448965},
	Hal-Id = {hal-00759030},
	Inria = {RMOD},
	Inriareport = {2012},
	Isbn = {978-1-4503-1897-6},
	Keywords = {lse-pub stefPub kzIDE},
	Labo = {dans},
	Location = {Ghent, Belgium},
	Pages = {2:1--2:14},
	Publisher = {ACM},
	Selectif = {non},
	Series = {IWST '12},
	Title = {Spec, a framework for the specification and reuse of UIs and their models},
	Url = {http://rmod.inria.fr/archives/papers/Ryse12b-Spec-IWST12-Final.pdf},
	X-Country = {CL},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR,CL},
	X-Proceedings = {yes},
  Year = {2012}}

@article{Ryse14a,
	Abstract = {Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic.},
	Annote = {internationaljournal},
	Author = {van Ryseghem, Benjamin and St\'ephane Ducasse and Johan Fabry},
	Hal-Id = {hal-00915350},
	Journal = {Science of Computer Programming},
	Keywords = {lse-pub stefPub kzIDE},
	Publisher = {Elsevier},
	Title = {Seamless Composition and Reuse of Customizable User Interfaces with Spec},
	Url = {http://rmod.inria.fr/archives/papers/Ryse14a-SCICO-Spec.pdf},
  Year = {2014}}

@article{Sade02a,
	Abstract = {The concept of interfaces is central to
                  object-oriented methodologies and is one of the most
                  attractive features of {Java} and COM. Although
                  Smalltalk always had interfaces implicitly, in
                  Smalltalk interfaces are not first-class objects: t
                  hey cannot be conversed with, referred to, or
                  reflected upon. Consequently, Smalltalkers have been
                  deprived of such an important and useful tool. Since
                  a fundamental feature of Smalltalk is that just
                  about everything in the language is an
                  implementation feature, explicit, static interfaces
                  can be added to Smalltalk using Smalltalk itself
                  with ease. However, such an addition would
                  short-change the powerful dynamic aspects of
                  Smalltalk. In this article we present
                  SmallInterfaces; a new ontology of dynamic i
                  nterfaces which makes a powerful use of the dynamic
                  nature of Smalltalk. SmallInterfaces adds interfaces
                  as honorary members to Smalltalk's extensive
                  reflection mechanism, in a manner portable across
                  the many Smalltalk variants},
	Annote = {internationaljournal},
	Author = {Benny Sadeh and St\'ephane Ducasse},
	Journal = {Journal of Object Technology},
	Keywords = {scg-pub skip-doi stefPub kzLanguageDesign},
	Number = {1},
	Title = {Adding Dynamic Interfaces to {Smalltalk}},
	Url = {http://scg.unibe.ch/archive/papers/Sade02aDynamicInterfaces.pdf},
	Volume = {1},
  Year = {2002}}

@inproceedings{Salg16a,
	TITLE = {{Lowcode: Extending Pharo with C Types to Improve Performance}},
	AUTHOR = {Salgado, Ronie and Ducasse, St\{'e}phane},
	URL = {http://rmod.inria.fr/archives/papers/Salg16a-IWST16-Lowcode.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01353884},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@inproceedings{Bera16b,
	TITLE = {{A low Overhead Per Object Write Barrier for the Cog VM}},
	AUTHOR = {B\'era, Cl\'ement},
	URL = {http://rmod.inria.fr/archives/papers/Bera16b-IWST16-WriteBarrier.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01356338},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@inproceedings{Milo16a,
	TITLE = {{Inferring Types by Mining Class Usage Frequency from Inline Caches}},
	AUTHOR = {Milojkovi\'c, Nevena and B\'era, Cl\'ement and Ghafari, Mohammad and Nierstrasz, Oscar},
	URL = {http://rmod.inria.fr/archives/papers/Milo16a-IWST-DynamicTypeInference.pdf},
	BOOKTITLE = {International Workshop on Smalltalk Technologies {IWST'16}},
	ADDRESS = {Prague, Czech Republic},
	HAL-ID = {hal-01357071},
	YEAR = {2016},
	MONTH = aug,
	annote = {internationalworkshop}
}

@inproceedings{Sand13a,
	Abstract = {Understanding the root of a performance drop or improvement requires analyzing different program executions at a fine grain level. Such an analysis involves dedicated profiling and representation techniques. JProfiler and YourKit, two recognized code profilers fail, on both providing adequate metrics and visual representations, conveying a false sense of the performance variation root.
	We propose performance evolution blueprint, a visual support to precisely compare multiple software executions. Our blueprint is offered by Rizel, a code profiler to efficiently explore performance of a set of benchmarks against multiple software revisions.},
	Annote = {internationalconference},
	Author = {Sandoval Alcocer, Juan Pablo and Alexandre Bergel and St\'ephane Ducasse and Marcus Denker},
	Booktitle = {Vissoft 2013},
	Hal-Id = {hal-00849004},
	Keywords = {pharo stefPub lse-pub kzVisualization},
	Title = {Performance Evolution Blueprint: Understanding the Impact of Software Evolution on Performance},
	Url = {http://rmod.inria.fr/archives/papers/Sand13a-Vissoft-PreformanceBlueprint.pdf},
  Year = {2013}}

@inproceedings{Sand16a,
	Abstract = {Filtering, mapping, and iterating collections are frequent operations. It is known that composing a number of these operations may create intermediate collections causing an additional and unnecessary over- head. To reduce the number of intermediate collections it is often necessary to rewrite the source code and combine the operations. However, for some cases such reduction becomes aplicable only after a source code refactoring (i.e., when the collection operations are in different methods) which could introduce code duplication.
In this paper we propose Collection Promises to dynamically compose collection operations in order to reduce the number of unnecessary intermediate collections. Collection Promises delay a number of collection operations and then merge them using com- positions rules. By using Collection Promises developers can auto- matically reduce the intermediate collections even if the collection operations are in different methods.},
	Aeres = {ACT},
	Title = {Dynamically Composing Collection Operations through Collection Promises},
	Annote = {internationalworkshop},
	Author = {Juan Pablo Sandoval Alcocer and Marcus Denker and Alexandre Bergel and Yasett Acurana},
	Booktitle = {Proceedings of International Workshop on Smalltalk Technologies (IWST 2016)},
    series = {IWST'16},
	Inria = {RMOD},
    pages = {8:1--8:5},
	Inriareport = {2016},
	Keywords = {lse-pub marcusdenker},
	Hal-Id = {hal-01358347},
    isbn = {978-1-4503-4524-8},
    location = {Prague, Czech Republic},
	Peer = {yes},
    articleno = {8},
    numpages = {5},
    doi = {10.1145/2991041.2991049},
    acmid = {2991049},
    publisher = {ACM},
    address = {New York, NY, USA},
	Selectif = {non},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CZ},
	X-Proceedings = {yes},
	Url = {http://rmod.inria.fr/archives/papers/Sand16aIWSTCollectionPrimises.pdf},
 	Year = {2016}}

@inproceedings{Sant14a,
	Abstract = {In this paper, we report an experience on using and adapting Semantic Clustering to evaluate software remodularizations. Semantic Clustering is an approach that relies on information retrieval and clustering techniques to extract sets of similar classes in a system, according to their vocabularies. We adapted Semantic Clustering to support remodularization analysis. We evaluate our adaptation using six real-world remodularizations of four software systems. We report that Semantic Clustering and conceptual metrics can be used to express and explain the intention of the architects when performing common modularization operators, such as module decomposition.},
	Author = {Gustavo Santos and Marco T\'ulio Valente and Nicolas Anquetil},
	Booktitle = {Software Maintenance, Reengineering and Reverse Engineering (CSMR-WCRE), 2014 Software Evolution Week-IEEE Conference on},
	Hal-Id = {hal-00904409},
	Keywords = {moose lse-pub cutter kzChecking},
	Misc = {acceptance rate: 27/86 = 31\%},
	Pages = {224--33},
	Pdf = {http://rmod.inria.fr/archives/papers/Sant14-CSMRWCRE-SemanticClustering.pdf},
	Selectif = {oui},
        annote = {internationalconference},
	Tagnicolasa = {architecture},
	Title = {Remodularization Analysis Using Semantic Clustering},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2014}}

@inproceedings{Sant15a,
	Author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {31st IEEE International Conference on Software Maintenance and Evolution},
	Hal-Id = {hal-01185637},
	Keywords = {moose lse-pub kzAnalysis},
	Abstract={During its lifetime, a software system might undergo a major transformation effort in its structure, for example to mi- grate to a new architecture or bring some drastic improvements to the system. Particularly in this context, we found evidences that some sequences of code changes are made in a systematic way. These sequences are composed of small code transformations (e.g., create a class, move a method) which are repeatedly applied to groups of related entities (e.g., a class and some of its methods). A typical example consists in the systematic introduction of a Factory design pattern on the classes of a package. We define these sequences as transformation patterns. In this paper, we identify examples of transformation patterns in real world software systems and study their properties: (i) they are specific to a system; (ii) they were applied manually; (iii) they were not always applied to all the software entities which could have been transformed; (iv) they were sometimes complex; and (v) they were not always applied in one shot but over several releases. These results suggest that transformation patterns could benefit from automated support in their application. From this study, we propose as future work to develop a macro recorder, a tool with which a developer records a sequence of code transformations and then automatically applies them in other parts of the system as a customizable, large-scale transformation operator.},
	Misc = {acceptance rate: 32/148 = 22\%},
	Pages = {},
	Pdf = {http://rmod.inria.fr/archives/papers/Sant15a-ICSME-TransformationPatterns.pdf},
	URL = {http://rmod.inria.fr/archives/papers/Sant15a-ICSME-TransformationPatterns.pdf},
	Selectif = {oui},
	annote = {topconference},
	Tagnicolasa = {analysis},
	Title = {System Specific, Source Code Transformations},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}

@inproceedings{Sant15b,
	Author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and St\'ephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {15th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM'15)},
	Hal-Id = {hal-01185639},
	Keywords = {moose lse-pub kzAnalysis},
	Abstract = {During its lifetime, a software system is under continuous maintenance to remain useful. Maintenance can be achieved in activities such as adding new features, fixing bugs, improving the system’s structure, or adapting to new APIs. In such cases, developers sometimes perform sequences of code changes in a systematic way. These sequences consist of small code changes (e.g., create a class, then extract a method to this class), which are applied to groups of related code entities (e.g., some of the methods of a class). This paper presents the design and proof-of-concept implementation of a tool called MACRORECORDER. This tool records a sequence of code changes, then it allows the developer to generalize this sequence in order to apply it in other code locations. In this paper, we discuss MACRORECORDER’s approach that is independent of both development and transformation tools. The evaluation is based on previous work on repetitive code changes related to rearchitecting. MACRORECORDER was able to replay 92% of the examples, which consisted in up to seven code entities modified up to 66 times. The generation of a customizable, large-scale transformation operator has the potential to efficiently assist code maintenance},
	Pages = {},
	Pdf = {http://rmod.inria.fr/archives/papers/Sant15b-SCAM-MacroRecorder.pdf},
	URL = {http://rmod.inria.fr/archives/papers/Sant15b-SCAM-MacroRecorder.pdf},
	Selectif = {oui},
	annote = {internationalconference},
	Tagnicolasa = {transformation},
	Title = {Recording and Replaying System Specific, Source Code Transformations},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}

@inproceedings{Sant15c,
	Author = {Gustavo Santos and Nicolas Anquetil and Anne Etien and Stephane Ducasse and Marco T\'ulio Valente},
	Booktitle = {3rd IEEE Working Conference on Software Visualization (VISSOFT 2015) -- Tool track},
	Hal-Id = {hal-01185635},
	Keywords = {moose lse-pub},
	Abstract={Many techniques have been proposed in the literature to support architecture definition, conformance, and analysis. However, there is a lack of adoption of such techniques by the industry. Previous work have analyzed this poor support. Specifically, former approaches lack proper analysis techniques (e.g., detection of architectural inconsistencies), and they do not provide extension and addition of new features. In this paper, we present ORIONPLANNING, a prototype tool to assist refactorings at large scale. The tool provides support for model- based refactoring operations. These operations are performed in an interactive visualization. The contributions of the tool consist in: (i) providing iterative modifications in the architecture, and (ii) providing an environment for architecture inspection and definition of dependency rules. We evaluate ORIONPLANNING against practitioners' requirements on architecture definition listed in a previous survey. We also evaluate the tool in a concrete example of software remodularization.},
	Pages = {},
	Pdf = {http://rmod.inria.fr/archives/papers/Sant15c-VISSOFT-OrionPlanning.pdf},
	URL = {http://rmod.inria.fr/archives/papers/Sant15c-VISSOFT-OrionPlanning.pdf},
	Selectif = {yes},
	annote = {internationalconference},
	Tagnicolasa = {transformation architecture},
	Title = {OrionPlanning: Improving Modularization and Checking Consistency on Software Architecture},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}

@inproceedings{Scha02a,
	Abstract = {We present a simple, component-based model of
                  mixins, called traits, and argue that this simple
                  model sidesteps many of the practical problems with
                  other approaches to mixins and multiple inheritance.
                  With our model, classes are built from a set of
                  traits by specifying glue code that connects them
                  together and accesses the necessary state. We
                  briefly discuss practical experience with an
                  implementation of traits for Squeak, and we list a
                  number of open questions for discussion.},
	Annote = {internationalworkshop},
	Author = {Nathanael Sch{\"a}rli and St\'ephane Ducasse and Oscar Nierstrasz},
	Booktitle = {Proceedings of the International Workshop on Inheritance},
	Keywords = {scg-pub stefPub kzTrait},
	Title = {Classes = Traits + States + Glue (Beyond mixins and multiple inheritance)},
	Url = {http://scg.unibe.ch/archive/papers/Scha02aTraitsPlusGlue2002.pdf},
  Year = {2002}}

@techreport{Scha02b,
	Abstract = {Inheritance is the fundamental reuse mechanism in
                  object-oriented programming languages; its most
                  prominent variants are single inheritance, multiple
                  inheritance, and mixin inheritance. In the first
                  part of this paper, we identify and illustrate the
                  conceptual and practical reusability problems that
                  arise with these forms of inheritance. We then
                  present a simple compositional model for structuring
                  object-oriented programs, which we call traits.
                  Traits are essentially groups of methods that serve
                  as building blocks for classes and are primitive
                  units of code reuse. In this model, classes are
                  composed from a set of traits by specifying glue
                  code that connects the traits together and accesses
                  the necessary state. We demonstrate how traits
                  overcome the problems arising with the different
                  variants of inheritance, we discuss how traits can
                  be implemented effectively, and we summarize our
                  experience applying traits to refactor an existing
                  class hierarchy.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {report notrefereed},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf-redundant scg-pub skip-doi jb02 scg-traits stefPub kzTrait},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-014, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-005},
	Title = {Traits: Composable Units of Behavior},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Scha02bTraits.pdf},
  Year = {2002}}

@techreport{Scha02c,
	Abstract = {Single-inheritance in object-oriented languages can
                  lead to duplicated code in rich class libraries
                  where feature-sharing cannot be linearized.
                  Multiple-inheritance and mixins alleviate this
                  problem, but lead to other difficulties in the face
                  of evolution. Changes to classes or mixins can break
                  code lower in the hierarchy in unexpected ways.
                  Traits solve both problems by factoring out shared
                  behaviour as sets of methods that do not depend on
                  state. Traits have the important property that
                  composition is symmetric, so changes do not lead to
                  unexpected side effects. We present a formal model
                  of traits, and define some basic properties of
                  traits and classes.},
	Address = {Universit\"at Bern, Switzerland},
	Annote = {notrefereed},
	Author = {Nathanael Sch\"arli and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Andrew Black},
	Classification = {D.3.1 Formal Definitions and Theory; D.1.5 Object-oriented Programming; D.3.3 Language Constructs and Features},
	Institution = {Institut f\"ur Informatik},
	Keywords = {snf03 scg-pub skip-doi jb02 scg-traits schaerli kzTrait},
	Month = nov,
	Note = {Also available as Technical Report CSE-02-013, OGI School of Science \& Engineering, Beaverton, Oregon, USA},
	Number = {IAM-02-006},
	Title = {Traits: The Formal Model},
	Type = {Technical Report},
	Url = {http://scg.unibe.ch/archive/papers/Scha02cTraitsModel.pdf},
  Year = {2002}}

@inproceedings{Scha03a,
	Abstract = {Despite the undisputed prominence of inheritance as
                  the fundamental reuse mechanism in object-oriented
                  programming languages, the main variants --- single
                  inheritance, multiple inheritance, and mixin
                  inheritance --- all suffer from conceptual and
                  practical problems. In the first part of this paper,
                  we identify and illustrate these problems. We then
                  present traits, a simple compositional model for
                  structuring object-oriented programs. A trait is
                  essentially a group of pure methods that serves as a
                  building block for classes and is a primitive unit
                  of code reuse. In this model, classes are composed
                  from a set of traits by specifying glue code that
                  connects the traits together and accesses the
                  necessary state. We demonstrate how traits overcome
                  the problems arising from the different variants of
                  inheritance, we discuss how traits can be
                  implemented effectively, and we summarize our
                  experience applying traits to refactor an existing
                  class hierarchy.},
	Acceptnum = {18},
	Accepttotal = {88},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
	Booktitle = {Proceedings of European Conference on Object-Oriented Programming},
	Cvs = {TraitsECOOP2003},
	Doi = {10.1007/b11832},
	Isbn = {978-3-540-40531-3},
	Keywords = {scg-pub traits stefPub kzTrait},
	Misc = {acceptance rate: 18/88 = 20\%},
	Month = jul,
	Pages = {248--274},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Traits: Composable Units of Behavior},
	Url = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
	Volume = {2743},
  Year = {2003}}

@inproceedings{Scha04a,
	Abstract = {Given the importance of encapsulation to
                  object-oriented programming, it is surprising to
                  note that mainstream object-oriented languages offer
                  only limited and fixed ways of encapsulating
                  methods. Typically one may only address two
                  categories of clients, users and heirs, and one must
                  bind visibility and access rights at an early stage.
                  This can lead to inflexible and fragile code as well
                  as clumsy workarounds. We propose a simple and
                  general solution to this problem in which
                  encapsulation policies can be specified separately
                  from implementations. As such they become
                  first-class composable entities that can be reused
                  by different classes. We present a detailed analysis
                  of the problem with encapsulation and visibility
                  mechanisms in mainstream OO languages, we introduce
                  our approach in terms of a simple model, and we
                  evaluate how our approach compares with existing
                  approaches. We also assess the impact of
                  incorporating encapsulation policies into Smalltalk
                  and discuss some implementation issues.},
	Acceptnum = {25},
	Accepttotal = {132},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Roel Wuyts},
	Booktitle = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'04)},
	Cvs = {EncapsulationPoliciesECOOP2004},
	Doi = {10.1007/b98195},
	Isbn = {978-3-540-22159-3},
	Keywords = {scg-pub stefPub kzLanguageDesign},
	Misc = {acceptance rate: 25/132 = 19\%},
	Month = jun,
	Pages = {26--50},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Composable Encapsulation Policies},
	Url = {http://scg.unibe.ch/archive/papers/Scha04aEncapsulationPolicies.pdf},
	Volume = {3086},
  Year = {2004}}

@inproceedings{Scha04b,
	Abstract = {Encapsulation in object-oriented languages has
                  traditionally been based on static type systems. As
                  a consequence, dynamically-typed languages have only
                  limited support for encapsulation. This is
                  surprising, considering that encapsulation is one of
                  the most fundamental and important concepts behind
                  object-oriented programming and that it is essential
                  for writing programs that are maintainable and
                  reliable, and that remain robust as they evolve. In
                  this paper we describe the problems that are caused
                  by insufficient encapsulation mechanisms and then
                  present object-oriented encapsulation, a simple and
                  uniform approach that solves these problems by
                  bringing state of the art encapsulation features to
                  dynamically typed languages. We provide a detailed
                  discussion of our design rationales and compare them
                  and their consequences to the encapsulation
                  approaches used for statically typed languages. We
                  also describe an implementation of object-oriented
                  encapsulation in Smalltalk. Benchmarks show that
                  extensive use of object-oriented encapsulation
                  results in a slowdown of less than 15 per cent.},
	Acceptnum = {27},
	Accepttotal = {174},
	Annote = {internationalconference topconference},
	Author = {Nathanael Sch\"arli and Andrew P. Black and St\'ephane Ducasse},
	Booktitle = {Proceedings of 18th International Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA'04)},
	Cvs = {OOEncapsulationOOPSLA2004},
	Doi = {10.1145/1028976.1028988},
	Keywords = {scg-pub stefPub kzLanguageDesign},
	Misc = {acceptance rate: 27/174 = 16\%},
	Month = oct,
	Pages = {130--149},
	Title = {Object-oriented Encapsulation for Dynamically Typed Languages},
	Url = {http://scg.unibe.ch/archive/papers/Scha04bOOEncapsulation.pdf},
  Year = {2004}}

@inproceedings{Seeb06b,
	Abstract = {To understand a certain issue of the system we want
                  to ask the knowledgeable developers. Yet, in large
                  systems, not every developer is knowledgeable in all
                  the details of the system. Thus, we would want to
                  know which developer is knowledgeable in the issue
                  at hand. In this paper we present the Chronia tool
                  that implements the Ownership Map visu- alization to
                  understand when and how different developers
                  interacted in which way and in which part of the
                  system. circle reflects the size of the change, and
                  the color of the line denotes the author who owns
                  most of the lines of code of the file in that
                  period. File A commit by the green author followed
                  by the ownership file removed by the blue author
                  file present from the first import},
	Annote = {tooldemo},
	Author = {Mauricio Seeberger and Adrian Kuhn and Tudor G\^irba and St\'ephane Ducasse},
	Booktitle = {Proceedings of 10th European Conference on Software Maintenance and Reengineering (CSMR'06)},
	Cvs = {ChroniaDemoCSMR2006},
	Keywords = {scg-misc moose stefPub kzVisualization girba chronia},
	Month = mar,
	Note = {Tool demo},
	Pages = {345--346},
	Title = {{Chronia}: Visualizing How Developers Change Software Systems},
	Url = {http://scg.unibe.ch/archive/papers/Seeb06bChronia.pdf},
  Year = {2006}}

@inproceedings{Silv15a,
	Acceptnum = {46},
	Accepttotal = {144},
	Address = {Montreal, Canada},
	Aeres = {ACT},
	Aeresstatus = {aeres15},
	Annote = {internationalconference},
	Author = {Leonardo Humberto Silva and Miguel Ramos and Marco T\'ulio Valente and Alexandre Bergel and Nicolas Anquetil},
	Booktitle = {Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER'15)},
	Inria = {RMOD},
	Inriareport = {2015},
	hal-id = {hal-01185854},
	Url = {http://rmod.inria.fr/archives/papers/silv15a-Saner-Javascript-classes.pdf},
	Keywords = {moose lse-pub raweb2015 pharo},
	Labo = {dans},
	Misc = {acceptance rate: 46/144 = 32\%},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {Does Javascript Software Embrace Classes?},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}

@inproceedings{Silv15b,
	Author = {Luciana L. Silva and Marco T\'ulio Valente and Marcelo Maia and Nicolas Anquetil},
	Booktitle = {Proceedings of the 31st IEEE International Conference on Software Maintenance},
	Hal-Id = {hal-01185865},
	Keywords = {moose lse-pub},
	Misc = {acceptance rate: 32/148 = 22\%},
	url = {http://rmod.inria.fr/archives/papers/silv15bICSM-cochange-patterns.pdf},
	Selectif = {oui},
        annote = {topconference internationalconference},
	Tagnicolasa = {architecture},
	Title = {Developers' Perception of Co-Change Patterns: An Empirical Study},
	X-Country = {BR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
	Year = {2015}}


@inproceedings{Sing10a,
	Acmid = {1925815},
	Address = {Riverton, NJ, USA},
	Annote = {invited},
	Author = {Singer, Janice and Lethbridge, Timothy and Vinson, Norman and Anquetil, Nicolas},
	Booktitle = {CASCON First Decade High Impact Papers},
	Doi = {10.1145/1925805.1925815},
	Location = {Toronto, Ontario, Canada},
	Numpages = {15},
	Pages = {174--188},
	Publisher = {IBM Corp.},
	Series = {CASCON '10},
	Tagnicolasa = {analysis},
	Title = {An Examination of Software Engineering Work Practices},
	Url = {http://dx.doi.org/10.1145/1925805.1925815},
  Year = {2010}}

@inproceedings{Sing97a,
	Abstract = {This paper presents work practice data of the daily activities of software engineers. Four separate studies are presented; one looking longitudinally at an individual SE; two looking at a software engineering group; and one looking at company-wide tool usage statistics. We also discuss the advantages in considering work practices in designing tools for software engineers, and include some requirements for a tool we have developed as a result of our studies.},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {Singer, Janice and Lethbridge, Timothy and Vinson, Norman and Anquetil, Nicolas},
	Booktitle = {Proceedings of the 1997 conference of the Centre for Advanced Studies on Collaborative research},
	Labo = {non},
	Location = {Toronto, Ontario, Canada},
	Pages = {21--},
	Publisher = {IBM Press},
	Selectif = {oui},
	Series = {CASCON '97},
	Tagnicolasa = {analysis},
	Title = {An examination of software engineering work practices},
	Url = {http://rmod.inria.fr/archives/papers/Sing97a-SoftwareEngineeringWorkPractices.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CA},
  Year = {1997}}

@inproceedings{Sous04a,
	Abstract = {Developing and maintaining software systems is a knowledge intensive task. One needs knowledge of the application domain of the software, the problem the system solves, the requirements for this problem, the architecture of the system and how the different parts fit together, how the system interacts with its environment, etc. More often than not, this knowledge is not documented and lives only in the head of the software engineers. It is, therefore, volatile and an organization may repeatedly pay professionals to rediscover a knowledge it previously acquired and lost. In recognition of this fact, knowledge management techniques such as Postmortem Analysis are being used to help salvage this knowledge. Traditionally, Postmortem Analysis has been applied at the end of software development projects with a focus on organizational aspects such as how to improve the execution of a process. In this paper, we present the application of Postmortem Analysis in a new context: for software maintenance projects. We also apply it, not only for process improvement, but to discover knowledge on the software maintained itself.},
	Aeres = {ACT},
	Annote = {internationalworkshop},
	Author = {Kleiber D. de Sousa and Nicolas Anquetil and K{\'a}thia Mar\c{c}al de Oliveira},
	Booktitle = {Advances in Learning Software Organizations, 6th International Workshop, LSO 2004},
	Isbn = {3-540-22192-1},
	Labo = {hors},
	Pages = {67-77},
	Publisher = {Springer},
	Selectif = {oui},
	Series = {Lecture Notes in Computer Science},
	Tagnicolasa = {knowledge},
	Title = {Learning Software Maintenance Organizations},
	Volume = {3096},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
	Year = {2004}}

@inproceedings{Sous08b,
	Abstract = {In this paper, we present a model-driven traceability framework to software product line (SPL) development. Model-driven techniques are adopted with the aim to support the flexible specification of trace links between different kinds of SPL artefacts. A traceability metamodel is defined to support the flexible creation and storage of the SPL trace links. The framework is organized as a set of extensible plug-ins that can be instantiated to create customized trace queries and views. It is implemented based on the Eclipse platform and EMF technology. We illustrate a concrete instantiation of the framework to support the tracing between feature and use cases models.},
	Address = {Norway},
	Aeres = {ACL},
	Annote = {internationalworkshop},
	Author = {Andr\'e Sousa and Uir\'a Kulesza and Andreas Rummler and Nicolas Anquetil, Ralf Mitschke and Ana Moreira and Vasco Amaral and Jo\~{a}o Ara\'ujo},
	Booktitle = {ECMDA Traceability Workshop Proceedings},
	Labo = {non},
	Month = {jun},
	Publisher = {SINTEF ICT},
	Selectif = {non},
	Tagnicolasa = {traceability SPL},
	Title = {A Model-Driven Traceability Framework to Software Product Line Development},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	Year = {2008}}

@inproceedings{Souz05a,
	Abstract = {Software engineering has been striving for years to improve the practice of software development and maintenance. Documentation has long been prominent on the list of recommended practices to improve development and help maintenance. Recently however, agile methods started to shake this view, arguing that the goal of the game is to produce software and that documentation is only useful as long as it helps to reach this goal.On the other hand, in the re-engineering field, people wish they could re-document useful legacy software so that they may continue maintain them or migrate them to new platform.In these two case, a crucial question arises: "How much documentation is enough?" In this article, we present the results of a survey of software maintainers to try to establish what documentation artifacts are the most useful to them.},
	Address = {New York, NY, USA},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {de Souza, Sergio Cozzetti B. and Anquetil, Nicolas and de Oliveira, K\'{a}thia M.},
	Booktitle = {Proceedings of the 23rd annual international conference on Design of communication: documenting \& designing for pervasive information},
	Doi = {10.1145/1085313.1085331},
	Isbn = {1-59593-175-9},
	Keywords = {empirical study, program understanding, software maintenance, software system documentation},
	Labo = {non},
	Location = {Coventry, United Kingdom},
	Pages = {68--75},
	Publisher = {ACM},
	Selectif = {oui},
	Series = {SIGDOC '05},
	Tagnicolasa = {knowledge},
	Title = {A study of the documentation essential to software maintenance},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2005}}

@article{Souz06a,
	Abstract = {Software engineering has been striving for years to improve the practice of software development and maintenance. Documentation has long been prominent on the list of recommended practices to improve development and help maintenance. Recently however, agile methods started to shake this view, arguing that the goal of the game is to produce software and that documentation is only useful as long as it helps to reach this goal. On the other hand, in the re-engineering field, people wish they could re-document useful legacy software so that they may continue maintain them or migrate them to new platform. In these two case, a crucial question arises: "How much documentation is enough?" In this article, we present the results of a survey of software maintainers to try to establish what documentation artifacts are the most useful to
them.},
	Aeres = {ACLN},
	Annote = {nationaljournal},
	Author = {Souza, Sergio Cozzetti B. de and Anquetil, Nicolas and Oliveira, K\'{a}thia M. de},
	Doi = {10.1007/BF03194494},
	Inria = {hors},
	Issn = {0104-6500},
	Journal = {Journal of the Brazilian Computer Society},
	Labo = {hors},
	Pages = {31--44},
	Selectif = {oui},
	Tagnicolasa = {knowledge},
	Title = {Which documentation for software maintenance?},
	Url = {http://www.scielo.br/pdf/jbcos/v12n3/04.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {no},
  Year = {2006}}

@incollection{Stein12a,
	Abstract = {Developers continuously design their programs. For
                  example, developers strive for simplicity and
                  consistency in their constructions like
                  practitioners in most design fields. A simple
                  program design supports working on current and
                  future development tasks. While many problems
                  addressed by developers have characteristics similar
                  to design problems, developers typically do not use
                  principles and practices dedicated to such problems.
                  In this chapter we report on the adoption of design
                  practices for programming. First, we propose a new
                  concept for integrated programming environments that
                  encourages developers to work with concrete
                  representations of abstract thoughts within a
                  flexible canvas. Second, we present continuous
                  versioning as our approach to support the need for
                  withdrawing changes during program design
                  activities.},
	Author = {Steinert, Bastian and Taeumel, Marcel and Cassou, Damien and Hirschfeld, Robert},
	Booktitle = {Design Thinking Research},
	Doi = {10.1007/978-3-642-31991-4\_14},
	Publisher = {Springer},
	Title = {Adopting Design Practices for Programming},
  Year = {2012}}

@inproceedings{Stein12b,
  Acmid        = {2384591},
  Address      = {New York, NY, USA},
  Author       = {Steinert, Bastian and Cassou, Damien and Hirschfeld,
                  Robert},
  Booktitle    = {DLS'12: Proceedings of the 8th Dynamic Languages
                  Symposium},
  Doi          = {10.1145/2384577.2384591},
  Isbn         = {978-1-4503-1564-7},
  Keywords     = {continuous testing, continuous versioning,
                  debugging, evolution, explore-first programming,
                  fault localization, prototyping},
  Location     = {Tucson, Arizona, USA},
  Numpages     = {12},
  Pages        = {107--118},
  Publisher    = {ACM},
  Selectif     = {non},
  Series       = {DLS'12},
  Title        = {{CoExist}: Overcoming Aversion to Change -
                  Preserving Immediate Access to Source Code and
                  Run-time Information of Previous Development States},
  Url          = {http://doi.acm.org/10.1145/2384577.2384591},
  Year         = {2012},
  Acceptnum    = {10},
  Accepttotal  = {23}
}

@misc{Stin05a,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {Serge Stinckwich and St\'ephane Ducasse},
	Inria = {hors},
	Journal = {Linux Pratique},
	Keywords = {stefPub kzVulgarisation},
	Month = nov,
	Number = 32,
	Pages = {18--23},
	Selectif = {non},
	Title = {La syntaxe Smalltalk},
	Volume = 1,
	Year = {2005}}

@misc{Stin06a,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {Serge Stinckwich and St\'ephane Ducasse},
	Inria = {hors},
	Journal = {Linux Pratique},
	Keywords = {stefPub kzVulgarisation},
	Month = jan,
	Number = 33,
	Pages = {18--23},
	Selectif = {non},
	Title = {Les structures de contr\^ole en Smalltalk},
	Volume = 1,
	Year = {2006}}

@misc{Stin06b,
	Aeres = {OV},
	Annote = {vulgarisation},
	Author = {Serge Stinckwich and Hilaire Fernandes},
	Inria = {hors},
	Journal = {Linux Magazine},
	Month = jun,
	Number = 84,
	Pages = {18--23},
	Selectif = {non},
	Title = {Nos premi\`eres classes en Smalltalk},
	Volume = 1,
	Year = {2006}}

@inproceedings{Suen07a,
	Annote = {internationalworkshop stefPub},
	Author = {Mathieu Suen and St\'ephane Ducasse and Damien Pollet and Hani Abdeen and Ilham Alloui},
	Booktitle = {FAMOOSr, 1st Workshop on FAMIX and Moose in Reengineering},
	Keywords = {moose kzVisualization},
	Title = {Package Surface Blueprint: A Software Map},
	Year = {2007}}

@inproceedings{Suny01a,
	Address = {Toronto, Canada},
	Annote = {internationalconference},
	Author = {Suny\'e, Gerson and Pollet, Damien and Le~Traon, Yves and J\'ez\'equel, Jean-Marc},
	Booktitle = {UML~2001 --- The Unified Modeling Language --- Modeling Languages, Concepts, and Tools},
	Editor = {Gogolla, Martin and Kobryn, Cris},
	Isbn = {3-540-42667-1},
	Month = oct,
	Note = {Ten-Year Most Influential Paper Award at Models 2011},
	Pages = {134--148},
	Publisher = {Springer Verlag},
	Series = {LNCS},
	Title = {Refactoring UML Models},
	Url = {http://www.irisa.fr/triskell/publis/2001/Sunye01b.pdf},
	Volume = {2185},
  Year = {2001}}

@techreport{Tant05a,
	Aeres = {ACT},
	Author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
	Inria = {hors},
	Institution = {University of Chile},
	Keywords = {fromscgbib marcusdenker},
	Note = {published to Software Composition (SC'06)},
	Number = {TR/DCC-2005-12},
	Selectif = {non},
	Title = {Context-aware aspects},
	Year = {2005}}

@inproceedings{Tant06a,
	Abstract = {Context-aware applications behave differently
                  depending on the context in which they are running.
                  Since context-specific behavior tends to crosscut
                  base programs, it can advantageously be implemented
                  as aspects. This leads to the notion of
                  context-aware aspects, e.g., aspects whose behavior
                  depends on context. This paper analyzes the issue of
                  appropriate support from the aspect language to both
                  restrict the scope of aspects according to the
                  context and allow aspect definitions to access
                  information associated to the context. We propose an
                  open framework for context-aware aspects that allows
                  for the definition of first-class contexts and
                  supports the definition of context awareness
                  constructs for aspects, including the ability to
                  refer to past contexts, and to provide domain- and
                  application-specific constructs.},
	Address = {Vienna, Austria},
	Aeres = {ACT},
	Annote = {internationalconference},
	Author = {{\'E}ric Tanter and Kris Gybels and Marcus Denker and Alexandre Bergel},
	Booktitle = {Proceedings of the 5th International Symposium on Software Composition (SC 2006)},
	Doi = {10.1007/11821946\_15},
	Inria = {hors},
	Isbn = {978-3-540-37657-6},
	Keywords = {scg-pub jb06 fb06 snf06 fromscgbib marcusdenker},
	Medium = {2},
	Month = mar,
	Pages = {227--242},
	Peerreview = {yes},
	Selectif = {non},
	Series = {LNCS},
	Title = {Context-Aware Aspects},
	Url = {http://rmod.inria.fr/archives/papers/Tant06a-SC06-ContextAspects.pdf},
	Volume = {4089},
	Year = {2006}}

@inproceedings{Teru13a,
	Abstract = {More and more software systems are now made of multiple collaborating third-party components. Enabling fine-grained control over the communication between components becomes a major requirement. While software isolation has been studied for a long time in operating systems (OS), most programming languages lack support for isolation. In this context we explore the notion of proxy. A proxy is a surrogate for another object that controls access to this object. We are particularly interested in generic proxy implementations based on language-level reflection. We present an analysis that shows how these reflective proxies can propagate a security policy thanks to the transitive wrapping mechanism. We present a prototype implementation that support transitive wrapping and allows a fine-grained control over an isolated object graph.},
	Annote = {internationalworkshop},
	Audience = {international},
	Author = {Teruel, Camille and Cassou, Damien and Ducasse, St{\'e}phane},
	Booktitle = {{DYLA - 7th Workshop on Dynamic Languages and Applications, Collocated with 26th European Conference on Object-Oriented Programming - 2013}},
	Inria = {RMOD},
	Hal-id ={hal-00834320},
	Keywords = {lse-pub stefPub kzLanguageDesign},
	Pdf = {http://hal.inria.fr/hal-00834320/PDF/main.pdf},
	URL = {http://rmod.inria.fr/archives/papers/Teru13a-Dyla-ObjectGraph},
	Selectif = {non},
	Title = {{Object Graph Isolation with Proxies}},
	X-Language = {EN},
	Year = {2013}}

@article{Teru15a,
	Author = {Teruel, Camille and Wernli, Erwann and Ducasse, St{\'e}phane and Nierstrasz, Oscar},
	journal = {Transactions on Aspect-Oriented Software Development (TAOSD)},
	Title = {Propagation of Behavioral Variations with Delegation Proxies},
	Hal-Id = {hal-01135706},
	Keywords = {lse-pub stefPub kzLanguageDesign},
	Pages = {63--95},
	Abstract = {Scoping behavioral variations to dynamic extents is useful to support non-functional concerns that otherwise result in cross-cutting code. Unfortunately, such forms of scoping are difficult to obtain with traditional reflection or aspects. We propose delegation proxies, a dynamic proxy model that supports behavioral intercession through the interception of various interpretation operations. Delegation proxies permit different behavioral variations to be easily composed together. We show how delegation proxies enable behavioral variations that can propagate to dynamic extents. We demonstrate our approach with examples of behavioral variations scoped to dynamic extents that help simplify code related to safety, reliability, and monitoring.},
	Publisher = {Springer},
	Annote = {internationaljournal},
	Url = {http://rmod.inria.fr/archives/papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf},
	PDF = {http://rmod.inria.fr/archives/papers/Teru15a-Propagation-of-Behavioral-Variations-with-Delegation-Proxies.pdf},
	Year = {2015}}


@inproceedings{Teru15b,
  Abstract     = {Reflection is a powerful programming language
                  feature that enables language extensions, generic
                  code, dynamic analyses, development tools, etc.
                  However, uncontrolled reflection breaks object
                  encapsulation and considerably increases the attack
                  surface of programs e.g., malicious libraries can
                  use reflection to attack their client applications.
                  To bring reflection and object encapsulation back
                  together, we use dynamic object ownership to design
                  an access control policy to reflective operations.
                  This policy grants objects full reflective power
                  over the objects they own but limited reflective
                  power over other objects. Code is still able to use
                  advanced reflective operations but reflection cannot
                  be used as an attack vector anymore.},
  Annote       = {internationalconference},
  Audience     = {international},
  HAL-ID       = {hal-01217041},
  Author       = {Teruel, Camille and Ducasse, St{\'e}phane and
                  Cassou, Damien and Marcus Denker},
  Booktitle    = {Dynamic Languages Symposium (DLS'2015)},
  Inria        = {RMOD},
  Keywords     = {lse-pub stefPub kzLanguageDesign},
  PDF          =
                  {http://rmod.inria.fr/archives/papers/Teru15b-DLS15-AccessControlWithOwnership.pdf},
  DOI          = {10.1145/2816707.2816721},
  Title        = {Access Control to Reflection with Object Ownership},
  Year         = {2015},
  Acceptnum    = {14},
  Accepttotal  = {40}
}

@phdthesis{Teru16a,
	Abstract = {Users expect modern software to be both continually available and updated on the fly. Introduction of new features and integration of bug fixes should not trouble the smooth running of an application. Developers also benefit from dynamic modifications of software, e.g. they can adapt code to new unanticipated situations or they can run dynamic analyses to get feedback about the behavior of running applications for monitoring, debugging and optimization purposes. Programming languages and their runtimes should thus provides developers with mechanisms that improve software adaptability. At the same time, the increasing size and complexity of software call for applications made up of many interacting components developed by different parties. In this context, either all components are trusted or each component needs to be properly protected from other ones. For example, a plugin should not be able to manipulate the internal structures or leaks private data of its host application unrestrictedly. Likewise, a malicious library should not be able to corrupt its clients or interfere with their operations. Programming languages should thus provide developers with mechanisms that improve software isolation, such as encapsulation and custom access control policies. The need for dynamic adaptations that can change nearly every aspect of an application on the one hand and the need for properly confined components on the other hand pulls programming language design in two opposite directions: ei- ther more flexibility or more control. This dissertation studies this tension in the context of dynamically-typed object-oriented languages with two language mechanisms that promote software adaptability: reflection and extension methods. For both mechanisms, we demonstrate their usefulness, their harmful effect on encap- sulation and propose solutions to retain their power while maintaining encapsulation.},
	Author = {Camille Teruel},
	Hal-Id = {tel-01290364},
	Month = jan,
	School = {Universit\'{e} Lille 1 - France},
	Title = {Adaptability and Encapsulation in Dynamically-Typed Languages: Taming Reflection and Extension Methods},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2016-Teruel.pdf},
  Year = {2016}}

@inproceedings{Tich00b,
	Abstract = {Refactoring --- transforming code while preserving
                  behaviour --- is currently considered a key approach
                  for improving object-oriented software systems.
                  Unfortunately, all of the current refactoring tools
                  depend on language-dependent refactoring engines,
                  which prevents a smooth integration with mainstream
                  development environments. In this paper we
                  investigate the similarities between refactorings
                  for Smalltalk and {Java}, derive a
                  language-independent meta-model and show that it is
                  feasible to build a language-independent refactoring
                  engine on top of this meta-model. Our feasibility
                  study is validated by means of a tool prototype
                  which uses the same engine to refactor both
                  Smalltalk and {Java} code. Using our approach we
                  minimize the language-dependent part of refactoring
                  tools, providing a standard way for programmers and
                  tools to perform refactorings no matter what
                  language they work in.},
	Acceptnum = {22},
	Accepttotal = {51},
	Annote = {internationalconference},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer and Oscar Nierstrasz},
	Booktitle = {Proceedings of International Symposium on Principles of Software Evolution},
	Doi = {10.1109/ISPSE.2000.913233},
	Keywords = {reengineering refactoring FAMIX repositories scg-pub stefPub moose kzMeta},
	Misc = {acceptance rate: 22/51 = 43\%},
	Pages = {157--167},
	Publisher = {IEEE Computer Society Press},
	Series = {ISPSE'00},
	Title = {A Meta-model for Language-Independent Refactoring},
	Url = {http://scg.unibe.ch/archive/papers/Tich00bRefactoringMetamodel.pdf},
  Year = {2000}}

@inproceedings{Tich00m,
	Abstract = {In the FAMOOS project we have developed a set of
                  tools for reengineering object-oriented legacy
                  systems. These tools are based on the FAMIX meta
                  model and exchange information using CDIF, an
                  industry standard exchange format. For several
                  reasons XMI, an emerging standard for information
                  exchange, has appealed to us to be used as our
                  interchange format. In this paper we discuss why XMI
                  is interesting for us and what, to our current
                  experience, are the advantages and disadvantages of
                  XMI over CDIF.},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings of the ICSE 2000 Workshop on Standard Exchange Format (WoSEF 2000)},
	Keywords = {scg-pub stefPub moose kzTools},
	Month = jun,
	Title = {{FAMIX}: Exchange Experiences with {CDIF} and {XMI}},
	Url = {http://scg.unibe.ch/archive/papers/Tich00mFamixCdifXmi.pdf},
  Year = {2000}}

@inproceedings{Tich00n,
	Abstract = {Recently exchange formats have gained lots of
                  attention. Multiple tools need to interact and/or
                  work on the same software system. Especially there
                  is a need to reuse parser technology. Within the
                  FAMOOS project we have developed a model for
                  representing object-oriented software systems at the
                  program entity level. The model has been designed
                  for language independence, extensibility and
                  information exchange. For the actual exchange of
                  data we are currently moving to use XMI, a standard
                  for model-based information exchange.},
	Address = {Los Alamitos CA},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Serge Demeyer},
	Booktitle = {Proceedings WCRE 2000 Workshop on Exchange Formats},
	Doi = {10.1109/WCRE.2000.891485},
	Keywords = {scg-pub stefPub moose kzMeta kzTools},
	Month = nov,
	Pages = {296--296},
	Publisher = {IEEE Computer Society Press},
	Title = {{FAMIX} and {XMI}},
	Url = {http://scg.unibe.ch/archive/papers/Tich00nFamixWCRE2000.pdf},
  Year = {2000}}

@techreport{Tich01y,
	Annote = {report notrefereed},
	Author = {Sander Tichelaar and St\'ephane Ducasse},
	Institution = {Institute of Computer Science and Applied Mathematics},
	Keywords = {kzPattern},
	Note = {University of Bern, IAM-TR-09-01},
	Title = {Pull Up/Push Down Method: an Analysis},
	Year = {2001}}

@inproceedings{Tich97b,
	Abstract = {In this workshop proposal we present a prototype
                  approach to help the extraction of architectural
                  information in the re-engineering process. Commonly,
                  the re-engineering life-cycle has been defined as a
                  succession of the following tasks: analysis of
                  requirements, model capture (understanding the
                  system), problem detection, problem analysis,
                  reorganization and change propagation. We have
                  evaluated the benefit of a prototyping approach with
                  a focus on model capture. Although prototyping is a
                  known approach to evaluate the application
                  feasibility, costs, comparison and validation of
                  choices, we focus in this paper on the aspects of
                  prototyping that are helpful for re-engineering.},
	Annote = {internationalworkshop},
	Author = {Sander Tichelaar and St\'ephane Ducasse and Theo-Dirk Meijler},
	Booktitle = {Proceedings of the ESEC/FSE Workshop on Object-Oriented Re-engineering},
	Editor = {Serge Demeyer and Harald Gall},
	Keywords = {stefPub scg-pub kzArchitecture},
	Month = sep,
	Note = {Technical Report TUV-1841-97-10},
	Publisher = {Technical University of Vienna, Information Systems Institute, Distributed Systems Group},
	Title = {Architectural Extraction In Reverse Engineering by Prototyping: An experiment},
	Url = {http://scg.unibe.ch/archive/papers/Tich97bArchExtraction.pdf},
  Year = {1997}}

@inproceedings{Uqui09b,
	Address = {New York, NY, USA},
	Author = {Uquillas G\'{o}mez, Ver\'{o}nica and Kellens, Andy and Brichau, Johan and D'Hondt, Theo},
	Booktitle = {Proceedings of the joint international and annual ERCIM workshops on Principles of software evolution (IWPSE) and software evolution (Evol) workshops},
	Doi = {10.1145/1595808.1595825},
	Isbn = {978-1-60558-678-6},
	Location = {Amsterdam, The Netherlands},
	Pages = {79--88},
	Publisher = {ACM},
	Series = {IWPSE-Evol'09},
	Title = {Time warp, an approach for reasoning over system histories},
  Year = {2009}}

@inproceedings{Uqui10a,
	Abstract = {Automatic and advanced merging algorithms help programmers to merge their modifications in main development repositories. However, there is little support to help release masters (integrators) to take decisions about the integration of published merged changes into the system release. Most of the time, the release master has to read all the changed code, check the diffs to build an idea of a change, and read unchanged code to understand the context of some changes. Such a task can be overwhelming. In this paper we present a dashboard to support integrators getting an overview of proposed changes in the context of object-oriented programming. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. We describe our experiment applying it to Pharo, a large open-source system, and report on the evaluation of our approach by release masters of several open-source projects.},
	Annote = {internationalconference},
	Author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
	Booktitle = {Proceedings of the 17th Working Conference on Reverse Engineering (WCRE'10)},
	Hal-Id = {inria-00531508},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {lse-pub pharo pharo-pub kzMerging},
	Labo = {dans},
	Misc = {Acceptance rate = 22/68 = 32\%},
	Month = oct,
	Pages = {55-64},
	Title = {Visually Supporting Source Code Changes Integration: the {T}orch Dashboard},
	Url = {http://rmod.inria.fr/archives/papers/Uqui10a-Torch-WCRE10.pdf},
	X-Country = {BE},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Proceedings = {yes},
  Year = {2010}}

@inproceedings{Uqui10b,
	Abstract = {Source code management systems record different versions of code. Tool support can then com- pute deltas between versions. However there is little support to be able to perform history-wide queries and analysis: for example building slices of changes and identifying their differences since the beginning of the project. We believe that this is due to the lack of a powerful code meta- model as well as an infrastructure. For example, in Smalltalk often several source code meta- models coexist: the Smalltalk reflective API coexists with the one of the Refactoring engine or distributed versioning system. While having specific meta-models is an engineered solution, it hampers meta-models manipulation as it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly navigation tool reuse. As a first step to solve this problem, this article presents several source code models that could be used to support several activities and proposes an unified and layered approach to be the foundation for building an infrastructure for omnipresent version browsing.},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
	Booktitle = {Smalltalks'2010},
	Hal-Id = {inria-00531613},
	Inria = {RMOD},
	Inriareport = {2010},
	Keywords = {stefPub lse-pub pharo pharo-pub kzMeta kzMerging},
	Title = {Meta-models and Infrastructure for Smalltalk Omnipresent History},
	Url = {http://rmod.inria.fr/archives/workshops/Uqui10b-Smalltalk2010-Metamodels.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Proceedings = {yes},
  Year = {2010}}

@article{Uqui11a,
	Abstract = {Source code management systems record different versions of code. Tool support can then compute deltas between versions. To ease version history analysis we need adequate models to represent source code entities. Now naturally the questions of their definition, the abstractions they use, and the APIs of such models are raised, especially in the context of a reflective system which already offers a model of its own structure.
	We believe that this problem is due to the lack of a powerful code meta-model as well as an infrastructure. In Smalltalk, often several source code meta-models coexist: the Smalltalk reflective API coexists with the one of the Refactoring Engine or distributed versioning system such as Monticello or Store. While having specific meta-models is an adequate engineered solution, it multiplies  meta-models and it requires more maintenance efforts (e.g., duplication of tests, transformation between models), and more importantly hinders navigation tool reuse when meta-models do not offer polymorphic APIs.
	As a first step to provide an infrastructure to support history analysis, this article presents Ring, a unifying source code meta-model that can be used to support several activities and proposes a unified and layered approach to be the foundation for building an infrastructure for version and stream of change analyses. We re-implemented three tools based on Ring to show that it can be used as the underlying meta-model for remote and off-image browsing, scoping refactoring, and visualizing and analyzing changes. As a future work and based on Ring we will build a new generation of history analysis tools.},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {internationaljournal},
	Author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
	Hal-Id = {inria-00629677},
	Impactfactor = {Impact factor (2010) 0.541},
	Inria = {RMOD},
	Inriareport = {2011},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {stefPub lse-pub raweb2011 pharo pharo-pub kzMeta kzMerging},
	Month = apr,
	Number = 1,
	Pages = {44-60},
	Title = {Ring: a Unifying Meta-Model and Infrastructure for {S}malltalk Source Code Analysis Tools},
	Url = {http://rmod.inria.fr/archives/papers/Uqui11a-RingJournalPaper-CSSJournal.pdf},
	Volume = {38},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BE},
	X-Proceedings = {yes},
  Year = {2012}}

@phdthesis{Uqui12b,
	Abstract = {Modern software is built by teams of developers that work in a collaborative environment. The goal of this kind of development is that multiple developers can work in parallel. They can alter a set of shared artifacts and inspect and integrate the source code changes of other developers. For example, bug fixes, enhancements, new features or adaptations due to changing environment might be integrated into the system release. At a technical level, a collaborative development process is supported by version control systems. Since these version control systems allow developers to work in their own branch, merging and integration have become an integral part of the development process.  These systems use automatic and advanced merging techniques to help developers to merge their modifications in the development repositories. However, these techniques do not guarantee to have a functional system. While the use of branching in the development process offers numerous advantages, the activity of merging and integrating changes is hampered by the lack of comprehensive support to assist developers in these activities.For example, the integration of changes can have an unexpected impact on the design or behavior of the system, leading to the introduction of subtle bugs. Furthermore, developers are not supported when integrating changes across branches (cherry picking), when dealing with branches that have diverged, when finding the dependencies between changes, or when assessing the potential impact of changes. In this dissertation we present an approach that aims at alleviating these problems by providing developers and, more precisely, integrators with semi-automated support for assisted integration within a branch and across branches. We focus on helping integrators with their information needs when understanding and integrating changes by means of characterizations of changes and streams of changes (i.e., sequence of successive changes within a branch) together with their dependencies.These characterizations rely on the first-class representation of systems' histories and changes based on program entities and their relationships rather than on files and text. For this, we provide a family of meta-models (Ring, RingH, RingS and RingC) that offer us the representation of program entities, systems' histories, changes and their dependencies, along with analyses for version comparison, and change and dependency identification. Instances of these meta-models are then used by our proposed tool support to enable integrators to analyze the characterizations and changes. Torch, a visual tool, and JET, a set of tools, actually provide the information needs to assist integration within a branch and across branches by means of the characterization of changes and streams of changes respectively.},
	Author = {Uquillas G\'{o}mez, Ver\'{o}nica},
	Hal-Id = {tel-00835097},
	Month = oct,
	School = {Vrije Universiteit Brussel - Belgium \& Universit\'{e} Lille 1 - France},
	Title = {Supporting Integration Activities in Object-Oriented Applications},
	Url = {http://rmod.inria.fr/archives/phd/PhD-2012-Uquillas-Gomez.pdf},
  Year = {2012}}

@article{Uqui13a,
	Abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Theo D'Hondt},
	Doi = {10.1016/j.scico.2013.08.002},
	Hal-Id = {inria-00862049},
	Impactfactor = {5-year impact factor (2012) 0.903},
	Inria = {RMOD},
	Inriareport = {2013},
	Journal = {Journal of Science of Computer Programming},
	Keywords = {stefPub lse-pub raweb2013 pharo pharo-pub kzMeta kzMerging kzVisualization},
	Title = {Visually charactering source code changes},
	Url = {http://rmod.inria.fr/archives/papers/Uqui13a-SCICO-Official-VisuallyCharacterizingChange.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BE},
	X-Proceedings = {yes},
  Year = {2012}}

@article{Uqui14a,
	Abstract = {Revision Control Systems (e.g. SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects.},
	Aeres = {ACL},
	Annote = {internationaljournal},
	Author = {Uquillas G\'omez, Ver\'onica and St\'ephane Ducasse and Andy Kellens},
	Hal = {http://hal.inria.fr/hal-01060524},
	Hal-Id = {hal-01060534},
	Impactfactor = {5-year impact factor (2012) 0.903},
	Inria = {RMOD},
	Inriareport = {2014},
	Journal = {Journal of Science of Computer Programming},
	Keywords = {stefPub lse-pub raweb2014 pharo pharo-pub kzMeta kzMerging},
	Title = {Supporting Streams of Changes during Branch Integration},
	Url = {http://rmod.inria.fr/archives/papers/Uqui14a-SCISCO-StreamsOfChanges.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
  Year = {2014}}

@inproceedings{Verw11a,
	Abstract = {Programming idioms, design patterns and application libraries often introduce
cumbersome and repetitive boilerplate code to a software system. Language
extensions and external DSLs (domain specific languages) are sometimes
introduced to reduce the need for boilerplate code, but they also complicate
the system by introducing the need for language dialects and inter-language
mediation.
To address this, we propose to extend the structural reflective model of the
language with object layouts, layout scopes and slots.
Based on the new reflective language model we can 1) provide behavioral hooks
to object layouts that are triggered when the fields of an object are accessed
and 2) simplify the implementation of state-related language extensions such as
stateful traits. By doing this we show how many idiomatic use cases that
normally require boilerplate code can be more effectively supported.
We present an implementation in Smalltalk, and illustrate its usage through a
series of extended examples.},
	Address = {New York, NY, USA},
	Aeres = {ACL},
	Aeresstatus = {aeres12},
	Annote = {topconference internationalconference},
	Author = {Toon Verwaest and Camillo Bruni and Mircea Lungu and Oscar Nierstrasz},
	Booktitle = {Proceedings of 26th International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA '11)},
	Doi = {10.1145/2048066.2048138},
	Hal-Id = {hal-00641716},
	Inria = {RMOD},
	Inriareport = {2011},
	Isbn = {978-1-4503-0940-0},
	Keywords = {raweb20011 scg lse-pub},
	Labo = {dans},
	Location = {Portland, Oregon, USA},
	Medium = {0},
	Pages = {959--972},
	Peerreview = {yes},
	Publisher = {ACM},
	Selectif = {oui},
	Title = {Flexible object layouts: enabling lightweight language extensions by intercepting slot access},
	Url = {http://rmod.inria.fr/archives/papers/Verw11a-OOSPLA11-FlexibleObjectLayouts.pdf},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {CH,FR},
	X-Proceedings = {yes},
  Year = {2011}}

@inproceedings{Vizc05a,
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Annote = {internationalworkshop},
	Author = {Aurora Vizca\'{\i}no and Nicolas Anquetil and Kathia Oliveira and Francisco Ruiz},
	Booktitle = {First Workshop on Ontology, Conceptualizations and Epistemology for Soft},
	Labo = {non},
	Publisher = {IEEE Computer Society},
	Selectif = {non},
	Tagnicolasa = {knowledge},
	Title = {Merging Software Maintenance Ontologies: Our Experience},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
	Year = {2005}}

@inproceedings{Webs05a,
	Abstract = {There can be no doubt that risk management is an important activity in the software engineering area. One proof of this is the large body of work existing in this area. However, when one takes a closer look at it, one perceives that almost all this work is concerned with risk management for software development projects. The literature on risk management for software maintenance is much scarcer. On the other hand, software maintenance projects do present specificities that imply they offer different risks than development. This suggests that maintenance projects could greatly benefit from better risk management tools. One step in this direction would be to help identifying potential risk factors at the beginning of a maintenance project. For this, we propose a taxonomy of possible risks for software management projects. The ontology was created from: i) an extensive survey of risk management literature, to list known risk factors for software development; and, ii) an extensive survey of maintenance literature, to list known problems that may occur during maintenance.},
	Address = {Washington, DC, USA},
	Aeres = {ACT},
	Annote = {topconference internationalconference},
	Author = {Webster, Kenia P. Batista and de Oliveira, Kathia M. and Anquetil, Nicolas},
	Booktitle = {Proceedings of the 21st IEEE International Conference on Software Maintenance},
	Doi = {10.1109/ICSM.2005.14},
	Isbn = {0-7695-2368-4},
	Labo = {non},
	Pages = {453--461},
	Publisher = {IEEE Computer Society},
	Selectif = {oui},
	Tagnicolasa = {analysis},
	Title = {A Risk Taxonomy Proposal for Software Maintenance},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Pays = {BR},
  Year = {2005}}

@inproceedings{Weih05a,
	Abstract = {We introduce Higher Order Messaging, a higher order
                  programming mechanism for dynamic object-oriented
                  languages. Higher Order Messages allow user-defined
                  message dispatch mechanism to be expressed using an
                  optimally compact syntax that is a natural extension
                  of plain messaging and also have a simple conceptual
                  model. They can be implemented without extending the
                  base language and operate through language bridges.},
	Aeres = {ACT},
	Aeresstatus = {aeres08},
	Annote = {internationalconference},
	Author = {Marcel Weiher and St\'ephane Ducasse},
	Booktitle = {Proceedings of International Symposium on Dynamic Languages (SDL'05)},
	Inria = {hors},
	Keywords = {stefPub jb06 listic kzLanguageDesign kzMessaging},
	Pages = {23--34},
	Publisher = {ACM Press},
	Selectif = {non},
	Title = {High-Order Messaging},
	Url = {http://scg.unibe.ch/archive/papers/Weih05aHigherOrderMessagingOOPSLA2005.pdf},
  Year = {2005}}

@inproceedings{Wern14a,
	Address = {Lugano, Suisse},
	Annote = {internationalconference topconference},
	Author = {Wernli, Erwann and Nierstrasz, Oscar and Teruel, Camille and Ducasse, St{\'e}phane},
	Booktitle = {Proceedings of the 13th International Conference on Modularity},
	Hal-Id = {hal-00958573},
	Keywords = {lse-pub stefPub kzLanguageDesign kzMessaging},
	Month = {apr},
	Title = {Delegation Proxies: The Power of Propagation},
	Url = {http://rmod.inria.fr/archive/papers/Wern13a-DelegatingProxy-AOSD.pdf},
  Year = {2014}}

@inproceedings{Wint02a,
	Abstract = {This paper presents a domain specific composition language called CoCo. The CoCo language has been
developed in the context of the PECOS project which aims at enabling component-based technology for a                certain class of embedded systems called "field devices".},
	Annote = {internationalworkshop},
	Author = {Michael Winter and Thomas Gen{\ss}ler and Alexander Christoph and Oscar Nierstrasz and St\'ephane Ducasse and Roel Wuyts and Gabriela Ar{\'e}valo and Peter M\"uller and Christian Stich and Bastiaan Sch\"onhage},
	Booktitle = {Proc. Second International Workshop on Composition Languages},
	Keywords = {pecos stefPub arevalo kzComponent kzLanguageDesign},
	Note = {In conjunction with 16th European Conference on Object-Oriented Programming (ECOOP) Malaga, Spain, June 11, 2002},
	Title = {Components for Embedded Software --- The PECOS Approach},
	Url = {http://rmod.inria.fr/archives/papers/Wint02a.pdf},
  Year = {2002}}

@inproceedings{Wuyt01a,
	Abstract = {Meta-programming is the act of using one system or
                  language to reason about another one. Reflection
                  describes systems that have access to and change a
                  causally connected representation of themselves,
                  hence leading to self-extensible systems . Up to
                  now, most of the reflective languages have been
                  implemented in the same paradigm. In this paper, we
                  propose \emph{symbiotic reflection} as a way to
                  integrate a meta programming language with the
                  object-oriented language it reasons about and is
                  implemented in. New to this approach is that any
                  element of the implementation language can be
                  reasoned about and acted upon (not only the self
                  representation), and that both languages are of
                  different paradigms. Moreover, every language
                  implementer that is faced with the problem of
                  allowing the base language to access the underlying
                  meta-language has to solve the problem of enabling
                  entity transfer between both worlds. We propose a
                  uniform schema, called upping/downing, to this
                  problem that avoid explicit wrapping or
                  typechecking. We illustrate this with SOUL (the
                  Smalltalk Open Unification Language), a logic
                  programming language in symbiotic reflection with
                  the object-oriented language Smalltalk. We show how
                  SOUL does logic reasoning directly on Smalltalk
                  objects, and how to use this to implement type
                  snooping},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {ECOOP 2001 International Workshop on MultiParadigm Programming with Object-Oriented Languages},
	Keywords = {stefPub kzReflection},
	Title = {Symbiotic Reflection between an Object-Oriented and a Logic Programming Language},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01a.pdf},
  Year = {2001}}

@inproceedings{Wuyt01c,
	Abstract = {Supporting reuse of existing pieces of code is one
                  of the main goals of software engineering. In the
                  name of reuse, module-based programming languages
                  came to be, only to be surpassed by object-oriented
                  technology. With the same motivation component-based
                  solutions are overtaking object-oriented solutions.
                  However, the delegation-only focus of
                  component-based programming risks of resulting in
                  the same problems that modular-based approaches ran
                  into. To counter this, we claim that one of th e
                  important problems that should be addressed by
                  component languages is the composition of
                  components. More specifically, we see component
                  languages where components are black-box
                  abstractions, and with (one or more) composition
                  languages to glue them tog ether. As an example we
                  show a functional (Piccola) and a logic (QSoul)
                  composition approach.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {First OOPSLA Workshop on Language Mechanisms for Programming Software Components},
	Keywords = {component kzComponents kzLanguageDesign Pecos stefPub},
	Title = {Composition Languages for Black-Box Components},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01c.pdf},
  Year = {2001}}

@inproceedings{Wuyt01d,
	Abstract = {This position paper presents some preliminary work
                  we made for applying declarative component oriented
                  design in the context of embedded devices. We
                  quickly describes COMES the model we develop and
                  present how logic rules can be used to describe
                  architectures.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse and Gabriela Ar{\'e}valo},
	Booktitle = {Ecoop 6th International Workshop on Component-Oriented Programming},
	Keywords = {component Pecos stefPub arevalo kzComponent kzArchi kzChecking},
	Title = {Applying Experiences with Declarative Codifications of Software Architectures on COD},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01d.pdf},
  Year = {2001}}

@inproceedings{Wuyt01e,
	Abstract = {In this paper we describe an interesting context to
                  study formal methods for component systems: embedded
                  devices. The context of embedded devices is highly
                  constrained by the physical requirements the devices
                  have to adhere to. As a result, component models for
                  embedded devices are not general purpose but geared
                  towards these constrained contexts. In this paper we
                  give the concrete setting of the Pecos project (a
                  project with as goal component engineering for
                  embedded devices). We describe the Pecos component
                  model, and show possibilities where we think formal
                  verification could be useful. We would like to use
                  this as a very concrete example to discuss formal
                  verification techniques.},
	Annote = {internationalworkshop},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Booktitle = {International Workshop on Specification and Verification of Component-Based Systems},
	Keywords = {scg-pub skip-doi snf01 jb01 component Pecos stefPub kzComponent kzLanguageDesign},
	Title = {Non-Functional Requirements in a Component Model for Embedded Systems},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt01e.pdf},
  Year = {2001}}

@article{Wuyt04a,
	Abstract = {The increasing complexity of software development
                  spawns lots of specialised tools to edit code,
                  employ UML schemes, integrate documentation, and so
                  on. The problem is that the tool builders themselves
                  are responsible for making their tools interoperable
                  with other tools or development environments.
                  Because they cannot anticipate all other tools they
                  can integrate with, a lot of tools cannot
                  co-operate. This paper introduces the classication
                  model, a lightweight integration medium that enables
                  unrelated tools that were not meant to be integrated
                  to cooperate easily. Moreover, the tool integration
                  is done by a tool integrator, and not by the tool
                  builder. To validate this claim, we show how to
                  integrate several third-party tools using the
                  classication model, and how it forms the foundation
                  for the StarBrowser, a Smalltalk browser integrating
                  different tools.},
	Annote = {internationaljournal},
	Author = {Roel Wuyts and St\'ephane Ducasse},
	Doi = {10.1016/j.cl.2003.08.003},
	Impactfactor = {Impact factor (2010) 0.541},
	Journal = {Journal of Computer Languages, Systems and Structures},
	Keywords = {stefPub kzIDE},
	Number = {1-2},
	Pages = {63--77},
	Publisher = {Elsevier},
	Title = {Unanticipated Integration of Development Tools using the Classification Model},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt04aClassifications.pdf},
	Volume = {30},
  Year = {2004}}

@inproceedings{Wuyt04x,
	Abstract = {This paper reports on the results of the Fifth
                  International Workshop on Object-Oriented
                  Reengineering in Oslo on June 15, 2004. It
                  enumerates the presentations made, classifies the
                  contributions and lists the main results of the
                  discussions held at the workshop. As such it
                  provides the context for future workshops around
                  this topic.},
	Annote = {workshopproceedings},
	Author = {Roel Wuyts and Serge Demeyer and St\'ephane Ducasse and Kim Mens},
	Booktitle = {Object-Oriented Technology. ECOOP'04 Workshop Reader},
	Doi = {10.1007/b104146},
	Isbn = {978-3-540-23988-8},
	Keywords = {scg-pub stefPub recast04 kzEditor},
	Pages = {177--186},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the {ECOOP}'04 Workshop on Object-Oriented Reengineering},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt04x-OOR04Report.pdf},
	Volume = {3344},
  Year = {2004}}

@article{Wuyt05a,
	Abstract = {Software for embedded systems must cope with a
                  variety of stringent constraints, such as real-time
                  requirements, small memory footprints, and low power
                  consumption. It is usually implemented using
                  low-level programming languages, and as a result has
                  not benefitted from component-based software
                  development techniques. This paper describes a
                  \emph{data-centric component model} for embedded
                  devices that (i) minimizes the number of concurrent
                  tasks needed to implement the system, (ii) allows
                  one to verify whether components meet their
                  deadlines by applying Rate Monotonic Analysis (RMA),
                  and (iii) can generate and verify schedules using
                  Constraint Logic Programming (CLP). This model forms
                  the foundation for a suite of tools for specifying,
                  composing, verifying and deploying embedded software
                  components developed in the context of the \pecos
                  project.},
	Aeres = {ACL},
	Aeresstatus = {aeres08},
	Annote = {internationaljournal},
	Author = {Roel Wuyts and St\'ephane Ducasse and Oscar Nierstrasz},
	Cvs = {PecosJournalPaper},
	Doi = {10.1016/j.jss.2003.05.004},
	Inria = {hors},
	Journal = {Journal of Systems and Software --- Special Issue on Automated Component-Based Software Engineering},
	Keywords = {scg-pub jb03 pecos stefPub kzComponent kzLanguageDesign},
	Misc = {SCI impact factor 0.744},
	Number = {1},
	Pages = {25--34},
	Publisher = {Elsevier},
	Title = {A Data-centric Approach to Composing Embedded, Real-time Software Components},
	Url = {http://scg.unibe.ch/archive/papers/Wuyt05aPecosElsevier.pdf},
	Volume = {74},
  Year = {2005}}

@inproceedings{Wuyt07a,
	Aeres = {OV},
	Aeresstatus = {aeres08},
	Annote = {workshopproceedings},
	Author = {Roel Wuyts and Serge Demeyer and Yann-Ga\"el Gu\'e{e}h\'{e}neuc and Kim Mens and St\'ephane Ducasse},
	Booktitle = {Object-Oriented Technology. ECOOP'06 Workshop Reader},
	Inria = {hors},
	Keywords = {stefPub kzEditor},
	Pages = {69--71},
	Publisher = {Springer-Verlag},
	Series = {LNCS},
	Title = {Report of the 7th ECOOP'06 Workshop on Object-Oriented Reengineering},
	Url = {http://rmod.inria.fr/archives/workshops/Wuyt07-WoorWorkshop.pdf},
  Year = {2007}}
