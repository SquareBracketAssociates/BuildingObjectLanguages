!! A word about prototypes

In this chapter we will give a first presentation of prototype-based language. We will present the key principles and some of the limits. 
Our goal is not to be exhaustive but to set the stage for the next chapter and provide some culture around prototypes but 
without diving in lengthly details. 

newtonscript javascript io Self
@@todo add a diagram
exnihilo creation

${cite:Dony92a}$



!!! Problems with state sharing

When clyde loses a leg, you do not want all your elephants to get only three legs.

Many prototype languages suffer from the following problem: when the parent changes its state, all the objects delegating to it 
get automatically impacted. Even in Javascript you get the exact problem as shown with the following script

[[[
o = {legs:4}
o1 = {}
o1.__proto__ = o
o.legs
>4
o1.legs
>4
o.legs = 3
o1.legs
> 3
]]]

In Self it was worse since modifying a children was modifying its parent. 

[[[
In self : unwanted children :-) 
o.legs
>4
o1.legs = 3
o1.legs
>3
o.legs
>3
]]]

This problem does not exist in Javascript and most prototype language
since writing to a field is local to the object. So even if the parent already has 
the same field with a value, the child is modified and get a new field.
Now the first problem still occur since the property legs when not found in the receiver is looked
up in the parent as shown before. 

[[[
o.legs
>4
o1.legs = 3
o1.legs
>3
o.legs
>4
]]]




!! Experimenting with Prototypes

In this chapter we want to build with you step by step a little prototype language named Propha. In prototype kernels, a single object can have instance specific state and more fundamental instance specific behavior. 

The kernel of Propha that we will build does not unify state and behavior as in Self. In particular, it means that the basic clone operation only clones state and delegation only look for behavior in another object when it does not find it in the current object. With this separation, we avoid the problem that when a parent changes its state, its sons are impacted. 
We can build other operations that would clone state as well as delegate to the cloned object. 

Our implementation is based on the use of anonymous class that we can dynamically inject in the superclass chain (between an instance and its class) and where we can then compile instance specific behavior. 

!!! A glimpse at our implementation
We will model object state with a dictionary and use the traditional instance variable semantic: each object has its own value. So each prototype will have its own dictionary of variables. 

Now for the behavior we will use anonymous classes. As we mentioned earlier, we can define hidden subclasses to a given class. Such subclasses have all the same format for their instances and they have their own method dictionary (see Figure *@fig:protoAnoPrinciple*).


+Using anonymous subclasses to have instance specific method dictionary.>file://figures/ProtoAnonymousSubclassPrinciple.png|width=40|label=fig:protoAnoPrinciple+


!!!! Delegation

Delegation can be easily implementated. When an object delegates to another ones, it means that when a method is not found in its method pool, the lookup should look in 
the ones of his parent or prototype. We can reuse the Pharo method dispatch and dynamically change the superclass chain as shown in Figure *@fig:protoAnoPrinciple*.
When ==o2== delegates to ==o1==, its behavior should point to the one of ==o1== (notice that in Propha state is not shared by delegation). At the implementation level, the superclass of anonymous class of ==o2== will point the anonymous class of ==o1==.


+Changing superclass chain to model delegation.>file://figures/ProtoAnonymousSubclassDelegation.png|width=90|label=fig:protoAnoPrinciple+



!!! Starting with ExNihilo creation

There are different ways to create prototypes and our language supports two ways: the exnihilo creation and the cloning. Let us start with the exnihilo one. 
Let us write some tests to make sure that we do not get semantic regression during our little journey. 

[[[
TestCase subclass: #ProphaTest
	...
]]]

Let first test that two exNihilo created objects have a distinct identity. 
[[[
ProphaTest >> testExNihiloCreateDifferentObjects

	self deny: Proto exNihilo == Proto exNihilo
]]]

Now we want to make sure that each created object has its own behavior so that it can have instance specific method. 
The following test uses the message ==class== to access to the behavior (the anonymous class in fact). 



[[[
testExNihiloCreateDifferentImplementationClasses

	| p1 p2 |
	p1 := Proto exNihilo.
	p2 := Proto exNihilo.
	self deny: p1 == p2.
	self deny: p1 class == p2 class.
]]]






[[[
Proto class >> exNihilo

	^ self installBehavior new
]]]

[[[ 
Proto class >> installBehavior

	^ Proto newAnonymousSubclass
]]]

A nicer solution in terms of API would be to compile 
- either in the class ==Proto== (the class from which ultimately inherits all the anonymous classes) 
- or in each of the anonymous classes
- or to get one prototype the root of delegation similar to ==Lobby== in Self. With this solution we would have to convert all the methods that we are defining the class ==Proto== into such prototype. We could do that by copying all the methods. 



The following snippet shows that we create two objects from nothing and that we can set to them different values and retrieve them. 

[[[
| o o1 |
o := Proto exNihilo.
o at: #foo put: 42.
o at: #foo.
>>> 42

o1 := Proto exNihilo.
o1 at: #foo put: 33.
o1 at: #foo.
>>> 33 
]]]

Let us turn that into a test.

[[[
testExNihiloCreation 

	| o |
	o := Proto exNihilo.
	o at: #foo put: 42.
	self assert: (o at: #foo) equals: 42.
]]]


Since we do not want to touch the Pharo compiler we represent object variables as a dictionary.

[[[
Proto >> initialize
	states := Dictionary new.
]]]

[[[
Proto >> at: aSymbol
	^ states at: aSymbol

Proto >> at: aSymbol put: aValue 
	^ states at: aSymbol put: aValue

Proto >> states
	^ states
]]]

Since we love representation of implementation and introspective system, let's define a little API for it. 

[[[
testMeta

	| o o1 |
	o := Proto exNihilo.
	o at: #foo put: 42.
	self assert: (o variableNames includes: #foo).  
	o1 := o clone.
	self assert: (o1 variableNames includes: #foo).  
]]]


[[[
Proto >> variableNames

	^ states keys
]]]


!!! Clone 

[[[
| o o1 |
o := Proto exNihilo.
o at: #foo put: 42.
o at: #foo.
>>> 42

o1 := o clone.
o1 at: #foo put: 33.
o1 at: #foo.
"> 33"
o at: #foo.
"> 42"
]]]

[[[
Proto >> clone	
	^ self copy
]]]

But now we are sharing the object state!
So we should copy the state too. 

[[[
Proto >> postCopy	
	states := self states copy.
]]]

We will see that this is not correct because now our two objects are sharing the same anonymous subclass and the same behavior. So adding one method will add this behavior to both objects while it should not. We are not in class-based languages.


!!! About behavior


[[[
Proto >> define: aString
	self class compile: aString classified: 'methods' 
]]]


[[[
| o o1 |
o := Proto exNihilo.
o at: #foo put: 42.
o at: #foo.
>>> 42

o1 := o clone.
o1 at: #foo put: 33.
o1 at: #foo.
>>> 33

o define: 'double  ^ (self at: #foo) * 2'.
o double. 
>>>84
]]]



!!! Instance specific behavior

[[[
o1 double. 
>>> 66    
do we want this? is cloning keeping a link to the parent? "
]]]

This is not really correct since it is more like class-based where multiple class are sharing 
common behavior. So we should create a new prototype with its own anonymous class and copy the 
the state of its mother prototype. Then after the two objects are autonomous. 

[[[
Proto >> clone
	
	| newObject |
	newObject := self class exNihilo.
	newObject states: self states copy.
	^ newObject
]]]

[[[
testCloningShouldNotShareBehavior

	| o o1 |
	o := Proto exNihilo.
	o at: #foo put: 42.
	o define: 'double  ^ (self at: #foo) * 2'.
	self assert: o double equals: 84.
	o1 := o clone.
	o1 at: #foo put: 33.
	self should:  [ o1 double] raise: MessageNotUnderstood 
]]]	

!!! Delegation
In class-based language, a class reuses and extends the behavior of other class using inheritance. In prototype-based language the pendant is delegation. With prototype delegation
when a method is not found in the receiver it is looked up in its proto or parent following a delegation chain and when it is found, it is applied to the receiver of the message. 

@@note It should be noted that delegation in class-based language is not the same as delegation in prototype languages because in class-based language delegation the receiver of the delegated message change. In prototype language delegation similarly than with class-based inheritance a method is looked in different behavior container and applied to the receiver of the message. 

Let us write some test to cover the semantics we want to implement. 
[[[
testDelegation

	| o o1 |
	o := Proto exNihilo.
	o at: #foo put: 42.
	o define: 'double  ^ (self at: #foo) * 2'.
	o1 := Proto exNihilo.
	self should:  [ o1 double] raise: MessageNotUnderstood. 
	o1 delegateTo: o.
	o1 at: #foo put: 33.
	self assert: o1 double equals: 66 
]]]


[[[
Proto >> delegateTo: anObject

	 self class superclass: anObject class 
]]]
	
	
In the model we implemented we make a difference between state and behavior. 
Cloning only clone the state and does not clone the state and delegation only share behavior. 

[[[
testDelegationOnlyShareBehavior

	| o o1 |
	o := Proto exNihilo.
	o at: #foo put: 42.
	o define: 'double  ^ (self at: #foo) * 2'.
	o1 := Proto exNihilo.
	self should:  [ o1 double] raise: MessageNotUnderstood. 
	o1 delegateTo: o.
	self should:  [ o1 double] raise: KeyNotFound
]]]
 
!!! Conclusion

