!! A class-based reflective minimal kernel

''"The difference between classes and objects has been repeatedly emphasized. In the view presented here, these concepts belong to different worlds: the program text only contains classes; at run-time, only objects exist. This is not the only approach. One of the subcultures of object-oriented programming, influenced by Lisp and exemplified by Smalltalk, views classes as object themselves, which still have an existence at run-time."'' B. Meyer Object-Oriented Software Construction

In this chapter we will explore a minimal reflective class-based kernel, inspired from ObjVlisp  ${cite:Coint86a}$. ObjVlisp has explicit metaclasses and supports metaclass reuse. It was inspired from the kernel of Smalltalk-78. In comparison Pharo has implicit metaclasses and no metaclass reuse except by basic inheritance but it is more stable as explained by Bouraqadi et al ${cite:Bour98a}$.

Studying this kernel is really worth since it has the following properties:
- It unifies class and instances (there is only one data structure to represent all objects classes included).
- It is composed of only two classes ==Class== and ==Object==. 
- It raises the question of meta-circularity infinite regression (a class is instance of another class....) and how to resolve it.
- It forces to revisit allocation, class and object initialization, message passing as well as bootstrap. 
- It can be implemented in less than 30 methods in Pharo. 

Just remember that this kernel is self described so we will start to explain some aspects and since everything is linked you may have to read the chapter twice to fully get it. 

!!! ObjVLisp's six postulates

The original ObjVlisp kernel is defined by 6 postulates ${cite:Coint86a}$. Some of them are looking dated by today standards and the 6th postulate is simply wrong as we will explained later. A solution is simple to add and implement.  Here we report them as stated in the paper for sake of historical perspective. 

# An object represents a piece of knowledge and a set of capabilities.
# The only protocol to activate an object is message passing: a message specifies which procedure to apply (denoted by its name, the selector) and its arguments.
# Every object belongs to a class that specifies its data (attributes called fields) and its behavior (procedures called methods). Objects will be dynamically generated from this model, they are called instances of the class. Following Plato, all instances of a class have same structure and shape, but differ through the values of their common instance variables.
# A class is also an object, instantiated by another class, called its metaclass. Consequently (P3), to each class is associated a metaclass which describes its behavior as an object. The initial primitive metaclass is the class Class, built as its own instance.
# A class can be defined as a subclass of one (or many) other class(es). This subclassing mechanism allows sharing of instance variables and methods, and is called inheritance. The class Object represents the most common behavior shared by all objects.
# If the instance variables owned by an object define a local environment, there are also class variables defining a global environment shared by all the instances of a same class. These class variables are defined at the metaclass level according to the following equation: class variable [an-object] = instance variable [an-object’s class].

+ObjVlisp kernel.>file://figures/ObjVlisp.png|width=60|label=fig:ObjVlisp+

!!! Kernel overview

Contrary to a real kernel, we do not consider arrays, boolean, strings, numbers or any other elementary objects as part of the kernel as this is the case in a real bootstrap such as the one of Pharo. Here the kernel focuses on understanding Class/Object core relationships.

*@fig:ObjVlisp* shows the two core classes of the kernel: ==Object== which is the root of the inheritance graph and is instance of ==Class==. ==Class== is the first class and root of the instantiation graph and instance of itself as we will see later. 

 Figure *fig:ObjVlispSingleton* shows that the class ==Workstation== is an instance of the class ==Class== since it is a class and it inherits from ==Object== the default behavior objects should exhibit. In addition the class ==WithSingleton== is an instance of the class ==Class== but in addition it inherits from ==Class== since this is a metaclass: its instances are classes. As such it changes the behavior of classes. The class ==SpecialWorkstation== is an instance of the class ==WithSingleton== and inherits from ==Workstation== since its instances exhibits the same behavior as ==Workstation==.

+ObjVlisp kernel with specialized metaclasses.>file://figures/ObjVlispSingleton.png|width=70|label=fig:ObjVlispSingleton+

The following two diagrams *@fig:ObjVlispSingleton* and *@fig:kernel2* and will be explained step by step during all this chapter. What is interesting to see is that a key to understand such reflective architecture is to use the fact that message passing always looks up method in the class of their receiver and then follow the inheritance chain as shown in Figure *@fig:kernel2*.

+Understanding metaclasses using message passing.>file://figures/ObjVlispSingleton2.png|width=70|label=fig:ObjVlispSingleton2+


!!! Instances

In this kernel, there is only one instantiation link, it is applied at all the levels as shown by Figure  *@fig:Instantiation*: 
%+Simple instances.>file://figures/Ref-Instances.png|width=50|label=fig:Instances+
- Terminal instances are obviously objects: a workstation named ==mac1== is an instance of the class ==Workstation==, a point ==10@20== is instance of the class ==Point==. 
- Classes are also objects instances of other classes: the class ==Workstation== is an instance of the class ==Class==, the class ==Point== is an instance of the class ==Class==.

+Chain of instantiation: classes are objects too.>file://figures/Ref-InstantiationLink.png|width=70|label=fig:Instantiation+

In our diagram, we represent objects (mainly terminal instances) as round corner rectangles with the list of variables.
Since classes are objects, when we want to stress that classes are objects we use the same graphical convention as shown in Figure *@fig:Instantiation*.





!!!! Handling infinite recursion

A class is an object therefore instance of another class its metaclass that is an object too instance of a metametaclass that is an object too instance of another a metametametaclass...... To stop this potential infinite recursion is similar to solutions proposed in many meta circular systems: we have one entity instance or described by itself. Here: 
- ==Class== is the initial class and metaclass.
- ==Class== is instance of itself and directly or undirectly all other metaclasses are instances of ==Class==.

We will see later the implication of this self instantiation at the level of the class structure itself. 

!!! Understanding metaclasses 

The model unifies classes and instances. When we follow the instance related postulates of the kernel we get:
- Every object is instance of a class.
- A class is an object instance of a metaclass.
- A metaclass is only a class that generates classes.

At the implementation level there is only one kind of entity: objects. There is no special treatment for classes. Classes are instantiated following the same process than terminal instances. There are sent messages the same way other objects are sent messages too. 

This unification between instances and classes does not mean that we do not distinguish objects and classes. 
Indeed not all the objects are classes. In particular, the sole difference between a class and an instance is the ability to respond to the creation message: ==new==. Only a class knows how to respond to it. Then metaclasses are just classes whose instances are classes as shown in Figure *@fig:Instantiation*.

+Everything is an object. Classes are just objects which can create other objects and metaclasses are just classes whose instances are classes.>file://figures/instancePatatoid.png|width=50|label=fig:Instantiation+


!!! Instance structure 

The model does not really bring anything new about instance structure when compared with languages such as Pharo or Java.

Instance variables are an ordered sequence of instance variables defined by a class. Such 
instance variables are  shared by all instances.
The values of such instance variables are specific to each instance. 
Figure *@fig:Ref-Instances* shows that instances of ==Workstation== have two values: a names and a next node. 


+Instances of ==Workstation== have two values: their names and their next node.>file://figures/Ref-Instances.png|width=60|label=fig:Ref-Instances+

In addition we should note that an object has a pointer to its class. As we will see when we will come to inheritance,  every object possesses an instance variable class (inherited from ==Object==) that points to its class. 


Note that this management of class instance variable defined in ==Object== is specific to the model. 
In Pharo for example, the class identification is not managed as a declared instance variable but as an element part of any object. It is an index in a class-table.

!!! About behavior

Les us continue with basic instance behavior. As in modern class-based languages, this kernel has to represent how methods are stored and looked up. 

Methods belong to a class. They define the behavior of all the instances of the class.
They are stored into a method dictionary that associates a key (the method selector) and the method body. 

Since the methods are stored in a class, the method dictionary should be described in the metaclass. Therefore, the method dictionary of a class is the ''value'' of the instance variable ==methodDict== defined on the metaclass ==Class==. Each class will have its own method dictionary.

!!! Class as an object

Now it is time to ask us the minimal information that a class should have. 
Here is the minimal information required:
- A list of instance variables to describe the values that the instances will hold. 
- A method dictionary to hold methods.
- A superclass to look up inherited methods.

This minimal state is similar to the one of Pharo: Pharo ==Behavior== class has a format (compact description of instance variables), method dictionary and superclass link. 

In our kernel we will had a name so that we can identify the class. As an instance factory the metaclass Class possesses 4 instance variables that describe a class:
- name the class name
- superclass its superclass (we limit to single inheritance)
- i-v the list of its instance variables 
- methodDict a method dictionary

Since a class is an object. A class possesses the instance variable ==class== inherited from ==Object== that refers to its class as any object.

+==Point== as an object.>file://figures/Ref-PointClassAsObject.pdf|width=60|label=fig:PointClassAsObject+

!!!! Example: class Point

Figure *@fig:PointClassAsObject* shows the instance variable values for the class ==Point== as declared by the programmer and before class initialization and inheritance takes place. 

- It is an instance of class ==Class==: indeed this is a class.
- It is named =='Point'==.
- It inherits from ==Object==.
- It has two instance variables: x and y. After inheritance it will be three instance variables: class, x, and y.
- It has a method dictionary. 


+==Class== as an object.>file://figures/Ref-ClassClassAsObject.pdf|width=60|label=fig:ClassClassAsObject+

!!!! Example: class Class

Figure *@fig:ClassClassAsObject* describes the class ==Class== itself. Indeed it is also an object.
- It is an instance of class ==Class==: indeed this is a class.
- It is named =='Class'==.
- It inherits from ==Object==
- It has five instance variables: 'name superclass i-v methodDict'.  
- It has a method dictionary. 



!!!! Everything is an object

Figure *@fig:Instanceshier* describes a typical situation of terminal instances, class and metaclasses when looked at them using an object perspective.

+Through the prism of objects.>file://figures/Ref-InstanceGlobalPicture.png|width=70|label=fig:Instanceshier+





+Sending a message is two step process.>file://figures/Ref-LookupNoError.png|width=60|label=fig:LookupNoError+
!!! Sending a message 
@sec_message
Sending a message is a two step process as shown by Figure *@fig:LookupNoError*
# the method corresponding to the selector is looked up in the class of the receiver and its superclasses.
# the method is applied to the receiver. It means that ==self== or ==this== in the method will be bound to the receiver.  

Conceptually sending a message is the following: 

[[[
sending a message (receiver argument)

	 return apply (lookup (selector classof(receiver) receiver) receiver arguments)
]]]


!!!! Method lookup

In this kernel the postulate 2 states that the only way to kick computation is vai message passing. 

Two steps process:
# The lookup starts in the ""class"" of the ""receiver"".
# If the method is defined in the method dictionary, it is returned. Otherwise the search continues in the superclasses of the receiver's class. If no method is found and there is no superclass to explore (if we are in the class ==Object==), this is an error

The method lookup walks through the inheritance graph between classes using the superclass link. Here is a possible description of the lookup algorithm. This lookup is conceptually the same in Pharo where all methods are public and virtual. There is no statically bound method, even class methods are looked up dynamically. This allows the possibility to define really elegant and dynamic registration mechanism. 


[[[
lookup (selector class receiver):
   if the method is found in class then return it
      else if class == Object
           then send the message error to the receiver
           else lookup (selector superclass(class) receiver) 
]]]

+When a message is not found, another message is sent to the receiver supporting reflective operation.>file://figures/Ref-LookupWithError.png|width=60|label=fig:LookupWithError+

While the look up happens at runtime, it is often cached based on the class of the receiver and per call site.
When the method is not found, the message ==error== is sent as shown in Figure *@fig:LookupWithError+*. It corresponds to the ==doesNotUnderstand:== in Pharo and it is an important reflective hook. For example, it is possible to implement proxies (objects representing other remote objects) or compile code on the fly by redefining locally such message. 
Now it should be notes that the algorithm is not really good because in case of error
there can be a mismatch between the number of argument of the method we are looking for and the 
number of argument of the error message. 

A better way to handle error is to decompose the algorithm differently as follows: 

[[[
lookup (selector class receiver):
   if the method is found in class then return it
      else if class == Object
           then return nil
           else lookup (selector superclass(class) receiver) 
]]]

And then we redefined sending a message as follows: 

[[[
sending a message (receiver argument)

   methodOrNil 
   methodOrNil = lookup (selector classof(receiver) receiver).
   if methodOrNil is nil
      then return send the message errorr to the receiver
      else return apply(methodOrNil receiver arguments)
]]]



!!! Refresh on self and super semantics

Since our experience showed us that even book writers got key semantics points of object-oriented programming totally wrong, 
we just refresh some facts that normally programmers familiar with object-oriented programming should fully master. For further readings refer to Pharo By Example or the Pharo Mooc available at *http://mooc.pharo.org*. 


- ""self"" / ""this"". 'self always represents the receiver of the message. The method lookup starts in the class of the receiver.  
- ""super"". super always represents the receiver of the message (and not the superclass). The method lookup starts in the superclass of the class containing the super expression (and not in the superclass of the class of the receiver whose semantics loops forever in case of inheritance tree of three classes - We let you to find how).

+self always represents the receiver.>file://figures/LookupWithSelfInSuperclassMethod.png|width=40|label=fig:LookupWithSelfInSuperclassMethod+

Looking at Figure *@fig:LookupWithSelfInSuperclassMethod*  we see that the key point is that ==B new bar== returns 50 since
the method is dynamically looked up and self represents the receiver i.e., an instance of the class ==B==. What is important to see is that self acts as a hook and that subclasses code can be injected in superclass code. 

[[[
A new foo
>>> 10 
B new foo
>>> 50
A new bar
>>> 10
B new bar
>>> 50
]]]


+super represents the receiver but the method lookup method is modified and starts in the superclass of the class using super. .>file://figures/LookupWithSuperInSuperclassMethodThreeClasses.png|width=40|label=fig:LookupWithSuperInSuperclassMethodThreeClasses+


For super, the following *@fig:LookupWithSuperInSuperclassMethodThreeClasses* shows that the super is not static but represents the receiver, hence ==C new bar== returns 100 and not 20 or 60. 

[[[
B new bar
>>> 20
C new bar
>>> 100
]]]


As a conclusion, we can say that ==self== is dynamic: Using self the lookup of the method begins in the class of the receiver. ==self== is bound at execution-time. We do not know its value until execution time. ==super== is static: while the object it will point to is only know at execution time, the place to look for the method is know at compile-time: it should start to look in the class above the one containing super. 





!!! Inheritance

There are two aspects of inheritance: 

- One static for the state where subclasses get superclass state. This instance variable inheritance happens once at class creation time. In traditional languages it happens at compilation-time. 

- One dynamic for behavior where methods are looked up during program execution.  There the inheritance tree is walked at run-time. 

Let's look at these two aspects:

!!!! Instance variable inheritance
Instance variable inheritance is done at class creation time and from that perspective static and performed once.
When a class ==C== is created, its  instance variables are the union of the instance variables of its superclass
with the instance variables defined locally in class ==C==.
Languages will define if they accept instance variables with the same name or not and the exact semantics of instance variable inheritance. In our model, we decide to use the simplest way: there should be no duplicate. 

[[[
instance-variables(C) =
	OrderedUnion (instance-variables(superclass(C)), local-instance-variables(C))
]]]

A word about ordered union: the union should make sure that the location of inherited instance variables are kept ordered compared to the superclass because in general we want that methods of the superclass can be applied to subclasses without recompilation. 
If a method uses a variable at a given position in the instance variable lists, applying this method to instance of subclasses should work.

!!!! Method lookup
At runtime methods are looked up as described previously in Section *@sec_message*. 
Methods of the superclasses are reused and apply to instances of subclasses. Contrary to instance variable inheritance this part of inheritance is dynamic. 


!!!! Inheritance graph

==Object== represents the minimal behavior any object should understand. For example, returning the class of an object, being able to handle errors, initializing an object.
==Object== is the root of the hierarchy.
A  Workstation is an object (should at least understand the minimal behavior), so the class ==Workstation== inherits from the class ==Object==.
A class is an object (it should understand the minimal behavior) so the class ==Class== inherits from class ==Object==. In particular, the ==class== instance variable is inherited from ==Object== class.

Figure *@inheritancegraph* shows the inheritance graph without the presence of instantiation. 

+Full inheritance graph.>file://figures/Ref-InheritanceGraph.png|width=50|label=fig:inheritancegraph+


!!! Inheritance and instantiation together

Now that we saw independently the instantiation  and the inheritance graph we can look at the complete picture. 
Figure *@fig:kernel2* shows the graphs and in particular how such graph are used during message resolution: 
- the instantiation link is used to find the class where to start to look the method associated with the received message. 
- the inheritance link is used to find inherited methods. 

This process is also true when we send messages to the classes themselves. There is no difference between sending a message to an object or a class. The system ''always'' performs the same steps. 

+Kernel with instantiation and inheritance.>file://figures/Ref-KernelTwo.png|width=70|label=fig:kernel2+


!!! Object creation 


[[[
	Creation of instances of the class Point
	[Point new :x 24 :y 6]
	[Point new]
	[Point new :y 10 :y 15]
	Creation of the class Point instance of Class
	[Class new 
	          :name ‘Point’
	          :super ‘Object’
	          :i-v #(x y)
	           :methods (x ...display ...)]
]]]

!!!! Object creation: new 

Object Creation = initialisation O allocation

Creating an instance is the composition of two actions: memory allocation: allocate method object initialisation: initialize  method
[[[
(new aClass args) = (initialization (allocation aClass) args)
[aClass new args] =                  [[aClass allocate] initialize args]
new creates an object: class or final instances new is a class method
]]]

!!!! Object allocation: Allocate

Object allocation should return:
Object with empty instance variables
Object with an identifier to its class
Done by the method allocate defined on the metaclass Class 
allocate method is a class method

[[[
[Point allocate]  
>>> #(Point nil nil) for x and y

[Workstation allocate] 
>>>#(Workstation nil nil) for ‘name’ and ‘nextNode’

[Class allocate]
>>>#(Class nil nil nil nil nil) for name, super, iv, keywords and methodDict
]]]

!!!! Object initialization

To specify the value of the instance variables by means of keywords (:x ,:y) associated with the instances variables

[[[

[ Point new :y 6  :x 24]  
>>> [ #(Point nil nil) initialize (:y 6 :x 24)]
>>> #(Point 24 6)

]]]

initialize: two steps
get the values specified during the creation. (y -> 6, x -> 24)
assign the values to the instance variables of the created object.

!!! Instance creation: Role of the metaclass

+Metaclass role during instance creation.>file://figures/Ref-InstanceCreationMetaclassRole.png|width=90|label=fig:metaclassrole+

!!! Class creation: Role of the metaclass

+Metaclass role during class creation.>file://figures/Ref-ClassCreation.png|width=90|label=fig:ClassCreation+


!!! Class class

Now we get a better understanding of what is the class ==Class==.
The class ==Class== is 
- Initial metaclass
- It defines the behavior of all the metaclasses.
- It defines the behavior of all the classes.

In particular, metaclasses defines three messages related to instance creation. 
- The ==new== creates an initialized instance of the class. It allocates the object using the class message ==allocate== and then initialize it by sending the message ==initialize== to the instance. 
- The ==allocate== message. As message ==new== it is a class message. It allocates structure for newly created object. 

- Finally the message ==initialize==. This message has two definitions one on ==Object== and one on ==Class==. 

There is a difference between the method ==initialize== executed on an instance creation and the class ==initialize== method. 

- The first one is a method defined on the class of the object and potentially inherited from ==Object==. On ==Object== this ==initialize== method just extract from the argument list the value corresponding to each instance variables and sets them in the corresponding instance variables. 

- The class ==initialize== method is executed when a new instance representing a class is executed. The message initialize is sent to the newly created object but its specialisation for classes will be found during method lookup and it will be executed. Usually this method invokes the default ones because the class parameter should be extracted from the argument list and set in their corresponding instance variables but in addition, instance variable inheritance and class declaration in the class namespace is performed. 









!!! Instantiation hierarchy
+Full instance hierarchy.>file://figures/Ref-InstanceGlobalPictureWithObject.png|width=60|label=fig:Instanceshier+









!!! Abstract Metaclass

+Abstract metaclass.>file://figures/Ref-Abstract.png|width=90|label=fig:Abstract+

+Abstract metaclass at work.>file://figures/Ref-AbstractLookup.png|width=90|label=fig:AbstractLookup+



!!! Further readings

The kernel presented inIt is a kernel with explicit metaclasses and as such it raised metaclass composition problems as explained in Bouraqadi et al. 
excellent article ${cite:Bour98a}$
